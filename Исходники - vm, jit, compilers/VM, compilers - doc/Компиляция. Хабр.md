---
created: 2023-03-14T12:00:40 (UTC +03:00)
tags: [компиляция,лексический анализ,flex]
source: https://habr.com/ru/post/99162/
author: Artyom Skrobov
---

# Компиляция. 1: лексер / Хабр

> ## Excerpt
> Меня всегда завораживало таинство рождения программой программы. К сожалению, российские вузы уделяют мало внимания сей интереснейшей теме. Рассчитываю написать...

---
Время на прочтение 7 мин

Количество просмотров 87K

Меня всегда завораживало таинство рождения программой программы. К сожалению, российские вузы уделяют мало внимания сей интереснейшей теме. Рассчитываю написать серию постов, в которых поэтапно создадим маленький работоспособный компилятор.

Первые посты серии уже подготовлены, и бета-тестировались в одном маленьком и наглухо закрытом сообществе. Тем не менее, я буду продолжать их править с учётом пожеланий почтенной хабрапублики.

### Далее в посте:

1.  С какой стати писать компиляторы?
2.  Общий план
3.  Анализ текста
4.  Практический пример
5.  Как это работает?

### С какой стати писать компиляторы?

Разве не все нужные языки программирования уже написаны? Кому в наш просвещённый век может понадобиться писать собственный компилятор?

> Everything that can be invented has been invented.  
> _\--Charles H. Duell, Director of U.S. Patent Office, 1899 (attributed)_

> Что было, то и будет; и что делалось, то и будет делаться, и нет ничего нового под солнцем.  
> _\--Екклесиаст 1:9 (ок. 3 в. до н.э.)_

Во-первых, языки постоянно создаются и развиваются. Из ныне популярных, Ruby, PHP, Java и C# были _созданы_ на нашей памяти, а бурно применяться начали несколько лет назад. Прямо сейчас Майкрософт проталкивает новый язык F#, и он — учитывая мощь Майкрософт — наверняка также войдёт в число общеупотребимых.  
До сих пор остаются ниши для новых языков: например, не прекращаются попытки придумать _удобный_ императивный язык для параллельного программирования.

Во-вторых, используемые в компиляции приёмы (в первую очередь, парсинг по грамматике) имеют массу других приложений. Часто есть потребность в преобразованиях source-to-source (рефакторинг, перевод кода на другой язык, и т.п.), когда нужно разобрать текст на языке программирования, обработать его, и вывести обработанный текст (на том же или на другом языке).

Безусловно, компиляция — довольно экзотичное занятие для программиста, где-нибудь в одном ряду с программированием

~огромных боевых человекоподобных~

роботов. Однако у всего этого есть практические применения, в отличие от многих других экстравагантных программистских хобби.

### Общий план

![](data:image/gif;base64,R0lGODdhkAC7APcAAPv2+fn47O747//v7+/45/fv7+7y9/fv5+/v7+/v5/Dw3vXn9/fn7+fv7+bx5/fn5+Xx3vjn3u/n7+/n5+vs1u/n3ufn7+fn5+fn3vPd8OPrzvHe597n5/Hd3t3n3ubd6Ofe3tzl1urc1t7c3uTfuOfV3tvV1trSzsvbxrXapM3DxNm5qrq4uNm0brGwqKW1o5u4n6KwiZmtnZSulJylnoyvjJSrioytlMSVeImwe9mSQJSllIyllIyljISllISljJiYl4uclYycjJaVhIechIScjIiUjIWUhIWWeHubbNtnY4mIh3uQfXCXbIaHcdhlQKCCPYSFYNhbUliaWXuEYtdaRXKEdNZaNLBlX3t7dWuEYoV2ZHt7Y9VSRXt7WnB7dNVSOXt7UtRSLnN7WnJ+SE+QRmp7a3N7UthKPmp7Y3tzWnVzY3tzUnBzb51mONdKLsJQRc5KPnNzWmR7VnNzUsJOOc5KLdhCOHFzScNOLGlzUmJzY9dCKWJzWs5CN69QQGtrY0WHMMxCKWxrUs5CIMNCONM5PGtqSNc5KNI5MVpqY1prWmdjXMs5Jq5COdIwNFRuPVpnUsI1NodRQFpjWpRPJ1JnWrM9KV5jQltjSs0vJlJkUrM7HmVXWUpkUyp9I1ZjM641NlpaUllaSlhWW5U9MFVaQk9aUlZaObEuKVpSUklaSlJaLLAsIVtQRiB4ECJ4CFFQUlJQR1RROa8pFRZ3CFNQMRl2AHc9LkpPRpQtLkFSQkJQSkpOOQ92AJAvE5QpISFmE0dMMUlMKS1YLBtoBUhNGz9KQjxLOQ9oAkJCPXcqLUVCLY8hEnUnITlCLnApEjBCMj85M0M2IYYVDUcrLys6KS81MkctEywyIWsSDC0wFCkuKSAyISEsFR8pIUoVFBUsFCIfIyUdGEgNBCgZEBgcGBAhEBgaECEWBRAbGBAYEBAZBwgaEAYZBhAQEBAQCBAQAAgQEAgQCBcHCx0FAAQQAAAQCAgHEAgICAgIAAAIAAAFCAgACAgAAAAAACwAAAAAkAC7AAAI/wAxCBSY4ECCggcSJlAwEIPCgxAPJjxAoCKBhAQiHiwgQECBjwUMSkRIsaJHkB8LkkTJsmXKjSwnlrRI8yRKjQlcQhR54ASICRWCTog4YShRiEZxKl1KNClTnAgQPJ2qsQDVq0qLat2qNYGKCxIkIBD78WGCqGgRvIQY0irMlmZvFgR5wKXdunbzyoWKV69OplrDCpbgdUTYAmmlFhWbOG3Rs40bg0SrVLLfyy2xHoyK0vLarFwFd1WBYWNjwWkRp0WtOjLasJQ1RsZMG2REqbdvc56ceC9orkNHg9gI+TVhtxAb58QdNSECkcXTVq1NnSVMtgwOevAQ3fdb5L+BB/9P4JP4Qa4qIzZoMFbCRwZWOSSQ8ICBBfBTq//1fr6ohxAoaMDBBTXEYGAKCVxgnlL8NSVeV+XlhFRwSRXAwIUMSMDBfyik4GEKKASowXyJ5aefdTnZhpN/KQTySiA1oPBKLbfU0oQHCqrFVIMTPviYT4+tOFRpF0qFQQgwTOFiLbUU88ornwSSRAoePGeQWRHxx6Nm/U0QwpKwfJLCJ0y+kgQHQXIpZAI+FmXCT04hpV0C2XmgQQ6B1OJLLZ80MQMMMzThIpQIfqQjQrhFNNFZil4JmVVYavRQV0WFUMaMtQSCApm3vJLDBBJUMAECXSUX1VKKTcgmm8C9mWZTCcj/x8CRUzBZi6ceWLDYBR7M8EkZKKhFmY5WhhRkXZCxaqWiCCF2wKmM1gUdqw2wcGkgL5iQ5545zCdqAa9yBm1yExmVaJdbuRpnfwdJMAEKtfpyyycvoBncA26xsAMHBzDA2QFFGapWAe65i4EHHIylMLhWNbAZfAVhwIEF7vI6wYUJVBArAg98O4EJFyAQApncAhwkBxyUlnBsB5VG5wMPBBaSqMC5q25WZ33kQRPF3FJjDvYCd1YDKAedgMsXlIowUGe5m4DDpY2K2wEw01fBdgM2UMACQFEgEFhawRz1yHrWkgPASQMV1HZRG3nxrAlkkAFQYTHwwNEYiCCCBqLS//wxnKAhm0IwTN6iKZp+b4UWrx3mMEUZZUyRQwoheCDQCzXAoPmRKeTQRBIwoCDC1SjEkEMSMfLtwYcgYoBCDTnkkDoGYoVo+8g+F5MDBhNgoEGHKWjuoQYhZAxgiCHwfoKHJkzAQYfCB+gBVyY0j+5WEiZxy561TMEd7+JVOVQKl/LZRBNkvlJGCr03kYy8gZD/yvZ7xn/nJ9vT+EkSKHy5ZzFJyAGZ9NSpKaAAYVP4xJOA9Ylk3EJ3AglBDC4VjEAoUH2Uw0ASLpgEJLnoEyHa4JOe1CcU9A4DI/iY9VgFnLEkoAy+kJfuKnABDFQgZsCpHAy2pSkLWGBMTBJTCP+0p6coQQlTeypDEorxiU8Eg363yIEHAiEvX1iwDI6b354MGIIpYApYVKRRDipwJxLGCF5FpFISXiGvJsAAf5lCQRL49AIUsMCLIDRYCqvXI65cyAOfiGGnYOAutQFnVil4RTF88Qoq+WcGwahf57RYC2ABqAmRvFUwchCiN+7JFyAsA5MYWQMcXeAFcHzFFLpYDCaB0WdmC0EOnqQ7DXyAAZtqUhmGSLhblGGAL3pjLD8ggRA0wXs1xMAH/kYc8cQslzSqxQvo5B/xWCqGmeLOUDywqRpFMQc9Y6QJcbSpGPoCmSmrVY0aCcMYBiIENfwPDG+RjGCkYArJoNEuqej/s8nB0Z4hGJCl5lcLGIBTT74IRhmaoIVjttKSHADBCEaQTAz8xAQpzMmD2FTO/MFAoxOYHnDKmc8psOpoU/SZL8G5vU+EYAS8K6cvkgE0DNQwCfK6FfmwicwKCCQHvmjlJpvwwHOiIBAO9IXsFsmn/kXQi0xqQg5GGYwaXEA+GOBZEd3YvwuIqoaiqt5PrhekKdJoezWIWu+Ag4EUlA2A9kIAygKh0kCAM4YuXav/uAWUGrKUkffcUxQ98AGfYqAGTAWg+4qRDAMGohiE8xxCKzmFyibwFbCAheT29KLpiQ2S9NMf/0CwgaKE1QQuE0/LONCE+W3Pe+AD31YqAAOm/+LqMVctw/YMN9VF5pV3ezWbUDDw10ZOQbBSLKxFaxvDZJyvlUZ97IxyME9Gni8JTEiCds9ngxzkU7M4ah6vMBnaWwGreVpxFVkfw4EGwACzNdJUbHMIA1sFIwki7R0HdFujMtSARqAMgV63VYsaDBeci3wFvASZ3KB8oL4xLMb5amTUQE4XhsUoxjvBBxvV5GCdq+ydqEbggRq4iMLJACDf0ts8q2wUZSGYQyQZmYQRSeACOMYxApKWyyRabgK8GlmEkVADc7o0LF6iYlDTWoFlejeG7DRnB4ESAlkCOBgxmEI4DRjIoHouwsHoH5CdMoGpMmkKfsOxBZ4HA/QRzv8XuwQK76q3QtXi+HmXimFVRyRXHV/gAyhI0iJBiQIMMOADF0iknlEw1Rq5FCzFVHIyDEzaCgBVfyhopxU1kGMPTMFn9QxsDBnY3Mk98YE1/kCVNVaUCwB11CJYzFBQC7MKZLoYsIgzi8eKM608TwuZ7B7lrka80kWuRWWLQQgywABjlqkGsuzZvExYqW0pFSghxan+dlqmHFQZA+/d0327CEsG0s/bWmBjp7z9GN8V2syVjDWoOPACYE3vAxwA5yZtOIFlqvdV/YlZVDYEg/IFMXJKmlFVL3BrPk3unkyqKpqQMOgwi+AAR2ogk3Jw1YOtUU/szJ2LppCEeCW0CVX/LkOG48gpXzRBAzubkTtr4KEalEELHgDqLXIt4EotMX4hapH6TBgUm40V4KwSC6MUFAIW1KAJZQiEBQOxUE6CRWRttmATf8U/HFdABuebghaadzVjWhYGzvNpD+YAOWDB8FY5KPgFPwEJGHxPC4GAxM2PKvX98Q7cCQxGMEhoVxRwoAZR+sQqC6mBHTox8YpHAQgYQEbu/HtdxVmVQdqjFiS7BzE3HsxYQFC9KknAX/JRzUYIM/BTkQooMENpwtpZDKs+jwWtixnaEpYyCVjuAgG9kEEaYAIWvOAFLDggqRiwnf8IOCwwQ4AHVIC5zJ0AARjqneWPjvTfsLBN95oA/8zAT/5SierG7TQb7eT6/cdgDz2rQkxMKGWU9w9lUg+6PObZApJXlf//AOh+EoBoebJxhgYfgyEa9td+S+F+Adgmb0IUyGEVE9h/ZAZ+5yEhElIhLYQU4HIebrEYwbU7n2cUBoEfHgh/C9J+Dyg0I3B0FOh+01F/D6gCLHCDf/cxjMACq/J+CUADbYABiQICsUADCAA+R3UrZgJzJnACKNCEqDUdLJAFJsBCLHSDFNKC5PeCKnQ0FOIC6FEAJuBi47Fe7SYOygAE5sAIUlEBINAGLAAwK1IAQKggRmEC47AEXsgAIEAESXA+M6AxSyAK4/ANqqCHWcgmRoAOJ5A0cv8yAbKQCy4zFeNBf1nIFSNgAgigAluQPEPhU0swBK8nMQlgBAVQH7viLjyBHhNwDbKAAMpwDS8gA7MoBCxgBC8gBFlAGipgBECAfDLAAkLgAkvgAiPwDUuAATQABDRgAiiwA82YAHDSisqAACdwfFWIAcZ3i+tgfIXGAsWnAtykAuSRfE94AibgAdWzIU94ECZAGqCigOKRiRdQAFuwBSTQNyFgApPgAgcAAhVQF0AghNnBASfQCe2WADHTftegDEtgDlkACOZwDEswD1nwDcpAA9dwDCfADUAwAksACOLQBvkABGpIA+KwBFmgDCYgC4BACkCAhSx0DblgAtywjNL/4AGMcAwq0AZZIA+KgAzcwALvkAu5gA40oAzRwALfcApmYA5GcAyKwAGKsAomcAxBcApMoAKMAARZQCqJM4+NyAE48AdYQAIc4C4nMAmTsAI0cwBOYALsIX0qMAlAYDJeMYnnwQ3HwAIqIAGMoAwXYALwYATc0AYF0AbXkAXjkEISkAXikAWMCALfIJJLwJdAYAakoAjiQAoqQIatGAtZYA5AYATX8JAuQDFAIA82+A404JomEJnKcAyA8A4qgAKkeQ2KgACkcAxmMJRtYA5fcA1DUGizFZZFMQIqABQ4UAdXMAknYAEXsAKV4AyTgAMVwAEiwAY4YFMJ4AHUuQUP/3ABGAcIwxEkICAOohB6gKAMFaAC8HCZWUAAigkE6MACE1AAWcANWfAO6PgNX5CS17CeoDICNCANjKACy1kU3CALjOkqr4mfB2Cfxeea90mZK6kMnSAO/wkEh5kAq6AMuSANCqoCJiAK6CCJvXMWXDEQEzACMVAUWPAHlwAHWxAUZakNlVAJOHABJ+AGlbACNlQBOOAIbgAyIHACWQAuE4BxRZELbSA1ESkBJpCGuWCKWRALF9AGubAENJAFx5AF8JAFjCALKiANQOACCLoELLAEQAAILqAMWcAmGHANpHACxyAKzDgCgHAMNEADS/ANxTcONPAN4Cibx+AC5rAERv8ADzRwDNJgmLlAA9xgBDdIAywABKpgBLJgAlVWZUXxEz71ov04AVhQCsBQB3+AAyIwCar6C5VwpC5QCXXgBidQAWtZCrY6mFHgBAUQVm2QNAyDFgTDGKeHfQRDMMTkHksgDhglGmExUcTUPCogC1vhmBJwAirwARbAAMVXAh9gAmFxAhNwAgOoAiWgAuaqApgqDi5gAjGpoBKgAm56AidQr2moASSwAi3QAihAM0IxApfgBijgBKUADaVQB5PAj2DQBXDwC38ABDFQCb/gCNi5BcsADJOAApzoBlvwnSIwBJ2QNIQxH6vSH8iBG6MCG0BQkyc7FK/XaghAekgBMzH/c4ou5hbgwgAOGDb1oRY26QKuF7MKeSHzugX8qgNQoAP9SgI2BJAfcwl1sAUu8AeOkKoLuwV/4AdSAAZ1MAQuMAnN8AdbUJfNUAeOwAJbgAW16lNF6gYX46Oa+AC8830OIhghg2QRcQJHcKtBESuIcYlN2qR+eS7kdzekUoXvUWumFRS+swJQUAd5wAlSi7ZY8K9jZgK0Ogl1KQVdoLAnsAJ/0AVxILk4sAKTUAlm6QKlILWrOgnOwAmTEAJF+pzkKgJUyzEawzAnm4FMqhUfmJ9FwQL5AIY0oAhGCQimOCofiBTcAAg5axAPYrP4Ai7SciG/Oiq64jskUJZ1cAmX/+AIjnAJhXAJuiqkbiK1W2AC3lurK+C9b+C1jtC6eZAHk+AGCXsJOLAFjtAMeeAGQ+AMwEAIQaoCbvAHotgxNIg9H6iuPnUCGFA9s6YCLlC82IcApyAOpEJ67lc9USEN0Hsz0/sAVEO9JAwue0MBPYcBJIAFjiAG4Bu+qvoHcNAK5kuuEnUJ9usCOFAKXvsHBwwHdTDEzlkHfkAIhIC2dgAGl4AFuFC+dYAFbgAMv5AHPJqwdYADFFMADgGaDggEitkGHSkKyuCuLADCsQAPcYgvscANCLAEDpoLKjACpJAFopAFFyANbfACbbDHZmjCN/QA72iiJNACK7CvGbMCjv9wBW9gvlbrCLqgC6EgvljgAiOWB6rqBgdMuX/wC6gKDKiKqpfgtVTcunaAyXBQCHBQCrPqutAgvnkAB0MwmEbgAkdDM07DJuByAozADSaADlZgApUpC8fwg/kQhwEpC9fAAveZAMoQC5QgDQlAvEeADG0QC4rAAsNxUlwBM/1iN70jAiwwBFIMxFDQAhogAs3ZBZDsDOKrC8BgsZ88BMljAn/wBweLsKXgDPgMB/xcCpEMDEJsvs7wypJ7CamQynAQCnFgB3/gDLpwsJfwB07ABn+ACyJQWEJRiVW6BIFqAuZAAxPwvMpAChfgAmqsy6dwDRSKAKJwDQ26ie8ACMj/YAYuwA3xqbJCwxZAsQJOXApw0AWfewm/gAMkUAlxIAXOAA660AWGUAihAAw4gAOX0AilsAKktwy4UApcvQx/AAyhIMmhAAerfAlXcNZgkArhS9bhi8/xHAp1EAe/gAtfXbG4UAmlYL8lkDRetRUAQ7xg/A0nENIjDQiK2ZPvILRhkQvcoALiQAMgsJhZcA0XQAPmEKeAwAJ8Cghj8SDycTQicAKnCgyX4AemfQd+ULqrCgxC7Qz8HAewXQiOYJaOIAilMAQRzNW6MNs0HNRkTdbOCQanfAV2kNqk2wX4zNW4gAvQsAzg+wdDfAmTsNWX8AQLO5gsEDTuR4wnAATs/yquNDDHQMCmQCCuYeECNDCvKkkDYPGluygBMekCWbAEhnGJQmEBFaA3ZQkMqSAJlyAIjdAIph0HfmAHdVAKUgAHuoALCx0KCQ0HfwDP5gsEpFe5vw0HsN3QdmDgdsAHjUAIHZ7aBA4HUqAESmC1+LwMv/AL/80HpTAJjgCxqzrVCcomOLQVDHN6+RmzRbEbwrLjUbEYSAYqyWoh9odtEpCkWBAKhdDkjWDEjdAKrSAJhWDaeXAJUmAIjrAMcQAMu+0ISiAJX10Ky4DVJjDKG77hBO4Hb8AHbi4IiOAHjcAHdiAIflAHDUu6deC5Qn3gV4uqqhwHeVAKlQANuDDbWP/wEzsGvN8XEgmREvf3gXWRn5NefwBjMuLXpOXCiqGKBbrQ5JfACa0Q4JJA5akQCpJw5wL9CHHgCIUADc4QCkoAB14O0ThQAhV+yoTAByL+BnbQ5nP+63wgCHRe54IABlcABl7rucp+BXDQvw/t6q3uDJ8sywIGjkj2AAp4UljBHC8rg9N7L0QKB5cQBwjt363Q34VQ6qlQCImACKngCI1gCF0g264Nz67tDKwKArmeB0hMCLD9BmKw4Xee5nXQCIKw4f7NxJcQz58rBsie4KUw286QCq1O69a9Ai5wCE5AMY/RHiqoJg/ozUUhun5Q7+ELysCw8isvvsDg7g1v3LL/vc8CrQSzrQSnWz2j/AZvgMRVjuxg8AaS2+xA77V1YOBE3ApxQOwC/wRTfarOQOJx0OQ8Ogkv/pcCgTKnV0iloiYNyILAIdqFEAdw0Azi6wy4oA0rDw3A4AxYgAVw0AivztBx0O7i2+RUjvMtgAMtcAKXsOE93wgLfwVi8AYAvsQbjuzJTsR2XvcEjgh84Jw4b+I0/NVVXgrLLd0gIwLimDY3Tn4M+BTkZzdFmtRjLQW6UNDOUAiGIAlkvc9/kAiFoA3NINv9nQorn+rxrqv92gLlbtp+IAk2nAdgIAZ58OsbPux3XgVe2+GCkAiSkApxzQeIkAh+cAVPYOKzrtUT///njkC1ODAJQzABHh+A6NKA//cBIKAEhtDqoRAKDx3PpU7lTV4IqaALiZAIrh0KAJ0Kau3uACEpVSpHjoDhaHEpjh8/fAoBy2NHjBgwdeKAsdOoESI/cC75qeNHkJ+HdUz6SYSoEaE3deBIgQNMVymTpSaV+lOHzQgQFzBgmBBU6NChEiYgmJAgQVClBZQmQIBAwlSiS4lKWCHFkJ9LjgqV0qarkJ9UhXT9UQIzVKJC0NwCuySp0Nw4cOAUahWnEBYcChsKytOqDuA3YMDEWVhII0m5dt44LMTJ5EiGfPi8udJFCsyZwOoYvJTqD5ATK1yYqECUaAXWIJg+TVABg//SClanUh1qlSgOJVz/lNXVLJUk4nCUvLQb6pEkaNqctZobamAoJcdbeZ20QmEhSXWAwYmTUZAdO4cZxukSx6Rj8oVSKQy/0I+dOmCumKxrEK7JS38mbbFpiQ9AuO221VJLwAQVgGhjCRdYOCEE1n6aTYKoqlJtgi3uuiS0RiQJBRi44tIIOkfgMCQUaMApK5VWuirEEJfcCyWOP1RIRa88OgxJo7Eu6qIOSeJAg72K6shjuLHmY0iQ8QwjrxFBPgPml19MwgULR66Y5IMRDijKqKAoRMGFITLJhA4vuFhjEEYGAcQJIVxQYTbdMgyqAgmW+MMuERshKZRWyirkkUb/NDFrLl2cAaYQTSQxZC5JSPLqoUJuvIS/POpIj6S5uqjCMMTIc7KuFwtZCBFVU+JDED4cc1WjRuxwhJpSgPmjFJr+wIGEF15IDcEJTECBhSGc8IIOOrjwotkwmmU2Ci8OMUUYUyIBIjU8Jwh2Ahdu0mW4RubiTqBC2JIktEJCoaYZ7oZLV4q54BDrIThKUeESOELJ474gX0qvIvS6SI8PkOpoRhdHdAlNEo1UVZUQQqTkQ6VGLgOjFGd0kfiSLP0zAQMRFHTBCTkGGcTZZp0NA48zwtADE1RQOWRNObiI5ARtt50AAxYGWWauxTyVSyNO8pgrkVa0CUWSVuAKsZRQ/wx5qUaxJjmhoEwL6cIuguEQteuu1StlmY2dwaYccJyBpplmHJZVI0EmXmzKOjJ1zLs//tjCBRuQXUNNOVZ+1os1wgiDDjwOOQQTTFImwws1xghDjT5OAGHCny4wStsERMChFO66urWZQQd18RK8/GDOXVxxWLgUaIDJ8daFQwECBEcuqaIKP+oimGDE6roXF+PBgQYXcMopBx3mwcHGGUYVVsyyiv0Y91VBKoLjDzcmmcSVQ/Tg4llmVS7cCzlixuQQOtbwggovwjhDcsrVAEQFbinE4AILuA2KAvrCHV3gIh3kEEsXCnEJXYgFUp4BBjWA4Qht4GAFjmBdKELkiP9m4EoXWzABCBRWhSccxi7gkY+N0jaOcVSjUYVwBjpk6DxlMKIa4wCHc+ACEoaMay4FqQT42MAGOsjhfitD4rMWh4lIjE8OdKifHBCnMiRGQgWywcDOOtezFfyhEQtzhjaQJ4lHSAoOu5tLK0IRFkk4AhxuWEEpUoESRzhDg2XDQQkmoDuTXAEj6iEPSfyDjXG4AhelqFQi/oANdNBDGTTwEguqMckwQoMg3cuVTYaoBjatYXJGZIMa1pSsNdFBZjTjAhcGEQlZmKKIdGBD/J5VOPnlDChZzBAGsKA6gyzKGaVoo0fGEpN9pQIYs9OEG3GxAuUxyhHLCIUjcOGCErj/BgR/qMIV/FgeMLzhDTYqxTbUJha9eOoruKCBCUYwggmM4ARAqAY4qrEM44FvEKKM38rkpwY1sKFyaghDmzCBJvfRYRCikEUuchELUYwiF4OI3PzCsIUzyM8LWhjECX6yM6E84AMVEF2IFOYMcJwFBzjQkr6acUZgrG04jsAGOHAAhGnEVIzOmIQKPgBA3VWhPqIqyN5wUY5p/DJGqpqLISL1hyGoYASyOUGxkMAMWQzifPlcWRTSJ7lNHmIUs8DEHFSJCVn0QhaqIEVaSaEKVXRCGIcoXPoQl4aMXiBDrBlWKRIxk0uEQhfgw8EJSgOHVoCFYSTFhS4koYvlbUEE/ypQBTdk4aCdJiUoIOhXHfwIhq6Vwnjl2MbGhmOIRLAlRomIFPiAAAQnjAGK/kQiFZ9FhWdFIQoni4TjDvHEQ6ACF8zoRVs7QYpYkAIQolCFKBA6iinOT2VcOMQJ8MSaC5hAdNSziyNOetIVwM4Zy8BgS93yEHDQgxlXHJZrMgQCTnG2Ik9IyySYVw1dNE0uZSSXXICBCzdtoXzOUtNWCYc4+rHPfYvzLS6CiItZLNS4S2CBCWggi07IoqGuoMMU5eoFQJhgunqawCTWdZZLXGcSfHGDBbGADZrUASxhlCY26CEN9HJLBGAiiu7SQ7BsPkEHLgbHOMTyIUhJIiWsK/+FLbYghz40q35ekJZzsdosOWSCcZhQEyNcwYxpTCMbuKhDJtkAhAjnCQiqYIRyl/usl0n5WYPwsGoekIAHHAV2hWhGTjrUpzOWIrBYcKnTFiXNcsBDQBO4gF3vJBQQ6MsimqlCv54Ah2WUwxmOSIRc2MIqP5RiFs3SQ26xHFvC9ZaJdFDDFsA3CQjRQBmvxsYfoOGGP7ggA3tMdBZycVZAjEIVozCFk2c5Sy8wInNypvMDEGBd92zsD5mqw7qc4YQKqKAa0WuaMsGRjiww4AP+syueQFAJr3UNDvWpgxQWWQ7RzUUlhUCEwRzRCypooVlqkINu49pbmqmJDoeYBC7//vCEUrhABO1UwQlc8AdcgG8FPTEBC4AAYRWYYAnJPUWwuUCGMJSv488yNkeDMucHKFsCdwYLOBxRl5mUAggYAAE8pWcTV3DjkR8YEIW2xd4+gcrcJEy3fEv6oR4a2RCOcEUYKHcGfKpPDjOLhB7UMIhM2OIZldDsM7HgWRaEIGQf6GIp0oYDFtAAQjvFgAmycFa2jkKimWCGmqAFCKAk5U7JRkABwA4H4oSiGRsrhCOw4AKgSMAFFVYFDbJwApzjfI94DZNRQGAWR2xGCppRAg6uAIfQpaMccHHShxCRCKQPW6JUHkb8ANELaazDebi4ghieUGuFL8EIdMLACjyS/zworMAC6wRBxJOL3OS6HXHZiAcmoLymPtRdKUJZSvQtK4Kth6IQJ8SCE0ZwAY+q90FmkEEQjkCDhJvAAxTSouQvobGXwCQOSmiBEurwY2eUAxtNQ9pGGlEHVBCYwEj8ND3IBbQ6hmyQBjATCRdzgQoYgQ9QARoAgr5ohEsAhlJYgQgBChdQLraShVg4BVFYmUEYBUbAhGF4FjlQr6fYFrxSge3CgQcpAc5hChYQAitYBEsgAibYAybQwU0gghdAgRDIItvYo/WDhj+wPM1qgRaogxLyA5ICpnGRFUfAhObaKjmwBS+YhVgorlXIhmmABgxiCTuohNOYAAn4gARYgf/haAZoawESEAEgKK5OULNYkAW3WwNGAARTeIZZmIZmoTuegT4EYAAxqQDOuY1w8wAh2AQrqAEzWIQe5EFkiEQdNIMZQAEMwLF2KghnGLjL8ykdYEIokQTncASVgJs/6AQ3Sx86yEJhGIWGsoVpqIRMaYSFEASPcQGv04Dugo5m2B0+qAMs2IJRUCviQ65RYIZnWEZmkAZU0INnCURBtDtCNIoLSI2pSLQQoIE9MAMz2AMrsIIvsAIeZAIrsIRo6IZuWAUisIJNEAJcCj6hwoX224w6UAJt0qaMKSm4+ZA/qBmWoZ8zGIMxQIUx6IWvOqRLu4IncEgw4ANCqINKWAH/EtC9DmmEVPgFRxCERvAs5FKrWCg+TBCGTOiFQZADOZCW+plGapwABmCA3JiABjCBF0CCI1iEHbiBIOBJHuhJn+RJJjiFdegGboiGcmSnCjABLFCCRSkFzdCMOsgmiXDIh4CGUmiERBgXR4Arj3silzkDOpgFOTArqQmjS3gCtOxIjZDISsCBnBAXSQCGVsgDjekF4iqutCq+3UrJAHsimVmDunPJCTiAByiAOfOZHTiCH+iBHcjJHRCCHZBMHtgBHhCCHugBngwCIziGb1hHKzCC8zMB48iVMIQDgpmPJyAPHXgCP6gjxTKUNoIriWIDPEA1fJsFNVAGXFg/cCgF/10YjLXUCK38oiP0okZoBeFYhml4Bi4UybTqhF+ThUh4FjrohWxAE2achTZgp8EkzDxhgSM4ghvgAR6YAUaUTMgUgvWMzB3AzB5ozx2whHbghmOwBBpIOyRUt1/4JSQsEjv4sYb8IWAgDjLiSthKHDwIJXzrhTXYzXvRBWDQhkuwgzggDvfwD/CRhi+bI2BwBlzYhnmQhlUQSbZiK4TKhUgwJVNAh2xgBrgbhDVoA0RzyTpDtAuwgiOQgRuozPKsQSY4AivwhD3wRjMQRytAgvcUAp5Ehnb4BmTYA6c6kbq4FbYpBfDIA/jKUr14iFAgMq78v7AsHDWwBTlghmWQnf8/CJFLoIw46KtyWIUTKAEagIdpwAVHKAV5ggczYAHiM9HkUoVd4zJTyIZsMIWUNJwZ9QlcwhMbnQAOeAEjmIFJLU/KjEwzsIRVgNJF2INFWIRvTIMc1cwg2AFzWId12IPc+QhyASNocAZHqwNhjLY4MAjueASunB81IQMoOoNetYUzYIZREIbkwQbPOJq7SY9SKIcYmAEmUAR4iJ5JmIZxkIZoeIZc8DVVOIUPpENZkAVlGAWrUp+VSSXZkA2XfIHwnAHyrFQfFYJFsIZdWARPUAQi9cZOXQTQ7MkgEAVT3YU2MIE5ApTrqyPpcY4/AIOLEYQ4iBRcMdBBKCI2OAP/OTgDMuhVPUAFORAGVfBWZkCH5IGGPECEQsCBjACGYfgGdKCBXPgGO8UGbKiGb1CGkEyr4hIFYcAEZgkDjtsqausZwQwKn9ij/QlPHbQC8mTXGzgCIl0FM0CGTTgFTiVScKRaIy3PHjiCcGiHaFiEgMWe3+kaXXBVcECenCCEkWjYSygtriwixFEcKKIDPShTYRCFTjiFUagpbICGSiAOJcgDrqjAD1UeFtsbhnMFUSCFbc1LUhCFXjgEnU2WQUCFYXAfasOiDFEKn0ABadiE8iwCM2ACz8VUStwEIg0HrjWDI1jPI9DBTjUDIugBy7QGotyEE0gFIVlYxFgYbUgb/0uDA4NBjAXSBUMpBYjNsAQdIjYYhDJlBuQ6BVnAhWidnVCQgo/QiNt1U0RKN40oBVeIBMbdBLbqBDrshUhIFlOQBWngMuWjA581V6FIDRZ4kBBihHnYB2QogiDogc9lAqfdhf/dhBuMhmjYAx5NT8i0AiINXR7ogV2wB3M4hhMIhT8Iqj8IPN5Vmxxi029iCAo0lD94opdRljBI3t4aBGZwBS5UhV4oKjaIXmzYHeIYWHByhDqYlTrQBUZYhbUq0bQSBWQAhGkYhmzohWfoBeVLnCyojZ9QjS8wgif+gm+QB/vlhiOQzCPYhF2whlVo2gHehT3gAdC1VMrkgSANR/8G5oFNWIdzUAYTwIaaarj6qqPnwQnysIiFMIjlmIQ+oIPIeVtepRYzlYVTYCs7rIZn2IZChQbwKgTKcIRp2AJV04U4cIZpoIEdYLtRMMa1UgZAeIZn+KpnwINkCUsl/lnVYAEjqMEntoJV+IZ5+AYrgERkiIYn3YRNGOA9KIIiWNp8bU/23AMiQGMrOIdwAAQQOIRqKIdxYJ4PxYZtWJs/8Cb6WAhaTQU9fiKOy9VeHYNBwASNZTtVKNFVsIZs8E1HyAOFrQJHKAcnUIEYwAY4wIZwWIIjsDBt/UBOHoTdooNnQAVQkKibSY2NGorZCAImOIdzaFomCAIriIZ5iIb/U7CGY9iFc1jHaNgEI+XBfN2BSLBi9mTdSmWCdTAHIBiBE8kVZxgHdEiHccAGbcAggzEJg9kX5TCESQAElpkfgpSDSDjUYP01E91Wc8ChEZEVk8CGdciGcIhnaICHaxhAcV4rxCUFx02cMJgFWzjeMJCDLACKcxWKjWKBJVgFJzWD0wVSobyGWkaGbkCGXTCDKxbHHUhdZEAGIbBMIWDdHt2Db+gwE/gDsekCR1BmsqUJy/idwbg+d3kEP5iETAAwIiqcQ8gEM/W1WBRqceCGl71KR7iYmhCncliGvQEHaYgEtjoFvUyrXojGDJMoApMD9+UoJp6AJUDoc7ACZDiH/01o6z0Qgj3YBa5dhLvu36O1zGiwBm4IByu2zNSt1F2gBBCAObS4vDhQt/6sg8cQxi4YjzBj7EKYBLfLVWXxpzBoHI39UxO1w1lwhS3Ihui5hC/VGMWaFaS729ReK3GOBdb2v9fmaiTQFkY9ZZ9hgmgIh1XYhHawhkVYByjdhCCd11XI0R2YAQa2QXWMBiaATHAsgspkgg6zpo+xiz8ABsfwprnZ7in5A0aRC/DOhQw7g9ocYTY4b2E4q2REq21FPGVQATYohbgYCBGBm4oYBIYi5KAmrhQdNv8rIgAHIP6h7REQx89M6C/Yh2/Yg3WghF0oR7yGTAsfYGtQcCZYz/9oWIXL3AErGFoQAAHj1I88eAM7kBiGaIk42L9SIAdgmotJyAW4yjDbxAP6cRw6gEVkRCvGrVmTPoFJkI6+mg7pIMNZYNy7NYVYTKvpnCVYKm88kAMnrzsol40LCAIheGUr6IZ2MAN1UAcrMAdKiAZKFEf4ZAJPiIZzMPB2OAbxNAMJL88vUAH12qOrhIMnQJKWcIRfKPE4HwxAUR5x+YppeFFleSVlGShAOAaRZCg1Y9xROAUQP4EtYJhUkA7aUQwKxAVtPVFRoAQ9lAVGQDVpV5zEWYMl2L4LGAEJwKKNgrnw3ARPMGPxtAK9Fs89iIZ2IPPhtoZwCIdzsIZY3gH/JliEVWBoK3CqRLMrEMAFt/glPJUeaLiEPBiPOBgJOEAeL10OXJiGXoBsEhYlZaEZOVCGDsx25Zp0gGUBXZOFIcCC+nIR9QAD1eleQj4FRfiCJciCNuiFnP4kIvK3SFiCU/5ZKE+7cuRUKziGVdgDZEgDt37oeWjEXTjdaAD7bnj1IwiCRVAEMzACJnCBC3CNcAOBSXDhl722so2MH+mIZUiHV3UYScAFaejD15KDNfhLxrFxD1Sz1P5AF8iCU9iEXPh1ENiCjdmP+E6EUGjebW2DLOg1WZiFMVgZfwvlTLAqF9AoIbxcwTSCPQgHbmCCdjjwdliEcIhXe/jiV38G/244h3mw6N22TEvo1HNkczbnKUS6FQ9F0xJLTgu9PvlCB2eAm0LABWFghlk43nvDA92y8VhULkpgKOdErlxwgi1gg2mQBmhooPdohTbChcMVBUIeBc8/SNAfg8ZxHNIXhpZXFicYgnTNdwoBCBZMvoVjEu3cnnOruH3bZE3RrmjdolG0Fi6aNSs7iCzaY2aXDBAgKlSYUBLEpTqXHF0qBexXM2DOfgkq5OdPOXTjlhUq1MgQrmfZmB3CE8ZLmDB4QGE61CvWKFGxREk9JYqUKFmkVJ2ahgvctm3psOHCVs2ZrVGqZOVSNktWJC9e6GRChWmQFy50MDFDNdeLHky2Zv9lWoShAobEiU8wsWZukaJ1lrp9i7aOiZVd37pNRCbxXLRdQXb0MGNmzyoZLkyASEwShK5SLp3Rpq0N2iU+hUJhiwevHDBJjRoVWvZsFnI6XuTQUYrqEKNcU6XKUhXrlNappCidcrUM17Zp2cZdk7a2Vy5ZoxatkaMnUyZMdOSEOXQIkylM8uXEt4UKjxdUcLEHYoopZsUX6yBzhDnIHBONFVZQckw45nQTDjfnWDNPNIsssgOIVliyyy7WrBLNMUKYYAIGINzmjC6x/eEGNMBcIklL0KADDzrYBCecJM5YY0smvWTCHB1ssDHLINGp8iSUUVlFCpWUZNHGKL3MQlX/W8z0YsohcrBBFyqoZEKHFmcMgold83mxpplyqHGIHnIdBUiBilVwgRE7SMSEGVYIYcUqyISjoTXWfKbQJt/sIcQOPFixiUN7nOIQMjS0CBswocBRRxVSVAJNHYXAoQs26eQjzzjgBDecJLgIYwozuZgyxhnNLTlIJLlACSUp18WiSBtLMPGFIk+ypaUpg8gxBplm0jGGHIeU2ZQcXkSCii3yeaEGHXqAAuBRXPQxwWGuIebCF18Mqggy56hzTjftRPPMOcdsaM0pFFpzDBMhWtPNIlZ4Ys0u2eRyQosp1TEjFH9wUkcdjjgDTjrovMOqq40k0ogj0MySS1vC6DHH/xlI/ZeJr6pk5TKxWVACCCCKSLUKyadEIocca+rXFB103KdfJIfQEUkmo5iSCR7NqeEFG2GcgYkeSamxxhoTmGQguigc8Y2i4XRzzjrfILNINBV2s8omYq+yCDKrRGgGpaucGE2G5phhwgi4gBceLo448scv0ORETzXVwBMPOLo0IonF5UDCDDOy9NLUGCrfZ4oogLSRBehLAMIIl8qoxwjPQl+rh1FCm2IXz1PPIszlcnAh13KjCIPKUYdE0lwYtqNrIAbDq0ARN9Zkc843p0QUTjjIpKHoObvYHc03q0B6REfI7HLKQdEc8YIJ2TxjjVd+m5V4PeUE/sc49PiYiv8u0NTjzSy29CIL7Xfhiooe9GALUVyJZjaTBVtGcaQxBHBohxhEuH7WFD0ILT6RqFMk9JOUuTDDG4vrxbcYwQjlBC8LJslT8bSGATN45hnR28QpoGchbnBGUYqyVGgWMajQrGIXnjnHJmTABBOUwg1QwMY2xpGxd6CjHM4ohRTgAIdq0MOJugBHOdLhjV4wIxOmcEUujBS0YRhtELkQhSpGQTJZhIkKDKwLKn4HrUOYIj96UEPPTDELb53hWWGIRAbDdQY9ZCMe85hHL+YzikMoiQxyyIIEiIeBC2htAic4hTjMwY1VdEMd37jGKULJDQshQxmV+Ug0ChWNTbxtFdb/2MwPesAEGVDsCVgoBS6mQZZJ/CGKXYjiMqoIDnBgg5jDnEYvaEc7WxzCC8yUy17yoxxoZRBMFKzWfezirL3gJxN6wBUdzhA8uYxiFJjAFR7O4I11zMMe5htEJg4RhubQwYQXIIlrKjmBC4CABTRYwil4YYUgBIEHQaDBDgwSDWRUpofWWMTbLJEZaWwmFzuYQQ/SkIpa1uFTUZQCSOPwSzjgQphngYbfJjEJNQxiFkIZhl9soRykNAcP2aTTGHI6CG55C075AeFcgtazWQzjL0nDxBnOYK11rIMb0QDh1A4BrhKa5J6STCEIPEADjewgCEIg6Gi4d4xPPhRtlAqN/0VW8YVN7AIJRJDlRq/wBIq94Q1dkGIc4gCHu+IiHeUopjaWQZs/4KKZ0KLVMExhC9xlE2jU0gMg6RS0ocVTD7mSaVIjIZTFZWNMavjZGYTRrWwgIxfS6EVS9SMXLsjBCQlI4VXRpYIjHGEGIOoBbnNbhF10IxfQm0g0TmG3TSjCCLLIxjasAQlI/OAHG7UDGOJQBzvwQa9wiIMfCqFXZ/gVGrT5Tikm4YrdUS1zdEDFNJgB00GkTA2ftYtlGSgYAD5tOfSchRxSew548DcbuBoDJiBxzjCMgQrPEAYznoGKpEIiEnMyhSxMgYLXGAgxFQCBCbLQgxlw2AY1qAGHef+A20VMhBhTaIInrHAESEFqFdXYBjHCAAVQQIIIDqsDdqnrh7zyeDdZxIZgnaHSMHkhc0MDmheGoRxuAi1cGZQs7nCnhqSe1wuDRAXZ9JGPcDwjEnMIcCRwpQdU9OJy9NRDmTERCUAwhwsqSAwlt4aYE6zYBjaYgQ1wC2IO14AIqxDbFKYQiB6Qpgdv9S2MIXGJVNgCEk24hEix2wg/+EEQdS1VHAqhC78S0y/LmcNMgzpPa9kiG8PoVsq8wCYkH8VOQZuL1ejACuWgmUfmu4Ze8IAJUWSCykZjw9TKBIg9yAISfZhDTgPoAgyMQGsiAQEKTnMEEFE7UrmV5YZ2MYX/MnxiB0AIwg2IwIxteOMTgXBDI4ABjl0oWrt28MOkKW2HOlDaD0FqYjUYsWqjAW+ewANX0Gj9M6PhboOuPopSAt6UYQhDGNYII+WYo+v8nAFXR4asKZDxjFxYoQ8H9qKRXtBsEAzvCFYIlIqnfVvc3gDb4TBxGQJRBtwSoRfjyEYgPkGGG0kiFbgIRCr8UAcw+AER9ZZupfngCHCgAxzV6EPFlXqtgNMTmvM9BK6inuooJyVo/vY676YVCS8JYxjPQEoY2BRH/TgrDX0wRRpW8dYjkGgVTCjULkyxCCMU7wIYUAET9rAHtB1hFSuOFA9mcIOW78Ic4SgD5AMxBSI8/6Ma3AgE5t0gic2nwhhALwSoJj3vTGNXECGrxziqgQ1xSi0MYwqMXeyjdmxJDSk5TarB0d51q0ntvFLb44Ex0bRwWatNz0IapSK0Co9sYg9EiHvzN/GMVUQCCSwagREgJctFmOEImxCUijncAyFY4hvriMa2MW+NcVgD8zq/xOMqgQdiWCMlIM3D0O3Qk9KXoh7VGCY2JIXUpJM4kRAmPIN8eN1eCMM5ZV2/2YkABs0ZTBkZ0MEsSM3OpAED6doEAY+2wF0T7MHJ7cEuEMEN/IAZeIIZFJqksBsV9AEKsIBG4NYPJNQebMIR0M0eBN4R9IAVRIM6rIPklcEUEAMxuP9fIFRCKpQCKrDChUTDJcCBEnzKFYDBvAldxRgOOASWM+heUiQVlamaOOVKL8QeJigFGQigGgqg7gGcF8yCFzQNPJXJIaThPAEYfgiDW7EQEfRhigneJlzb+JHGJvTCJuSCJezApMwAEbCYEAiBGQiBh2yCDkFUNLxDN2wb5H0CJwYCFIQXKBCD2GTDF6QEHGgXGPCBINQBHyBC5LSKLvxBNXDBBhkcGAKYHpABGZzBgkmd1/XOkXwL2iHFMMoFM+lHJkDQXOhBNllDlw1CxlmDGbCNZ+zCDgYKteUWJHKVpDBB84ngHgwiaSSUadjNEaRBNJjDOpiYJuZcGXQLb4X/gzfkwh7wwCXcSCFYISHwASFMGneVgxP9QSmMA30gXKtRGS/mYlJdzu7QCSZkgiy4AjPMgnu5F9cdBX+UCQQFDa6YAsOZwjPAXSRkgzRkQpelATdkA2mRVipZgW0VWg84X24dARPwgMmhBvcsgqGNXw/wQKS8FRHsAjegAzdAQqAJmrk54YVwgzTsYA+kgk10QR0QQh7YwaSVAjmUAzg4wx9MQsZAHT1t0H/x4iEkVWAAkvChwjD0gn/A1BraHjMiGTR5kzN6U5Ecx+VYTjIJQzaU2Sg8wzNUo0ThFmlgBohAyqNACoiI4PeZAROkgRXU5EvOABPwgjSYQRDsAhFu/9snjM1FXIMZKEKKCEErSIIdWKUgXAH+lYJWuopA0oM+nENdCB/C5RQ4PYdZRkIy2QUqQEKZgAIrgIIaCo1+hFpeqKV+zIo1NJyRYAIDCgY3VJ+JRILSdMMzWMjAhMZp9IAOCQFuCUE4PmKkgAgReKMkIoHhzc0M/OAuQIpBbCYxtEM4fIOI8AATcMP4leZwNAIfzBtrbmWM4AI65IM+KMgwNAVmpVquAFBOycEsMIsXmQIr9CYyAFCAyWWurBp+vI4p7ALt6GYm0E422MI3jUI47GBosAwyIIOIbAK9DIw1rGiEEFpkeidpaB+hCUF5vs0ImsENoE004JYNmAExbP9mNwCMFdRjD8gNEbTC42weyDgDQOJCp3BXPcBDPpzD65waarHePOEBKnjdGsjCW5hCJKgHmXKRMBhNUs0FFegBAs5CJLCWZtEOZFkPamzCNPpQcJnDLuwA3eXCKXyD+YjNRFiDhiwURfRBH6wSoRkUD4hYbnHYDZCjRDFBo0YCaYyGJxQp5JmBTZpBD/wAD0RCD5Tm5jlCKaRKE21lKFxCKJQCNDDd61wOgwqgOP0HPbHlLLiCc3pJMuZUkQESMzBgAM1OmWVCJPTBIARmWe1ChEQIL+zCIoBPQzDfLkgfM3wD7YyCLACmMISDokREoiDDHqwYD3jntdkAtQnBEaD/hiUsCIjwQEKcgycEWhkACqjKTQmiaihw146gwzYMU42kQioMDi7Qin/MAjP8jhr+R1LgASsMQ4IlIxfgUXOwSTKZ6YPmx7aMgSn0gZGgR4cgAQvtwjWEBrQ6JrX24KiWhs6MQiT4zNJkQzcoStooSjdESMFIah8iQRpsQuANXqGwFYgcQbysAzyEw71OgSd4ghb8gCekkhmUJqqkwyGNQxOlw8BuJTQ0gy6gBe2UIYKZgu6ZQtWwwSFsgym82lxkwizQgYINUiSAZDLB09LwBeV8icZJHw31yx4cw4OYQzSAaqTGEm4dQa+UIYLOgu9oxsCADUjsgLuyzfcsAiul/1JEUEQPfcgemANoiMM3mMM33GvMYV4ZRI8lAANrHtIhoUPG6AQ4xA8WgUXD9UUdPWhRSI0sKMeYeEm2eAG3DAI00g4CogKE9Yo1nKkw7IwXZUIfLALzWIIliNj36WhpRAMTKN4N+ABuidgOTCPccVEd9cIuZII1sNM6LF/AeNUXMFQ7XAPpHgMrWc+KMkG8dIMlrMIxDOrSFukUaIElpNUuyAQ40AM8zAMTLY4+wMM4aO04lMM4bANzxsdzjEK3WFaC0gEznFeY8EV+oMIzWEskkNGa6A4qzIIpzMpe9sGK9gD17gEyeGZnWIGISeq1JaklUALcnIKtxEfz5sIo2f9whDBBEdwAvabjOqjjN5xDOzzxOThxorANRDFUOMgn9HjSJhWwFFnMAevDPuyDPriuPvgDGFcP8uqRfsgBXyLVrOFB0wxDxS2NgwoDa2GCS6UwM7iHHGAwHT1DMspBJCgnb7UDZ0QDL1zDN9hLuAliuO3gDECqEXzB95zCcsqpwykmoCapY1qBIq9DO6jDPFTIE1+IiSgCJdoNiRwDN7QDN3DDMSjCybVCHmRXHDgCLmgDxphxO8CDPBzSPazDc86OnCqHnKLZ8NGBHM9HHTnTLKikkYwCM9SRLXjJYNCOCufteTmjNXBDEfCAIpyrIgSpIOKW80Xy9xKUFciyIqz/wjOsyZ+O58oBCmWowxOXjTrcQzfAsvfYDTJII89aAjeYgREYAQ8sAhNAZb1RmnQJ5DIYDgLPQz7AwzNMJHLs5jGPQSLNh9wGnBfURdAQhjDI7EgTrzAQBsg9r7I658ZNiA+JTUVYggi+FW5FZoh9WA2URk2KmBBEgjOeAqiO4w60XA8UgQyD8jp00jzQy4mszYraDROMXxCchkEJQeDtQCp8Co7ZwSrmlSDsGBw4AjbUwxjDg/kMw1v0wiko2FwoWeacATNQUNOEwZjhAXyssCn0zCF0kSkAAmA8Qy9YAybIgR4xbMO+UjY4RjZcBIl0BE376LX9ABFYQU9GalEv/wLdmatNs6AiDmo7jO463AOHzHCMmsEpLIIlFMGKPeIOpisTFEQQPJEjgB7FsIRs/MEfUEwdlMIB00M8xIM3JIr5JpPwDcM8hQEqfMM3yNTX2cch5A9vMiwmTANgEi8mmE8XJVMv/KUPPUOWqGRgrqj1LIInrEIR5FakMgFR9wASB0pMFgwTYEYP5jRHYI8mLbI8PAiK3CylDF5kUptOCgEP7EI7rBg44IIuOEJefQochAI41AM2lEIdXIFKlEJXgsfSklYvPMOBskLT6MHuDPKrZcuSYIKqEcZewFRiASaR9EIf0A58EAb/vDNECkU2UIShRMIuPEM3PEpuWcF5R/8qT2/CI3Zy9/lgjd6gZyADN4QD7EZwNqwCL/xLR8hNJFLuItiWGUQP5cLDNjxRjCj4jv0BNlSRM1xXIQjkbWOB4pRNYmNCL+CBZQkDMszCIhHcUdBBMz/HIRyoXTxvt4j0tzYLyFVz7NFBLzC5coONKTcfERj14uXwtJlcafigjUJidkpENPRIKSQ4LpgIRaRyR9gw99zAlmeEyd0DgZZDNSzDbGtXHMgiQGJDLP4BHPyjM+BCOdyDGHPZM4TTGUTCOoRDNrCCf7SOclgLHXCBtQjvfOzUNBeJ81bzrMjHl8LeLKACMggD6R6EKnGfDQviHoQIEYTvRgjKipmBJUT/w4j0Ajc40S9UQivoAjNIBC+kkt3oEA+YhveFAw4ygRD8Qz7cQxmz+jIk+KcQVjrEQ9M90R9c0W8bUhjvA5ZmgzdUSDYwgiwMw6klIDQ9t9HoxyH05SDYh2INgjRP5HE0i+zph66l8FtkAjMsdqKkEovGN847JqTopLnLEiXuL7VagicgwzpggzO4gQ78goPf+CqAj/Wk2A5gNiqtIGnsA6+LcRmnHi48tCPAATTEwz00EVngdjnkQz7MQxhrmdnzQxjPQ3lwke4cFXNQEDN1nZ0zw11Y0DuvgRrIPOXER1M896wYzXFrVjd7z0Kh9iaIt0cM3kWZAUbtQB8sfit5/wLahMMk/MITjAowoAo3iHc0BK4n7ID27IGicFUPWL0Y/4M+tD6P+AM9gIOngMM9EHw8aCUuTAI9THzaq/3EN/A1MIMyKA0qdHDAIbfR0JEFNqfveAk1M4PSIEd+PBBNNQ0cL4JmzSdFcMaKavrbIANxAUpCoXKiUAqJ7EKPCFYpVAIUVOk1HAMyRALbsBIPeAJlnsgOVj2BYn3rt/4/sD5AgHPkTN+9ffvy+aMnDZ7BffogRjwYUd+6b8JMCeuViQ4dPGG8oEIlJxOmQ6NkDbI1SxgzW6hMzYrJkY0Xj2HOnNGjxxSzbOHmHdzX7pu5defCtYuGbBUya6tWPd21Kf9XNHXHoq3aFQ6dM13OoAErBUySJGe2kH07JmrUqSOWdvAQEk2IkB5HEOp7SFHfv3/66GGrlk+e3oP+0AWdyHfxXn3ovllzierQTTl6RvIcJAuZqUy9ZqHKlOmQGo94OnbUg6nXs2zrFE/cty4at3bm2s07F82aOWtZoy1FFhwZ00WrLFoThkuXo7KSHklaNm0pt29NzewQsuPIjhtMrDzMx5divnvwxs27F8+wUMflx5OPuC5cr0iY9HS0OdKLHDmRRpFpEDpMo8OLM8jQ6ZCeflqnr3xiM+yeb6ziRp122jnHmnV6+yYcDaPZRKtsjvHkm3JessWnanQJ5blQdLH/RRlzutkjGkWEkCuIHnjooYe/DJNPHwiF0oc9ISPKR0kk9dInHOWEEU0OA0NDBZNM/OsItTDCoGNBZBoMSq9/lJTnIaHmMSccZE4J4ohFognHnHPOIWrDeZbaZRdruvkmHVz+eEIHKFjZhRlsWiwLRmeweaaPbo4xYzsee/yxSCHnmQci9ziVb0nylDRvH4Poe6aXXjDpjxk8yKBDDjbIwAOP1VTc5p18Oh1SSU1HzecdCpnYYQczjujOiCP2gK2dbnLz8Lc+0cHmDx2o1QEPVLCYBBtEXZQkFWemYeabayyxYocedvQxL8c+bS+2UN0bkq9Q6a13XnjCySY0OlCJ//WMMcZYbRaf2NH0noPjgxBXhPbxpy9urjnmCCJ6IAKZRczoYYc9tilnm3HQgWedkb/5JptyoKmE2haoxQEUMgbFZRpnQknFZhhxkWaXZ6yg2Mce1hVyooURslde+Oo1Wh+HQ4XHG1N72SmSjLIJWR94kkx6HqIfQueaaL7ggQcmFtlkDyJ2YIK3SaCAApdtsdlG7nK2VXllHVpoAQpMoKAWikmqwSWUUIABBhdzstllkZ97DFq+ffySLem/4ss6H79CJbPdvnSNiJtsnnnmG6whGi/hpCE07B88r6HEiIqtWCV2JHroY517hHGj2pjBggaclPvOW3gdcMADlN2hGP/GFsFLKSeabKxhYgYfbwB6vPfmDbUfJcn0yy9Pu7+ce80lSvKey4cUU9ekt7f3+ny4wUpSIazYAxkzgrUCma3lYUb33f3mhrYFEArDIx4k/uc3WzzjbRHLihV+pq7rCckf72ifONpgjnwcIxbe81Q+FHGMzHXve5UrXT5ywQ0gXU1rqEPfPuDBi1ysgmJEsEI3VrGH6e0hHPbQ1Dxs0TcA5k2AeBNg26CAA5bhLQygSOAToECMXRAlF9bYRHcqZb32FA1XQ6KBKvzRD2SYQBzHAMQxzjeeFepqHSpYApmWQANz+EUZlPgL5BTRBiWhwwSASB1ENHW1rSksImQyjDn/hrOHHTHBEovYwxEqtj+hiCyIAhSg8JCIROIVEA84EKLLDrE7UEDiHNngzW+ClcV1CeWP+kDGCVjwDn1cAwXcAIIs5PGOd6jjVt+4FYTEYQ43KikWF4iFkoBwjVAJUwXigAcfO9G+fMAjVJmaBzyoKZF/ICQ40TiCm+y3i0ggwQZWMEdj9hGOYejADS0whhuKlzdPQgEUbVPiPFvwPyhAAg/UAkUguoGUb+ypG5CMIMOwpxd4GEEWGJDFLFVwDBbIIBosWAILFOGCXCzBDNxgQRYUYYIlKOkdKqBBPq5xBHqRQhEqyILIRHoEFsjClqTIQhuwic1pSmQf5lCcGeRC/7ZFWMJHR9jEOkIVEXicgxVCHBQU4Mk2liHRkziwahIFiIMosMINboAEMc7RDWtkAyrRYEIEgcYwiogHGUvwqAsgKg4XjJQFQHjHRaUBCJeq4B3CHCmZSGECbnQ0VHeFxxIEy8c2+IMGNHCBEfQhDhMgg3Lyesg9uoEMXmCRbKtYRI7MuY+gLKxJ3SCGLVgRhuCxU4C4CF7b8tZJvVXCDbjAAiaGsQtSwuOU3LAEsWZQgxpU7yAmTFIWTiGKLIwAGddQgTloAIR9sKAN/wACC7jBDXEYgQX58Cv63sECGugxVKdYAiCyAAIjvMMEirDuC1yqj3ecwI7rSx9T9tAjIv9soghmyE4PVtGOvCQ1IuHYBRLGgApW1BNveutq35KYxKp60rVaDQYkwgEbc1iiONGgRMYOmpfS6TQaWdDHPML7gld+I7r6YIEZ/rGKEZDiG+LIBQqukYsR/NUvZmCuC7LgKxfcCh40AIEyRsAIfQAhujTohzJUwI31KalP0bCC2KywCGTsgUdM6AYr6RWReYQjEiuIgiuGEAZWsOIQQoSqGybhSb0V0A20hec/uyEybpgjK4rQihmIUIOfiTaQeslUT+eIK24gI7PryG4+RGePfXCDFLw45zMisZRrALKnx5jHLpTRU2XoyhqAiAYjrrGPGaKDEatghDT4QptunGL/OzfYw3GsYJdNKMaFuLpHOECBg23hYgtOcAIeIBEIPLg5k1CohLMHBQpiMAsycTKHIzcRDYwxATxAy9Sm9mGPewzJL/ew5qEPhjBcbXNhXdzUFhe2zdWd+IdnYtI8LBIOc/HADJtYxIHvwo2hmS5pBzsHMYYQBTZsARdhaAEOIPEJYixYiJWoBNuwAE8dsIIYxGjHyM6BDG6EQyuOtAaxdjA9Qm/K3Jm63D8OJg+Zy3yQ6fbuPbrHD/MUWi8QkseeC3ur4p5v3BD5yxq/wY1VdIcIt96FFX7Qg0XcLj72nrKSzE0MHLiBDWyIAhIgEXZTzCEJZGBz3+qMi2fjABPT/24HPBCHjF0gIxyKiJ0ZHJlrlf8x3Lk5CCmW0IYloJEwHvyLP3SszH8oYwlGiEUhS2cOySqCpEAYqXmwblzO4bsbwRICE+S+CSYIgQjREE+YT580fRAjCjhYQQxAweYhrIANncRBINYsxKyCAhRJgcc3kLGJU5zCDOGIBt6FYCMrgBghYjrIt/exBBV8Y7ncSJo//OHdXNzKudbJxV58lY8lLEGyxyRmLty3Ob2sAxlMEFtcFnGE7TDhG5LelOqT9pBujCEGmAi7EvNmn6Cgk6IAEowhDHBgUDiOWTLFKfSEKbRtF44A78xgFeyuCJrPXTTlH6QPHhjBBK5hHBhhCf9CKAs0KBeOwQTzQRZAgBQsSB6UQREUIReciwaU4QQAIQfVQoRAxV4mTQiCgAk2QQLrQghOAam4Jkm25uouxx/aQYr0YAuc4dnwZp+ioJ60KgxQARTwgOPOYWTUIemiYReg4hnG0Bp2gViybBHKJn3WjYv0QfquSxbg4R3gQRpOIBby8B2M4BgEy7teAARUgBSuwQSUYRxO4Bo+6htEyrniyAjWyHJCheQ2Zg88K0eYQOAGCVc2p13oZZvsIRrUAAdwoXCc4RcECBKSABSiIArwYAhswLQYEEOSLhx4QSs2QUQ8wX72wPP2oFwQAh62ZiKuKQ5dagREyIz0kPFY4Bj/OEOwhgQejoEG3GgEACEWlkAaXKAN0AEFREEfosvyIvGE4CUczCDL9mB+dg3MTIfnPDGpDsLA2MAZnEENsEAXSgEXUutatOoMdiFO6gQ2gE8RTmEVLGEI544N4STXtqN+HmKQxGw8LsobXoAFJo8bTCAajmEEgiAflOEP+yofvuHFLkAZ4oMFAKH8lgwIxPGDxGcevkEIFGET5MIMvuFSliShkARXsGYVsgEaJgEXnCEVgAELiAEPDiEM5oAVogEpbGMdmmUVTiErtMwaysb4iiMNhUU7mo9ellAfFCELaCMIGMEMjOAUznIejGAV/uEaaEAc5uEagMAMsiAX5kER/4YlFuYhC2jgGDRqH6ygWLJgHJlQYiyRG27nIFYoAwOplU7MhJKqG/oAByZhGQpHZSCBFTKTGMLhSaIBKtchDItjFTahkSpwKnYhsxbBE3AIkpigK+kFckpH5gzi0GTjTI4Oc4jGNhlmN0VLJ+tFp9bKB5ekMXnuK8nxxFbB4XCgEnABB8Kg4wIqHLqBG4KDTvokfm7EszzLkSyhKYKPCeqEzDahuLzS6NLHNl0uSEZlVA4GoTgFocjEPDUnqQxJSZhGSaQp3Wwu/zqHSYTCHDDhnvBg2sJBHdZkFcyBQqDyG7qhG7JNcW5NRNhwD+xnEYIgwNZBTUzvMXeFVxBjHP8ITTHWgQQXDwjkgT/7M2ly6R3kQefq8x9+qWnawIxESPNU9HxmVEmeT/PIQyiQQQsO4RmSQh34xBwQM1K4YUK4wRquwRqY4n7OMRfLhg3dzxragRukwZsgZBO/rS+4K6kgpC6TLgukoeAK7h5kQQWukS/RL1RyQQVyQefyARACqw1OwMTiY4VCJY1Qp0eZBNz2wbS+QT3U4WusMxp4wQw8DSavIX7YUCturd+yIofsYgf2LLuIr0vhxTEu6udQ8FAHURwAwQUs5Brewfq01BxS9ZfOKReg8R/MoCRDpZjeNB+ygBROoA1UAKe25lbkQR3kgaTeQXPqk0cVRvUY44f/zoFMJuQaSlMqLVAdNnQ4gk8hLfHf9GQPNiHXdsAKqHUdcsEtHrKaCu2i4lQZ2qAZTSALuAGxpOEUVAAIsiAL3MoF5JUR/uEUjuEf/FAclKQQg4yYaFVJskAUcHBXoysL3GhdgQAeYiGj2oAbtvG6TJITNzHMyGMY/QEe+uEeooFfG4lbv4E+qtMS9uAL/MtCVyE4dkFlJWUHioBZLCIWuMw9PtToLgoIVEC5IkoFKE8RUOAdVuEEakykcoEG6pUFzGFgYVWD7gEjrSA+iulG/wG52qtX50ofwjSwQmYcrkuyjqGkTKxJXIgxdAXmtucdeIGlsgwZ6OQ2lqJsLDT4/3RRUrdNCCihQY/hbIRgGJtPGOPDCF4gCFggMdJkEP9BaN8hTn/FBDphHeywEPvwL47BaDVFFC4gF+DhIWThAk6hdIBgjFqqVI8gDuFKFmqJBpTLIlXgGubBpdBHqahJWU9PItYhUvotKUamHazBE1DTfvDOkcCjF4sAPKygZNehGzDmLooGNiMCCFSsV5UhGoRJXxmBr+IUqZbABZRBGhKDu+bhL2TBBI6BG2LBBcyAEQ5XH8zBBVhAGcQB8MQBB3v1Bd5oCV5gH/QwC0DworghymL3C7DH5ZT1hHC3NszhHsLwmr4BZc1gD9ZwD34KqJigCMSmCJKFQ7RsEazgNf+JxLjy4QWqCx6GYx32oWQrQsrgZyKiQRbO9B8oIReObh2U4RiOQRlk6RvQT1dW4ab6FR4oIRsiQRpyQRr2QRm+jxsUwRyWTxqyoNTMYR4AYdT4lOCMJlfcQz3EoTbEgf3MxpGO49aWjwjEJous1zqhYhNmQAjorXQk4hpkQT1UlCK8B3Ic4y+aVpb64nuQRDbxWJu2KUn6OD4fooQQmBwJbIvALUkcjV8707Oy7LeW7wj2jUd64Hi/cEGLQ4d64I2PxujM0zwQJlCVCh38mJCFxiXtuNwWxiHQ9j+ZcK3Wai9g0opIcxHCalKtwApmQC62I4uEIDUXNLO0opdPrHz/lFkoIkcnkeToysOUzVZpCsmQOUeahSY+Q27upiKENMSDtcNHzviMv/UoIGUVbnFPkCGZH0dIDhibmcQxrw6bFxmeGYOZ94FNPOEUZtITrOAausETItgKMLhHxpkHkIFDkEEGKYGgc4Sd0RY4qdmePYXn5lma15Ois8cwiJZf2fALfvE46OLzermkkdcMkMJ6pXIR3K9H6tmU31mjYVpjpdlHKZpH9SIXfjH40pEJZIcIrOHkxvkGbqBHhnnMwuEayHAReCAIGmcxblr9ZDqeaVqanRmecVofTmEqymb5LDQwk48MUZZbMca/PvgYgpoprowHiOtSsHqqbzpQra5J/64ZrofkIU+hCDyhD/rACsZa/nLkXHykCOziBn6ZB4blSZ7CLs74g5DmevbCkCU7Xia7si37sm9TorvUOHUjDdKgCZrAs/tAC6ygCdDKBlA7gsSmB5jA+LTtrMQZbTsRHhOqsnlKtBzzS3uwSyni3A6Nrh8HNuvFt6/p3NohDY5jDpBACyKBCZpgDlA7uqVb0H6mnDJLcTK4B2ogoRYZ9djlQ9cTdXy717B4s63JXM9b9TJFGJvEmgQ3qdw7p6ypHXYhDSwUY9JxEyJBuvm7v71sOOJvenhgBrpykIjbXM2THc07Y700Y72SE89WzM4tZ3Py3Ypra2oXXha8Ds0ETxxYdmUpeBeIoL9tQLhsYHp6YHq6IU9osgicOiAAADs=)  
Процесс компиляции, в принципе, состоит из двух основных этапов:

1.  Анализ текста на исходном языке
2.  Генерация машинного кода

На первом этапе строится представление программы, с которым будет удобно работать дальше; обычно это дерево, но вовсе не обязательно. На втором этапе компилятор проходит по дереву, и для каждого узла генерирует окончательный код.

Самая challenging часть компилятора — оптимизация кода; на первом этапе выполняется высокоуровневая оптимизация, на уровне узлов дерева (например, разворачиваются циклы, вживляются inline-функции); на втором — низкоуровневая, на уровне потока команд (например, переупорядочиваются так, чтобы полнее нагрузить конвейеры конкретного процессора). До оптимизаций, по традиции, в вузовских курсах дело никогда не доходит; но самые простые (copy elimination, constant propagation) мы в нашем примере постараемся реализовать.

Старые посты на тему синтаксического разбора я на Хабре видел; но к генерации кода, вроде бы, авторы не приближались ни разу.

### Анализ текста

Когда начинающий программист пытается написать парсер текста, его естественный подход — рекурсивное углубление: найти начало конструкции (например, **{**); найти её конец (например, **}** на том же уровне вложенности); выделить содержимое конструкции, и пропарсить её рекурсивно.

Проблемы с таким подходом — во-первых, избыточная сложность (по одному и тому же фрагменту текста гуляем взад-вперёд); во-вторых, неудобство поддержки (синтаксис языка оказывается рассредоточен по килобайтам и килобайтам ветвистого кода).

Синтаксис языка можно задать декларативно; например, всем знакомы регулярные выражения. Идеально было бы написать стопочку регэкспов для всех конструкций языка, напротив каждого — определение узла, который должен создаться в дереве программы; «универсальный парсер» бы просто подставлял программу в один регэксп за другим, и создавал узлы согласно описанию, один за другим.

Первая из названных проблем решается тем, что поиск всех регэкспов в тексте можно выполнить за один проход, т.е. нет надобности хранить всю программу в памяти целиком — достаточно читать её по одному символу, обрабатывать символ, и тут же забывать.  
Вторая — тем, что теперь у нас есть централизованное, формальное описание языка: можем менять регэкспы, вовсе не трогая код; и наоборот, менять код, не рискуя повредить парсер.

### Практический пример

Упомянутый «универсальный парсер», конечно же, давно реализован, и не одиножды. Классическая реализация — `lex` — принимает описания действий для каждого регэкспа на Си. В стандартные утилиты GNU входит `flex`, совместимый с `lex`, — его мы и будем использовать для примеров. (Есть аналогичные утилиты для C#, Java и пр.)

По традиции, первым примером станет написание калькулятора:

```
%{
    #include <stdio.h>
    int reg = 0;
    char op = '+';
    int unmin = 0;
%}

%option main
%option yylineno

%%

[/][/].*\n      ; // comment
[0-9]           { int opnd = atoi(yytext);
                  if (unmin) opnd =- opnd; unmin=0;
                  switch(op) {
                    case '+': reg += opnd; break;
                    case '-': reg -= opnd; break;
                    case '*': reg *= opnd; break;
                    case '/': reg /= opnd; break;
                  }
                  op = 0;
                }
[-+*/]          { if (op) {
                    if (*yytext=='-')
                      unmin = 1;
                    else {
                      printf("Unexpected operator in line %d\n", yylineno);
                      exit(1);
                    }
                  } else
                    op = *yytext;
                }
[;]             { if (op) {
                    printf("Unexpected semicolon in line %d\n", yylineno);
                    exit(1);
                  }
                  printf("=%d\n", reg);
                  reg = 0;
                  op = '+';
                }
[ \t\r\n]       ; // whitespace
.               { printf("Syntax error in line %d\n", yylineno); exit(1); }
%%

```

Имитируется калькулятор торговок с рынка: без скобок, без приоритета операций, без дробей. Выражения разделяются точкой с запятой, и можно вставлять комментарии от `//` до конца строки.

Скомпилируем наш калькулятор, и попробуем с ним поиграть:  
`[tyomitch@home ~]$ **lex 1.lex**   [tyomitch@home ~]$ **cc lex.yy.c**   [tyomitch@home ~]$ **./a.out**   **2+2;**   =4   **2+2*2;**   =8   **2 + // hello   - 3   ;   **=-1   **2 / /**   Unexpected operator in line 6   `

#### Разбор кода

-   Вверху, в тегах **%{ %}**, идёт код, который скопируется напрямик в парсер. Объявляем три переменные: `reg` («регистр») для промежуточного результата, `op` для набранной операции, и `unmin` — флаг, что был набран минус после знака операции, и он должен трактоваться как знак второго операнда.
-   `%option main` указывает, что нас устроит стандартная `main` (которая читает с `stdin` до `EOF`). `%option yylineno` создаёт в парсере переменную `int yylineno`, где будет храниться номер текущей строки входного текста: он пригодится для диагностических сообщений.
-   **%%** разделяет область объявлений и область собственно правил языка
-   В каждом правиле слева пишется регэксп, справа — код на Си. В первом регэкспе код пуст; т.е. такая конструкция (а это коммментарий) будет просто игнорироваться. Аналогично, предпоследнее правило предписывает игнорировать пробелы и переводы строк между распознаваемыми конструкциями.
-   Во втором правиле пользуемся переменной `yytext`: в ней хранится совпавший с регэкспом текст (в нашем случае, число-операнд)
-   В третьем правиле — пример обработки ошибки в тексте программы (используем `yylineno` в тексте сообщения)
-   Правила пробуются в порядке их появления, от первого к последнему. Если ни одно не подошло, парсер просто напечатает текущий символ в `stdout`. Вместо этого, мы добавляем последним правилом **.** — оно подойдёт к любому символу, и напечатает сообщение об ошибке.

В настоящем компиляторе, разумеется, правила будут не печатать результаты вычислений на экран, а сохранять сами выражения для последующей генерации кода.

##### Как это работает?

У математиков есть понятие ДКА (_детерминированный конечный автомат_) — штука, которая может находиться в одном из _N_ состояний; которая читает из входного потока символ за символом; и у которой есть таблица: для каждого сочетания текущего состояния и прочитанного символа — в которое состояние перейти. Работа `flex` заключается в том, что он строит ДКА по заданному набору регэкспов; в некоторых состояниях этот ДКА не только переходит в следующее, но вдобавок вызвает наши правила.

Увидеть построенный ДКА можно, заглянув внутрь сгенерированного парсера `lex.yy.c`. Потребовалось 15 состояний. Для экономии места, таблица переходов хранится не в явном виде (размером 15х256), а разбитая на мудрёные накладывающиеся списки. Чтобы увидеть её в наиболее наглядной форме, скомпилируем парсер с опцией `-Cef` («отключить сжатие таблиц»):

```
static yyconst short yy_nxt[][8] =
    {
    {    0,    0,    0,    0,    0,    0,    0,    0    },
    {    3,    4,    5,    6,    7,    8,    9,   10    },
    {    3,    4,    5,    6,    7,    8,    9,   10    },
    {   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3    },
    {    3,   -4,   -4,   -4,   -4,   -4,   -4,   -4    },
    {    3,   -5,   -5,   -5,   -5,   -5,   -5,   -5    },
    {    3,   -6,   -6,   -6,   -6,   -6,   -6,   -6    },
    {    3,   -7,   -7,   -7,   -7,   -7,   -7,   -7    },
    {    3,   -8,   -8,   -8,   -8,   11,   -8,   -8    },
    {    3,   -9,   -9,   -9,   -9,   -9,   12,   -9    },
    {    3,  -10,  -10,  -10,  -10,  -10,  -10,  -10    },
    {    3,   13,   13,   14,   13,   13,   13,   13    },
    {    3,  -12,  -12,  -12,  -12,  -12,   12,  -12    },
    {    3,   13,   13,   14,   13,   13,   13,   13    },
    {    3,  -14,  -14,  -14,  -14,  -14,  -14,  -14    },
    } ;

static yyconst short int yy_accept[15] =
    {   0,
        0,    0,    8,    6,    5,    5,    3,    3,    2,    4,
        0,    2,    0,    1
    } ;

```

Символы здесь разбиты на 8 классов, идентичных с точки зрения парсера (например, все цифры объединены в один класс). Отдельный массив `static yyconst int yy_ec[256]` ставит каждому символу в соответствие класс.

Основной цикл работы парсера весьма незамысловат:

```
yy_match:
   while ( (yy_current_state = yy_nxt[yy_current_state][yy_ec[(unsigned char)(*yy_cp)]]) > 0 )
       {
       if ( yy_accept[yy_current_state] )
           {
           yy_last_accepting_state = yy_current_state;
           yy_last_accepting_cpos = yy_cp;
           }

         yy_cp;
       }

   yy_current_state = -yy_current_state;

```

Положительные числа в таблице переходов означают «перейти в состояние и продолжить читать»; отрицательные — «перейти в состояние и выполнить действие». Номер действия, которое должно выполняться по приходу в состояние, хранится в `yy_accept`.

Рассмотрим пример: для цифр номер «класса символа» — 6.  
В начальном состоянии (1) по символу 6 видим в таблице переходов 9. Переходим, читаем дальше.  
В состоянии 9, если есть ещё одна цифра (6), переходим в состояние 12 и читаем дальше.  
Из состояния 12, если есть ещё одна цифра, просто читаем дальше. (В таблице стоит 12)  
Если увидели не-цифру (любой символ, кроме 6), нужно выполнить действие: видим в 9-ой строчке ряд из -9, и в 12-ой строчке ряд из -12.  
Проверяем `yy_accept`: в обоих случаях применяем правило 2. (Вспомним, что правило, распознающее числа, в нашем парсере действительно второе.)  
Непонятно, зачем `flex` решил разделить состояния 9 и 12, если в обоих делает одно и то же самое. Но он бездушная железяка, ему виднее.

Замечательно то, насколько готовый парсер прост: вместо ветвистого распознавания разных конструкций, у нас одна большая таблица, и цикл из десяти строк. Но есть существенная проблема. Вернёмся к примеру из самого начала поста: «найти начало конструкции (например, **{**); найти её конец (например, **}** _на том же уровне вложенности_)...» Как регэкспом обозначить условие «на том же уровне вложенности»?

Математики и тут постарались: доказали, что невозможно. Значит, для парсинга языков, поддерживающих вложенные конструкции (а это все языки сложнее BAT-файлов), нам потребуется более мощный инструмент, чем регэкспы. В следующий раз — [о нём](http://habrahabr.ru/blogs/programming/99298/).
---
created: 2023-03-14T12:00:50 (UTC +03:00)
tags: [компиляция,теория автоматов,формальная грамматика,синтаксический анализ]
source: https://habr.com/ru/post/99298/
author: Artyom Skrobov
---

# Компиляция. 2: грамматики / Хабр

> ## Excerpt
> В предыдущем посте было много кода и, по некоторым мнениям, недостаточно объяснений. Будем чередовать: в этот раз будет много теории, а до практики почти не дойд...

---
Время на прочтение 11 мин

Количество просмотров 37K

В [предыдущем посте](http://habrahabr.ru/blogs/programming/99162/) было много кода и, по некоторым мнениям, недостаточно объяснений. Будем чередовать: в этот раз будет много теории, а до практики почти не дойдёт.

### Далее в посте:

1.  Магазинный автомат
2.  Формальные грамматики
3.  LR-парсинг

### Магазинный автомат

В прошлый раз обозначили проблему с регулярными выражениями и постройкой по ним ДКА для разбора текста: невозможно определить, на одном ли уровне вложенности расположены в тексте скобки. При помощи регэкспов невозможно решить даже намного более узкую задачу: проверить в строке типа **{\*}\***, равно ли количество **{** количеству **}**. Доказательство ведётся от противного: предположим, что можно создать такой регэксп. Значит, можно построить по нему ДКА, который будет отличать подходящие строки от неподходящих. Если в получившемся ДКА есть _N_ состояний, то на строке типа **{<sup><i>N</i>+1</sup>** (т.е. "_N_+1 раз **{**") автомат в каком-то из состояний побывает больше одного раза («зациклится»). Значит, добавив в начало строки новые символы **{**, можно прогнать автомат по тому же циклу лишний раз — и он не заметит подмены. В итоге, автомат не сможет отличить подходящую строку **{<sup><i>N</i>+1</sup>}<sup><i>N</i>+1</sup>** от неподходящей строки **{<sup><i>N</i>+<i>M</i>+1</sup>}<sup><i>N</i>+1</sup>**. (_M_ — длина обнаруженного в автомате цикла; именно столько **{** добавляем в начало строки.)

Иными словами, ДКА не может распознавать вложенные конструкции из-за того, что у него недостаточно памяти: всё, что он помнит, — одно лишь значение от 1 до _N_ (номер текущего состояния). Нам потребуется более ёмкий автомат, память которого сможет неограниченно расти по мере необходимости.

[![](data:image/jpeg;base64,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)](http://commons.wikimedia.org/wiki/File:Caroline-chargeur-plein-p1000499b.jpg) У _автомата с магазинной памятью_, кроме текущего состояния, есть стек, куда он может записывать символы. На каждом шаге автомат читает следующий входной символ, плюс верхний символ из стека. В соответствии с тройкой (текущее состояние, входной символ, символ из стека) автомат выбирает, в какое состояние перейти, и что записать в стек вместо прочитанного символа. Запись в стек необязательна: можно просто стереть оттуда прочитанный символ; так что стек во время работы может и расти, и сокращаться.

По поводу терминологии: магазинный автомат не имеет отношения к торговым автоматам в магазинах. Как ни странно, магазинный автомат назван в честь автоматных магазинов (см.рис.), являющихся классической реализацией стека: доступ возможен только к самому верхнему

~элементу~

патрону.

Теперь сможем решить исходную задачу: проверить, поровну ли в строке **{** и **}**. Читая каждую **{**, записываем её в стек. Читая каждую **}**, стираем из стека одну **{**.

```
состояние 1: считаем {
             символ стека:        {                        EOF (стек пуст)
входной символ:
      {                 записать {{, остаться в 1      записать {, остаться в 1
      }               ничего не писать, перейти в 2     строка не подходит (1)
     EOF                 строка не подходит (2)           строка подходит (3)


состояние 2: считаем }
             символ стека:        {                        EOF (стек пуст)
входной символ:
      {                  строка не подходит (4)         строка не подходит (4)
      }               ничего не писать, остаться в 2    строка не подходит (5)
     EOF                 строка не подходит (6)           строка подходит (7)

```

Примечания:

1.  строка начинается с **}**
2.  в начале строки есть несколько **{**, но после них нет ни одного **}**
3.  строка пуста
4.  после **}** в строке снова есть **{**
5.  **}** больше, чем **{** (стек закончился, а ввод нет)
6.  **}** меньше, чем **{** (ввод закончился, а стек нет)
7.  поровну **{** и **}** (стек и ввод закончились одновременно)

Кроме ёмкого автомата, нам ещё потребуется новый способ задания синтаксиса — более гибкий, чем регэкспы.

### Формальные грамматики

Для определения языковых конструкций, поддерживающих произвольную вложенность, стали использовать «правила вывода», состоящие из символов («терминалов») и переменных («нетерминалов»), например для рассмотренной выше задачи вложенных скобок:

```
VALID: '{' VALID '}' ;
VALID: ;

```

Слева, до двоеточия — переменная; справа — кусок текста, который может из неё получиться, и который может содержать переменные, включая рекурсивные ссылки на определяемую переменную.

Чтобы сэкономить место, альтернативные определения одной и той же переменной можно разделять **|**:

```
VALID: '{' VALID '}' | ;

```

Более содержательный пример — грамматика арифметических выражений:

```
EXPR: NUM | EXPR OP EXPR ;
NUM: DIGIT | NUM DIGIT ;
DIGIT: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
OP: '+' | '-' | '*' | '/' ;

```

Грамматики такого типа называются _контекстно-свободными_, указывая на то, что определения переменных не зависят от контекста: например, NUM всегда соответствует строчке из десятичных цифр, даже если перед числом стояло '0x'. На практике контекстно-зависимые грамматики не используются, потому что для них нет эффективных способов разбора.

Итак, в соответствии с нашей грамматикой, выражение `22+3*4-5` распознавалось бы так:

```
  '2'  '2'  '+' '3'  '*' '4' '-'  '5'
DIGIT DIGIT OP DIGIT OP DIGIT OP DIGIT
 NUM  DIGIT OP  NUM  OP  NUM  OP  NUM
   NUM      OP EXPR  OP  EXPR OP EXPR
    EXPR    OP EXPR  OP      EXPR
           EXPR      OP      EXPR
                    EXPR

```

А может быть, и так:

```
  '2'  '2'  '+' '3'  '*' '4' '-'  '5'
DIGIT DIGIT OP DIGIT OP DIGIT OP DIGIT
 NUM  DIGIT OP  NUM  OP  NUM  OP  NUM
   NUM      OP EXPR  OP EXPR  OP EXPR
    EXPR    OP      EXPR      OP EXPR
           EXPR               OP EXPR
                            EXPR

```

В первом случае, выражение распознаётся как произведение суммы слева и разности справа; во втором — в соответствии с правилами арифметики. Возможны и другие варианты, кроме двух приведённых.

Когда у одного выражения есть несколько «деревьев разбора», возникает вопрос: которое из них парсер должен выбрать?

Аналогичная проблема была и с регулярными выражениям: если применить **(.+)\[ \](.+)** к строчке «quick brown fox», то могло бы получиться либо $1=«quick brown» и $2=«fox», либо $1=«quick» и $2=«brown fox». Про регулярные выражения договорились, что они действуют «жадно», и, читая строку слева направо, забирают в каждое под-выражение как можно больше подходящих символов. (Так что на самом деле получим «quick brown» и «fox»).

С грамматиками такой договорённости нет. Если грамматика допускает неоднозначный разбор, то это плохая, негодная грамматика, и нужно придумать другую. Например, грамматика для калькулятора торговок с рынка, который все действия выполняет слева направо, была бы такой:  
`EXPR: NUM | EXPR OP **NUM** ;   NUM: DIGIT | NUM DIGIT ;   DIGIT: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;   OP: '+' | '-' | '*' | '/' ;   `Теперь в определении EXPR второй операнд — всегда голое число, и поэтому разбор может быть только таким:

```
  '2'  '2'  '+' '3'  '*' '4' '-'  '5'
DIGIT DIGIT OP DIGIT OP DIGIT OP DIGIT
 NUM  DIGIT OP  NUM  OP  NUM  OP  NUM
   NUM      OP  NUM  OP  NUM  OP  NUM
    EXPR    OP  NUM  OP  NUM  OP  NUM
           EXPR      OP  NUM  OP  NUM
                    EXPR      OP  NUM
                            EXPR

```

Если хотим вместо этого, чтоб соблюдался приоритет умножения над сложением, то нужно определить EXPR как _сумму произведений_:  
`EXPR: **TERM** | EXPR '+' **TERM** | EXPR '-' **TERM** ;   TERM: NUM | **TERM** '*' **NUM** | **TERM** '/' **NUM** ;   NUM: DIGIT | NUM DIGIT ;   DIGIT: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;`

`'2' '2' '+' '3' '*' '4' '-' '5'   DIGIT DIGIT '+' DIGIT '*' DIGIT '-' DIGIT   NUM DIGIT '+' NUM '*' NUM '-' NUM   NUM '+' TERM '*' NUM '-' TERM   TERM '+' TERM '-' TERM   EXPR '+' TERM '-' TERM   EXPR '-' TERM   EXPR`

  
В языках программирования похожие неоднозначности встречаются нередко, а в C++ так прямо на каждом шагу: комментаторы упомянули замечательную статью [«Редкая профессия»](http://www.interstron.ru/upload/images/pubs/Redkaya_professiya.pdf) о разработке компилятора C++ от начала до конца.  
Не время углубляться в специфику, но самый простой пример — `if (1) if (2) foo(); else bar();` — может истрактоваться либо как `if (1) { if (2) foo(); else bar(); }`, либо как `if (1) { if (2) foo(); } else bar();`, если составитель грамматики не позаботится запретить одну из трактовок.  
Составление грамматик без неоднозначностей — важный скилл.

### LR-парсинг

Как заставить магазинный автомат распознавать грамматику?  
Он будет читать входную строку символ за символом, и записывать (_сдвигать_) прочитанные символы в стек. Как только наверху стека соберётся последовательность (символов и переменных), подходящая к правилу грамматики, автомат вытолкнет всю её из стека, и заменит на переменную, стоящую в левой части подошедшего правила (_свёртка_). Вся работа автомата заключается в последовательности сдвигов и свёрток.

Интересный момент: автомату на самом деле не важно, какие символы лежат в стеке. Всё равно он не может их сравнить с правилами грамматики, потому что видит только верхний; вместо этого он выбирает, какое правило применить для свёртки, по своему текущему состоянию. Стек ему нужен затем, чтобы знать, в какое состояние перейти после свёртки. Для этого он во время сдвига записывает в стек, вместе с символом, своё текущее состояние; а во время свёртки берёт из стека состояние, записанное под всеми стёртыми символами, и в зависимости от него переходит в следующее состояние.

Придирчивый хабраюзер заметит, что получается не совсем магазинный автомат: на каждом шаге из стека стирается не один элемент, а сразу несколько; и смотрим не на верхний элемент стека, а на тот, что под стёртыми. Вдобавок, во время свёртки автомат оставляет входной символ непрочитанным. Теоретически, такой «расширенный» автомат можно преобразовать к «стандартному» виду, создав кучу дополнительных состояний для очистки стека. На практике, реализация обоих вариантов совершенно аналогична: точно такие же цикл, стек и таблица переходов. Чтобы сэкономить место под таблицу переходов, пользуются «расширенным» автоматом, не раздувая зря его состояния.

Чтобы распознать последнюю нашу грамматику (арифметические выражения с правильным приоритетом операций), потребуется автомат из 11 состояний:

```
состояние 1:
  цифра: сдвиг, перейти в 2
состояние 2:
  удалить 1 символ из стека, записать туда DIGIT
  если состояние на стеке — 1 или 7 или 10, перейти в 3
  если состояние на стеке — 4 или 9, перейти в 5
состояние 3:
  удалить 1 символ из стека, записать туда NUM
  если состояние на стеке — 1 или 10, перейти в 4
  если состояние на стеке — 7, перейти в 9
состояние 4:
  цифра: сдвиг, перейти в 2
  иначе: удалить 1 символ из стека, записать туда TERM
         если состояние на стеке — 1, перейти в 6
         если состояние на стеке — 10, перейти в 11
состояние 5:
  удалить 2 символа из стека, записать туда NUM
  если состояние на стеке — 1, перейти в 4
  если состояние на стеке — 7, перейти в 9
состояние 6:
  '*','/': сдвиг, перейти в 7
  иначе: удалить 1 символ из стека, записать туда EXPR
         если состояние на стеке — 1, перейти в 8
состояние 7:
  цифра: сдвиг, перейти в 2
состояние 8:
  EOF: выражение распознано успешно
  '+','-': сдвиг, перейти в 10
состояние 9:
  цифра: сдвиг, перейти в 2
  иначе: удалить 3 символа из стека, записать туда TERM
         если состояние на стеке — 1, перейти в 6
         если состояние на стеке — 10, перейти в 11
состояние 10: сдвиг EXPR: EXPR '+' TERM  либо сдвиг EXPR: EXPR '+' TERM
  цифра: сдвиг, перейти в 2
состояние 11:
  '*','/': сдвиг, перейти в 7
  иначе: удалить 3 символа из стека, записать туда EXPR
         если состояние на стеке — 1, перейти в 8

```

Не будем останавливаться на том, откуда этот автомат взялся; предположим, его принесло нам НЛО.  
Лучше посмотрим, как он работает: пропустим через него всё то же выражение `22+3*4-5`:

```
состояние 1,  вход "22+3*4-5",  стек пуст
* цифра: сдвиг, перейти в 2
состояние 2,  вход "2+3*4-5",   стек '2',(1)
* удалить 1 символ из стека, записать туда DIGIT, перейти в 3
состояние 3,  вход "2+3*4-5",   стек DIGIT,(1)
* удалить 1 символ из стека, записать туда NUM, перейти в 4
состояние 4,  вход "2+3*4-5",   стек NUM,(1)
* цифра: сдвиг, перейти в 2
состояние 2,  вход "+3*4-5",    стек '2',(4),NUM,(1)
* удалить 1 символ из стека, записать туда DIGIT, перейти в 5
состояние 5,  вход "+3*4-5",    стек DIGIT,(4),NUM,(1)
* удалить 2 символа из стека, записать туда NUM, перейти в 4
состояние 4,  вход "+3*4-5",    стек NUM,(1)
* удалить 1 символ из стека, записать туда TERM, перейти в 6
состояние 6,  вход "+3*4-5",    стек TERM,(1)
* удалить 1 символ из стека, записать туда EXPR, перейти в 8
состояние 8,  вход "+3*4-5",    стек EXPR,(1)
* '+': сдвиг, перейти в 10
состояние 10, вход "3*4-5",     стек '+',(8),EXPR,(1)
* цифра: сдвиг, перейти в 2
состояние 2,  вход "*4-5",      стек '3',(10),'+',(8),EXPR,(1)
* удалить 1 символ из стека, записать туда DIGIT, перейти в 3
состояние 3,  вход "*4-5",      стек DIGIT,(10),'+',(8),EXPR,(1)
* удалить 1 символ из стека, записать туда NUM, перейти в 4
состояние 4,  вход "*4-5",      стек NUM,(10),'+',(8),EXPR,(1)
* удалить 1 символ из стека, записать туда TERM, перейти в 11
состояние 11, вход "*4-5",      стек TERM,(10),'+',(8),EXPR,(1)
* '*': сдвиг, перейти в 7
состояние 7,  вход "4-5",       стек '*',(11),TERM,(10),'+',(8),EXPR,(1)
* цифра: сдвиг, перейти в 2
состояние 2,  вход "-5",        стек '4',(7),'*',(11),TERM,(10),'+',(8),EXPR,(1)
* удалить 1 символ из стека, записать туда DIGIT, перейти в 3
состояние 3,  вход "-5",        стек DIGIT,(7),'*',(11),TERM,(10),'+',(8),EXPR,(1)
* удалить 1 символ из стека, записать туда NUM, перейти в 9
состояние 9,  вход "-5",        стек NUM,(7),'*',(11),TERM,(10),'+',(8),EXPR,(1)
* удалить 3 символа из стека, записать туда TERM, перейти в 11
состояние 11, вход "-5",        стек TERM,(10),'+',(8),EXPR,(1)
* удалить 3 символа из стека, записать туда EXPR, перейти в 8
состояние 8,  вход "-5",        стек EXPR,(1)
* '-': сдвиг, перейти в 10
состояние 10, вход "5",         стек '-',(8),EXPR,(1)
* цифра: сдвиг, перейти в 2
состояние 2,  вход пуст,        стек '5',(10),'-',(8),EXPR,(1)
* удалить 1 символ из стека, записать туда DIGIT, перейти в 3
состояние 3,  вход пуст,        стек DIGIT,(10),'-',(8),EXPR,(1)
* удалить 1 символ из стека, записать туда NUM, перейти в 4
состояние 4,  вход пуст,        стек NUM,(10),'-',(8),EXPR,(1)
* удалить 1 символ из стека, записать туда TERM, перейти в 11
состояние 11, вход пуст,        стек TERM,(10),'-',(8),EXPR,(1)
* удалить 3 символа из стека, записать туда EXPR, перейти в 8
состояние 8,  вход пуст,        стек EXPR,(1)
* EOF: выражение распознано успешно

```

По сути, наш автомат определяет, является ли входная строка правильным арифметическим выражением. Если нет, то в одном из состояний не окажется действия, подходящего очередному входному символу; и тогда автомат сообщит о синтаксической ошибке.  
Можем при помощи того же автомата и _вычислять_ выражения: в каждом символе в стеке будем хранить его математическое значение; при свёртке, вычислим значение нового символа на основании удаляемых из стека.  
Получится продвинутый калькулятор, который учитывает приоритет операций:

```
состояние 1,  вход "22+3*4-5",  стек пуст
* цифра: сдвиг, перейти в 2
состояние 2,  вход "2+3*4-5",   стек '2',(1)
* удалить '2' из стека, записать туда DIGIT=2, перейти в 3
состояние 3,  вход "2+3*4-5",   стек DIGIT=2,(1)
* удалить DIGIT=2 из стека, записать туда NUM=2, перейти в 4
состояние 4,  вход "2+3*4-5",   стек NUM=2,(1)
* цифра: сдвиг, перейти в 2
состояние 2,  вход "+3*4-5",    стек '2',(4),NUM=2,(1)
* удалить '2' символ из стека, записать туда DIGIT=2, перейти в 5
состояние 5,  вход "+3*4-5",    стек DIGIT=2,(4),NUM=2,(1)
* удалить DIGIT=2,NUM=2 из стека, записать туда NUM=22, перейти в 4
состояние 4,  вход "+3*4-5",    стек NUM=22,(1)
* удалить NUM=22 из стека, записать туда TERM=22, перейти в 6
состояние 6,  вход "+3*4-5",    стек TERM,(1)
* удалить TERM=22 из стека, записать туда EXPR=22, перейти в 8
состояние 8,  вход "+3*4-5",    стек EXPR=22,(1)
* '+': сдвиг, перейти в 10
состояние 10, вход "3*4-5",     стек '+',(8),EXPR=22,(1)
* цифра: сдвиг, перейти в 2
состояние 2,  вход "*4-5",      стек '3',(10),'+',(8),EXPR=22,(1)
* удалить '3' из стека, записать туда DIGIT=3, перейти в 3
состояние 3,  вход "*4-5",      стек DIGIT=3,(10),'+',(8),EXPR=22,(1)
* удалить DIGIT=3 из стека, записать туда NUM=3, перейти в 4
состояние 4,  вход "*4-5",      стек NUM=3,(10),'+',(8),EXPR=22,(1)
* удалить NUM=3 символ из стека, записать туда TERM=3, перейти в 11
состояние 11, вход "*4-5",      стек TERM=3,(10),'+',(8),EXPR=22,(1)
* '*': сдвиг, перейти в 7
состояние 7,  вход "4-5",       стек '*',(11),TERM=3,(10),'+',(8),EXPR=22,(1)
* цифра: сдвиг, перейти в 2
состояние 2,  вход "-5",        стек '4',(7),'*',(11),TERM=3,(10),'+',(8),EXPR=22,(1)
* удалить '4' из стека, записать туда DIGIT=4, перейти в 3
состояние 3,  вход "-5",        стек DIGIT=4,(7),'*',(11),TERM=3,(10),'+',(8),EXPR=22,(1)
* удалить DIGIT=4 символ из стека, записать туда NUM=4, перейти в 9
состояние 9,  вход "-5",        стек NUM=4,(7),'*',(11),TERM=3,(10),'+',(8),EXPR=22,(1)
* удалить NUM=4,'*',TERM=3 из стека, записать туда TERM=12, перейти в 11
состояние 11, вход "-5",        стек TERM=12,(10),'+',(8),EXPR=22,(1)
* удалить TERM=12,'+',EXPR=22 из стека, записать туда EXPR=34, перейти в 8
состояние 8,  вход "-5",        стек EXPR=34,(1)
* '-': сдвиг, перейти в 10
состояние 10, вход "5",         стек '-',(8),EXPR=34,(1)
* цифра: сдвиг, перейти в 2
состояние 2,  вход пуст,        стек '5',(10),'-',(8),EXPR=34,(1)
* удалить '5' из стека, записать туда DIGIT=5, перейти в 3
состояние 3,  вход пуст,        стек DIGIT=5,(10),'-',(8),EXPR=34,(1)
* удалить DIGIT=5 из стека, записать туда NUM=5, перейти в 4
состояние 4,  вход пуст,        стек NUM=5,(10),'-',(8),EXPR=34,(1)
* удалить NUM=5 из стека, записать туда TERM=5, перейти в 11
состояние 11, вход пуст,        стек TERM=5,(10),'-',(8),EXPR=34,(1)
* удалить TERM=5,'-',EXPR=34 из стека, записать туда EXPR=29, перейти в 8
состояние 8,  вход пуст,        стек EXPR=29,(1)
* EOF: выражение распознано успешно, значение =29

```

Парсер в реальном компиляторе устроен похоже, только там в каждой свёртке не вычисляется выражение, а генерируется соответствующий код.

Описанный способ парсинга называется _восходящим_: начинаем с распознавания мельчайших конструкций, и, соединяя их воедино, получаем всё большие. Есть и противоположный, _нисходящий_ подход: начинаем с конструкции «весь текст», и дробим её, распознавая всё более мелкие подконструкции. Между сторонниками двух подходов, как выяснилось, ведутся вялые холиворы: каждая сторона считает, что именно её подход естественнее, ближе к распознаванию синтаксиса человеком, и поэтому проще в отладке.

В следующий раз [познакомимся с бизоном](http://habrahabr.ru/blogs/programming/99366/), который по грамматике сам строит распознающий LR-автомат, и тогда сможем скомпилировать наш расчудесный калькулятор.
---
created: 2023-03-14T12:13:18 (UTC +03:00)
tags: [компиляция,синтаксический анализ,yacc,bison]
source: https://habr.com/ru/post/99366/
author: Artyom Skrobov
---

# Компиляция. 3: бизон / Хабр

> ## Excerpt
> Это единственный пост в серии, в центре внимания которого &mdash; старообрядный сишный бизон, так надоевший некоторым. Тем, кто пишет не на Си, пост всё равно должен б...

---
Время на прочтение 13 мин

Количество просмотров 42K

Это единственный пост в серии, в центре внимания которого — старообрядный сишный бизон, так надоевший некоторым. Тем, кто пишет не на Си, пост всё равно должен быть интересен, потому что похожие по принципу работы генераторы LR-парсеров существуют для очень многих языков. Тех же, кто идеологически не приемлет LR-парсеры, мне сегодня привлечь нечем.

### Далее в посте:

1.  Компиляция грамматики
2.  Двухступенчатый парсер
3.  Что у него внутри?
4.  Конфликты в грамматике
5.  Как это работает?

  
Чем мы занимались до сих пор?  
В прошлый раз [составили грамматику](http://habrahabr.ru/blogs/programming/99298/) для арифметических выражений:

```
EXPR: TERM | EXPR '+' TERM | EXPR '-' TERM ;
TERM: NUM | TERM '*' NUM | TERM '/' NUM ;
NUM: DIGIT | NUM DIGIT ;
DIGIT: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

```

Закончили тем, что пристально рассмотрели автомат, который её парсит.  
Придумывать парсящие автоматы сами мы не умеем, да и не надо — ведь бизон умеет строить их за нас!  
С бизоньей помощью сможем скомпилировать наш парсер, и поглядеть, как всё это работает взаправду.

### Компиляция грамматики

Общий принцип такой же, как с `flex` в [первой части](http://habrahabr.ru/blogs/programming/99162/): мы перечисляем правила грамматики, и напротив каждого правила пишем сишный код, который будет выполняться во время свёртки правила.

В прошлый раз упомянули, что во время свёртки мы вынимаем из стека набор символов (строк или переменных), смотрим на их значения, задаём значение для свернувшейся переменной, и кладём её в стек вместо вынутых.

`%{       #include <stdio.h>       int yylex() { return getc(stdin); }       void yyerror(char *s) {         fprintf (stderr, "%s\n", s);       }   %}%%EVALUATE: EXPR '\n' { printf("%d\n", $$) } ;EXPR:    TERM           | EXPR '+' TERM { $$ = $1 + $3; }           | EXPR '-' TERM { $$ = $1 - $3; }   ;TERM:    NUM           | TERM '*' NUM  { $$ = $1 * $3; }           | TERM '/' NUM  { $$ = $1 / $3; }   ;NUM:      DIGIT           | NUM DIGIT    { $$ = $1*10+$2; }   ;DIGIT:    '0' { $$=0; } | '1' { $$=1; } | '2' { $$=2; } | '3' { $$=3; }           | '4' { $$=4; } | '5' { $$=5; } | '6' { $$=6; } | '7' { $$=7; }           | '8' { $$=8; } | '9' { $$=9; }   ;%%   `

#### Разбор кода

[![](data:image/jpeg;base64,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)](http://commons.wikimedia.org/wiki/File:Woman_with_yak_at_Qinghai_Lake.jpg)  
Так же, как в `lex`\-файлах, код в тегах **%{ %}** копируется в парсер неизменным. Есть две функции, которые необходимо определить: `int yylex()` возвращает следующий входной символ, и `void yyerror(char *s)` печатает сообщение об ошибке. Классический `yacc` включал готовую реализацию `yyerror`, которую можно было в случае необходимости переобъявить; но его GNU-клон `bison` требует от программиста явную реализацию.

**%%**, как и в `lex`\-файлах, разделяет область объявлений и область правил грамматики. Правила перечисляются в том же виде, как мы уже привыкли; в конце правила добавляем код свёртки. В коде свёртки, чтобы сослаться на значения символов на стеке парсера, используем **$**\-теги. `$$` ссылается на сворачиваемую переменную (левую часть правила), `$1` на самый левый символ в правой части правила (самый глубокий в стеке парсера), `$2` на второй слева, и т.д. Если в правой части правила _N_ символов, то можно пользоваться значениями от `$1` до `$N`.  
Если код свёртки не задан, и в правой части правила один символ, то по умолчанию бизон «наследует» его значение: `$$=$1`

Самая первая объявленная переменная считается «корнем» грамматики, т.е. весь входной текст должен в итоге свернуться в этот корень. `EXPR` подходил бы в качестве корня, но тогда печать вычисленного выражения пришлось бы засунуть в свёртку `EXPR`; а значит, печаталось бы ещё и значение каждого подвыражения по дороге. Для удобства печати заведём новую переменную `EVALUATE`, которая используется только в качестве корня. Это заодно даёт возможность прочитать в конце выражения перевод строки — кроме удобства печати, получаем удобство ввода.

При компиляции парсера нужно указать библиотеку `liby`, в которой лежит стандартная бизонья `main()`.  
`[tyomitch@home ~]$ **bison 2.y**   [tyomitch@home ~]$ **cc -ly 2.tab.c**   [tyomitch@home ~]$ **./a.out**   **22+3*4-5**   =29   [tyomitch@home ~]$ **./a.out**   **2 + 2**   syntax error   `  
В отличие от калькулятора торговок с рынка, который умел игнорировать пробелы и комментарии, бизоний калькулятор понимает строго заданный синтаксис: цифры, знаки операций, перевод строки в конце. Чтобы предусмотреть, например, пробелы между любой парой символов, пришлось бы добавлять их в грамматику явно:  
`EXPR: TERM | EXPR **WS** '+' **WS** TERM | EXPR **WS** '-' **WS** TERM ;   TERM: NUM | TERM **WS** '*' **WS** NUM | TERM **WS** '/' **WS** NUM ;   NUM: DIGIT | NUM DIGIT ;   DIGIT: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;   **WS: | WS ' ' ;**   `  
Ясно, что это неудобно. Да и писать для распознавания цифр 10 разных правил неудобно; а если бы нам нужны были латинские буквы, например в именах переменных, мы бы задавали 52 правила?!

До чего здорово было бы совместить преимущества `flex` и `bison`! Чтобы простые выражения (числа, пробелы) распознавать было _просто_, и чтобы сложные выражения распознавать было _возможно_.

### Двухступенчатый парсер

Если у нас уже есть `flex`\-парсер, который успешно распознаёт числа и удаляет комментарии и пробелы, то прогоним входной текст через него; а то, что получится, прогоним через продвинутый бизоний парсер. На самом деле, нет надобности хранить промежуточный результат: обе ступени можно выполнить за один проход. `flex` читает входной текст символ за символом, время от времени передавая «наверх» бизону _токены_ — терминальные символы грамматики. Значения для токенов `flex` задаёт сам.

Чтобы такой симбиоз был возможен, `flex` должен как-то узнать терминальные символы бизоньей грамматики. Будем запускать `bison` с ключом `-d`, тогда он сгенерирует `.h`\-файл с перечислением всех терминалов. Для этого нужно объявить (указанием `%token`) терминалы в файле грамматики — и останется лишь сослаться на сгенерированный `.h`\-файл в файле `.lex`.  
`%{       #include <stdio.h>       void yyerror(char *s) {         fprintf (stderr, "%s\n", s);       }   %}`

`**%token NUM**`

`%%EVALUATE: EXPR          { printf("=%d\n", $$); } ;EXPR:    TERM           | EXPR '+' TERM { $$ = $1 + $3; }           | EXPR '-' TERM { $$ = $1 - $3; }   ;TERM:    NUM           | TERM '*' NUM  { $$ = $1 * $3; }           | TERM '/' NUM  { $$ = $1 / $3; }   ;%%   `  
Функция `yylex` нам больше не нужна: теперь входные символы будут поступать не из `stdin`, а от `flex`.  
Кроме того, стёрли `'\n'` после `EXPR` (его проглотит `flex`), и убрали все правила про `NUM` и `DIGIT`.

Соответствующий файл `.lex`:  
`%{       #include "3.tab.h"   %}`

`%option yylineno   %option noyywrap`

`%%[/][/].*\n      ; // comment   [0-9]+          { yylval = atoi(yytext);                     return NUM;                   }   [ \t\r\n]      ; // whitespace   .              { return *yytext; }%%   `  
Файл с определениями токенов получает суффикс `.tab.h`  
Единственное, что в нём есть — `#define NUM 258`  
Все токены получают номера выше 256, чтобы отличаться от «обычных» символов.

Чтобы передать токен бизону, его значение записываем в глобальную (ох ужас!) переменную `yylval`, и возвращаем код токена.  
Обычные символы передаём обычным способом (возвращаем код символа).

Опция `noyywrap` указывает, что входной текст один, и после чтения `EOF` не нужно пытаться перейти к следующему тексту. Эта опция устанавливалась автоматически, пока мы пользовались `%option main`, задававшей чтение с `stdin`. Сейчас `main()` будет бизонья, поэтому нам не нужно ни просить у `flex` стандартную `main()`, ни писать свою.

Компилируем двухступенчатый парсер:  
`[tyomitch@home ~]$ **lex 3.lex**   [tyomitch@home ~]$ **bison -d 3.y**   [tyomitch@home ~]$ **cc -ly lex.yy.c 3.tab.c**   [tyomitch@home ~]$ **./a.out**   **22+ // hello   3*4 - 5   **=29   [tyomitch@home ~]$ **./a.out**   **22+x**   syntax error   `  
По поводу терминологии: в такой двухступенчатой модели нижний парсер, распознающий токены, по традиции называют _лексическим анализатором_ («лексером»), а верхний, распознающий конструкции из токенов — _синтаксическим анализатором_. Это указание именно роли парсера, а не его устройства: другие системы разбора могут, например, использовать для обеих ступеней магазинно-автоматные парсеры.

### Что у него внутри?

Чтобы увидеть сгенерированный автомат, не нужно нырять в пучины сишного кода: у бизона могучие средства для отладки грамматик. Указываем ключ `-v`, и глядим в файл с суффиксом `.output`.  
После переноса парсинга чисел в лексер, в автомате осталось 14 состояний, и описаны они примерно так:

```
...

state 7

    4 EXPR: EXPR '-' . TERM

    NUM  shift, and go to state 1

    TERM  go to state 11


state 8

    6 TERM: TERM '*' . NUM

    NUM  shift, and go to state 12


state 9

    7 TERM: TERM '/' . NUM

    NUM  shift, and go to state 13


state 10

    3 EXPR: EXPR '+' TERM .
    6 TERM: TERM . '*' NUM
    7     | TERM . '/' NUM

    '*'  shift, and go to state 8
    '/'  shift, and go to state 9

    $default  reduce using rule 3 (EXPR)

...

```

Для каждого состояния указаны правила, которые в этом состоянии распознаются (вместе с их номерами в грамматике), и перечислены действия, выполняемые для каждого входного символа. Не указано следующее состояние после свёртки; вместо этого автомат возвращается в состояние, прочитанное из стека, и в нём ищет правило «go to», соответствующее свежесвёрнутому нетерминалу. Таким образом, таблица переходов автомата получается двумерной: в каждом состоянии _действие_ зависит только от входного символа, и не зависит от содержимого стека. (Но из стека берётся следующее состояние после свёртки.)

Чтобы не ползать с карандашом по распечатке автомата, подставляя в него символ за символом, можно попросить бизона во время парсинга печатать все переходы из состояния в состояние. Для этого компилируем грамматику с ключом `-t`, и в парсере появится глобальный флаг `yydebug`. Его нужно установить в 1 — например, в `main()`.  
Если мы, кроме того, хотим, чтобы печатались значения символов, то нужно определить макрос `YYPRINT`:  
`%{       #include <stdio.h>       void yyerror(char *s) {         fprintf (stderr, "%s\n", s);       }       **#define YYPRINT(file, type, value) fprintf(file, "%d", value);**   %}%token NUM%%EVALUATE: EXPR          { printf("=%d\n", $$); } ;EXPR:    TERM           | EXPR '+' TERM { $$ = $1 + $3; }           | EXPR '-' TERM { $$ = $1 - $3; }   ;TERM:    NUM           | TERM '*' NUM  { $$ = $1 * $3; }           | TERM '/' NUM  { $$ = $1 / $3; }   ;%%   **int main () { yydebug=1; return yyparse(); }**   `  
Код после второго тега **%%** копируется в парсер неизменным так же, как если бы он был в **%{ %}**.  
Теперь, раз мы определили `main()` сами, уже не нужно при компиляции подключать `liby`:  
`[tyomitch@home ~]$ **lex 3.lex**   [tyomitch@home ~]$ **bison -dt 3.y**   [tyomitch@home ~]$ **cc lex.yy.c 3.tab.c**   [tyomitch@home ~]$ **./a.out**   Starting parse   Entering state 0   Reading a token: **22+3*4-5**   Next token is token NUM (22)   Shifting token NUM, Entering state 1   Reducing stack by rule 5 (line 20), NUM -> TERM   Stack now 0   Entering state 4   Reading a token: Next token is token '+' (22)   Reducing stack by rule 2 (line 15), TERM -> EXPR   Stack now 0   Entering state 3   Next token is token '+' (22)   Shifting token '+', Entering state 6   Reading a token: Next token is token NUM (3)   Shifting token NUM, Entering state 1   Reducing stack by rule 5 (line 20), NUM -> TERM   Stack now 0 3 6   Entering state 10   Reading a token: Next token is token '*' (3)   Shifting token '*', Entering state 8   Reading a token: Next token is token NUM (4)   Shifting token NUM, Entering state 12   Reducing stack by rule 6 (line 21), TERM '*' NUM -> TERM   Stack now 0 3 6   Entering state 10   Reading a token: Next token is token '-' (4)   Reducing stack by rule 3 (line 16), EXPR '+' TERM -> EXPR   Stack now 0   Entering state 3   Next token is token '-' (4)   Shifting token '-', Entering state 7   Reading a token: Next token is token NUM (5)   Shifting token NUM, Entering state 1   Reducing stack by rule 5 (line 20), NUM -> TERM   Stack now 0 3 7   Entering state 11   Reading a token: Now at end of input.   Reducing stack by rule 4 (line 17), EXPR '-' TERM -> EXPR   Stack now 0   Entering state 3   Now at end of input.   Reducing stack by rule 1 (line 13), EXPR -> EVALUATE   =29   Stack now 0   Entering state 2   Now at end of input.   `  
Из стека печатаются только состояния; типы символов в стеке, и их значения, остаётся угадывать из контекста.  
Если макрос `YYPRINT` не задан, тогда угадывать придётся и значения прочитанных токенов: бизон будет печатать только пустые скобки.

### Конфликты в грамматике

В прошлый раз упомянули неоднозначные грамматики, допускающие для одного выражения несколько вариантов разбора.  
Что скажет бизон, если попытаемся скомпилировать неоднозначную грамматику?  
`%{       #include <stdio.h>       void yyerror(char *s) {         fprintf (stderr, "%s\n", s);       }   %}%token NUM%%EVALUATE: EXPR          { printf("=%d\n", $$) } ;EXPR:    NUM           | EXPR '+' EXPR { $$ = $1 + $3; }           | EXPR '-' EXPR { $$ = $1 - $3; }           | EXPR '*' EXPR { $$ = $1 * $3; }           | EXPR '/' EXPR { $$ = $1 / $3; }   ;%%`

`[tyomitch@home ~]$ **bison 4.y**   4.y: conflicts: 16 shift/reduce`

  
Когда из одного состояния грамматика допускает несколько продолжений, бизону непонятно, что именно выполнять. В нашем случае он колеблется между сдвигом и свёрткой. Можно исправить грамматику, как мы в прошлый раз сделали; а можно «подтолкнуть» бизона в нужную сторону, и намекнуть, что делать в случае конфликта. Стоит относиться к этому как к быстрому хаку: парсер начинает работать, но отлаживать «грамматику с намёками» становится сложнее.

Поскольку типичный источник конфликтов — арифметические выражения, то и намёки даются в виде указания приоритета операторов (выполнять умножение раньше сложения) и их ассоциативности (из операторов с равным приоритетом, который выполнять раньше). Чем ниже оператор в списке, тем выше приоритет. Операторы в одной строчке списка получают одинаковый приоритет.

`%{       #include <stdio.h>       void yyerror(char *s) {         fprintf (stderr, "%s\n", s);       }   %}%token NUM`

`**%left '+' '-'   %left '*' '/'   **`

`%%EVALUATE: EXPR          { printf("=%d\n", $$) } ;EXPR:    NUM           | EXPR '+' EXPR { $$ = $1 + $3; }           | EXPR '-' EXPR { $$ = $1 - $3; }           | EXPR '*' EXPR { $$ = $1 * $3; }           | EXPR '/' EXPR { $$ = $1 / $3; }   ;%%   `  
Для правоассоциативных операторов есть директива `%right`.  
Противоестественность хака с приоритетами можно оценить на примере двусмысленности `if (1) if (2) foo(); else bar();`  
Чтобы она распарсилась привычным образом — `if (1) { if (2) foo(); else bar(); }` — нужно, чтобы приоритет `else` был выше, чем у `')'`  
Оба этих терминала тяжело назвать операторами, и тем более тяжело задать им «естественный» приоритет.  
Зато это работает!

«Грамматика с намёками» компактнее однозначной и в исходном виде (короче вдвое), и в виде автомата (сэкономили одно состояние).

Даже в однозначной грамматике могут возникать конфликты, связанные с принципом работы магазинного автомата: во время выполнения каждого действия он видит только один следующий символ ввода. Например, грамматика

```
WORD: S1 'a' 'i' 'l' | S2 'a' 'l' 'e' ;
S1: 's' ;
S2: 's' ;

```

— однозначная, и ей соответствует всего два слова — sail и sale. Когда парсер сдвинул первую букву 's' и видит после неё 'a', он не может сделать выбор, сворачивать `S1` или `S2`: правильная свёртка зависит от того, какая буква будет после 'a'; но её автомат ещё не видит.  
Это вторая причина, по которой парсер делают двухступенчатым: за счёт того, что лексер сжимает строки в токены и отбрасывает ненужные символы между токенами, LR-парсеру удаётся «дальше» заглядывать: не на одну букву, а на один токен вперёд.

### Как это работает?

Как и у `flex`, ядро парсера — таблица переходов и небольшой цикл. Используется два параллельных стека: стек состояний `yyssa` и стек значений `yyvsa` — всё равно состояния и символы входят и выходят из стека всегда парами.

Как и в прошлый раз, символы, идентичные с точки зрения парсера, объединены в классы. В данном случае, классов 7, и они перечислены в файле `.output`. Массив `static const unsigned char yytranslate[259]` сопоставляет всем терминалам класс. (От 0 до 255 — обычные символы; 258 — объявленный нами терминал `NUM`).

Таблицы переходов хитроумно объединены. В основной таблице хранятся описания действий: для сдвига (положительное число) — в какое состояние перейти; для свёртки (отрицательное) — по какому правилу свернуть.

```
static const unsigned char yytable[] =
{
       6,     7,     5,     8,     9,    10,    11,     1,    12,    13
};

```

Удивительно, что таблица не только одномерная, но даже элементов в ней меньше, чем наших состояний (их 14).  
Трюк в том, что индекс первого действия для каждого состояния хранится в отдельной таблице:

```
#define YYPACT_NINF -5
static const yysigned_char yypact[] =
{
       4,    -5,     2,    -4,    -3,    -5,     4,     4,     5,     6,
      -3,    -3,    -5,    -5
};

```

`YYPACT_NINF` означает, что состоянию не соответствует ни один элемент `yytable`; иначе говоря, выполняемое действие не зависит от входного символа.  
Действия по умолчанию для каждого состояния хранятся в другой отдельной таблице:

```
static const unsigned char yydefact[] =
{
       0,     6,     0,     2,     3,     1,     0,     0,     0,     0,
       4,     5,     7,     8
};

```

Не зависеть от входного символа может только выполнение свёртки, поэтому значения в `yydefact` — номера правил грамматики, по которым нужно сворачивать.

По индексу из `yypact[n]` хранится действие для состояния _n_ и для класса символов 0. Действие для класса символов _k_ хранится в `yytable[yypact[n]+k]`; поэтому в `yypact` могут быть отрицательные индексы — это лишь «база», к которой будет прибавляться номер класса.

Чтобы проверить, к которому символу относится каждое действие в `yytable`, есть ещё одна таблица:

```
static const unsigned char yycheck[] =
{
       4,     5,     0,     6,     7,     6,     7,     3,     3,     3
};

```

Что мы видим? `yytable[0]` относится к символам класса 4, `yytable[1]` к символам класса 5, и так далее.  
Попробуем найти какое-нибудь действие, например приведённые выше:

```
...

state 7

    4 EXPR: EXPR '-' . TERM

    NUM  shift, and go to state 1

    TERM  go to state 11


state 8

    6 TERM: TERM '*' . NUM

    NUM  shift, and go to state 12

...

```

Класс терминала NUM — 3.  
Ищем первый сдвиг: `yytable[yypact[7]+3]==yytable[4+3]==1` (и действительно, `yycheck[yypact[7]+3]==3`)  
Второй сдвиг: `yytable[yypact[8]+3]==yytable[5+3]==12` (и действительно, `yycheck[yypact[7]+3]==3`)

Аналогичным образом побита на три массива таблица «go to», которая задаёт, в какое состояние нужно перейти после свёртки.

Код собственно парсера: (неинтересные куски вырезаны, а интересные прокомментированы)  
`yynewstate:     *++yyssp = yystate;    // кладём в стек текущее состояние`

  `yyn = yypact[yystate];` 

`// индекс первого действия     if (yyn == YYPACT_NINF)       goto yydefault;      // не зависит от входного символа    yychar = yylex();       // читаем входной символ     yytoken = yytranslate[yychar]; // определяем класс     yyn += yytoken;        // индекс внутрь yytable     if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)       goto yydefault;      // нет подходящего действия     yyn = yytable[yyn];if (yyn <= 0) {       yyn = -yyn;       goto yyreduce;     }    *++yyvsp = yylval;       // сдвигаем     yystate = yyn;          // следующее состояние     goto yynewstate;yydefault:     yyn = yydefact[yystate];     if (yyn == 0)          // ошибка синтаксиса:       goto yyerrlab;        //  ни одно действие не подошло,                             //  и нет действия по умолчанию   yyreduce:     yylen = yyr2[yyn];      // длина правой части правила    yyval = yyvsp[  1-yylen]; // по умолчанию: унаследовать $1// действия при свёртке:   // вместо $-тегов бизон подставил yyval слева и yyvsp[] справаswitch (yyn) {     case 2:       { printf("=%d\n", yyval); }       break;case 4:       { yyval = yyvsp[-2] + yyvsp[0]; }       break;case 5:       { yyval = yyvsp[-2] - yyvsp[0]; }       break;case 7:       { yyval = yyvsp[-2] * yyvsp[0]; }       break;case 8:       { yyval = yyvsp[-2] / yyvsp[0]; }       break;     }    yyvsp -= yylen;         // удаление из стека     yyssp -= yylen;    *++yyvsp = yyval;       // кладём свежесвёрнутую переменную    yyn = yyr1[yyn];         // номер переменной по номеру правила// вычисление следующего состояния после свёртки     yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;     if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)       yystate = yytable[yystate];     else       yystate = yydefgoto[yyn - YYNTOKENS];goto yynewstate;   `  
Вновь видим: весь парсер, вместе с вычислением выражения, уложился в пару страниц кода; да и то, его треть — мудрёный поиск по сжатым таблицам.

В следующий раз займёмся парсингом [игрушечного языка программирования](http://habrahabr.ru/blogs/programming/99397/).  
Достоинство бизона и ему подобных в том, что от усложнения языка вырастут в парсере только таблицы и свитч с действиями при свёртке, скопированными из `.y`\-файла.  
Весь остальной код парсера универсален: никаких спагетти, никаких рекурсивных функций, вызывающих друг друга в хитрых комбинациях. Правила грамматики действительно _компилируются_, а не обрамляются в синтаксис языка высокого уровня.
---
created: 2023-03-14T12:13:38 (UTC +03:00)
tags: [компиляция,bison,синтаксический анализ,абстрактное синтаксическое дерево]
source: https://habr.com/ru/post/99397/
author: Artyom Skrobov
---

# Компиляция. 4: игрушечный ЯП / Хабр

> ## Excerpt
> С грамматиками калькуляторов поиграли достаточно, переходим к языкам программирования. Бета-тестеры статьи подали идею писать JavaScript-подобный язык: начнём с...

---
Время на прочтение 18 мин

Количество просмотров 18K

С грамматиками калькуляторов поиграли достаточно, переходим к языкам программирования. Бета-тестеры статьи подали идею писать JavaScript-подобный язык: начнём с простейшего скобчатого скелета, и будем его постепенно обращивать наворотами — синтаксическим сахаром, типами данных, поддержкой функций, и т.д.

Чтобы неполноценность нашего языка была понятна уже из названия, назовём его JSkrip.

### Далее в посте

  

1.  Синтаксис
2.  Грамматика
3.  Парсер
4.  Синтаксическое дерево
5.  Pretty-printing

  

### Синтаксис

В начальном варианте языка будут арифметические конструкции над целыми числами, `if`, `while`, и `exit`; и пара «предопределённых функций»: `echo()` для печати, и `input()` для ввода.

`from = 0; to = 1000;   echo("Задумай число от ",from," до ",to,", а я буду угадывать\n");   while (from <= to) {      guess = (from+to)/2;      echo("Это ",guess,"?  (1=меньше, 2=больше, 3=попал) ");      i = input();      if (i==1)         to = guess-1;      else if (i==2)         from = guess+1;      else if (i==3) {         echo("Ура! Я молодец!\n");         exit;      } else         echo("Я ничего не понял!\n");   }   echo("Врёшь, так не бывает!\n");   `

### Грамматика

Смотрим на пример программы, и пытаемся формализовать язык:

`PROGRAM: OPS ;  // последовательность операторов   OPS: OP | OPS OP ;   OP: '{' OPS '}' // блок       | EXPR ';'  // выражение       | 'if' '(' EXPR ')' OP       | 'if' '(' EXPR ')' OP 'else' OP       | 'while' '(' EXPR ')' OP       | 'exit' ';' ;   EXPR: NUM // переменная       | ID  // литерал       | ID '(' ARGS ')' // вызов функции       | EXPR '+' EXPR | EXPR '-' EXPR | EXPR '*' EXPR | EXPR '/' EXPR | '(' EXPR ')' | '-' EXPR // арифметика       | EXPR '==' EXPR | EXPR '<=' EXPR | EXPR '>=' EXPR | EXPR '!=' EXPR | EXPR '>' EXPR | EXPR '<' EXPR       | '!' EXPR // не будем заводить отдельные булевы операции; вместо && будет *, и вместо || будет +       | ID '=' EXPR ;   // присваивание   ARGS: // пустой список       | ARG // один аргумент       | ARGS ',' ARG ;   ARG: EXPR | STRING ;  // строки возможны только в аргументах   `

Натыкаемся на уже знакомые неоднозначности: с `else`, и с группировкой операторов в выражении. Уже знаем, как [починить грамматику](http://habrahabr.ru/blogs/programming/99298/):

`PROGRAM: OPS ;   OPS: OP | OPS OP ;   // операторы, за которыми может следовать else внешнего условия   **OP1**: '{' OPS '}' | EXPR ';'        | 'if' '(' EXPR ')' **OP1** 'else' **OP1** // if с else: оператором не может быть if без else        | 'while' '(' EXPR ')' **OP1**        | 'exit' ';' ;   // операторы, заканчивающиеся на if без else   **OP2**: 'if' '(' EXPR ')' OP     // if без else: оператор может быть любой        | IF '(' EXPR ')' **OP1** ELSE **OP2**        | WHILE '(' EXPR ')' **OP2** ;   **OP: OP1 | OP2 ;**   EXPR: **EXPR1** | ID '=' EXPR ;   // низший приоритет и правая ассоциативность   // остальные операторы левоассоциативные, по возрастанию приоритета   **EXPR1**: **EXPR2**        | **EXPR1** '==' **EXPR2** | **EXPR1** '<=' **EXPR2** | **EXPR1** '>=' **EXPR2**        | **EXPR1** '!=' **EXPR2** | **EXPR1** '>' **EXPR2** | **EXPR1** '<' **EXPR2** ;   **EXPR2**: **TERM** | **EXPR2** '+' **TERM** | **EXPR2** '-' **TERM** ;   **TERM**: **VAL** | **TERM** '*' **VAL** | **TERM** '/' **VAL** ;   **VAL**: NUM | '-' **VAL** | '!' **VAL** | '(' EXPR ')' | ID | ID '(' ARGS ')' ;   ARGS: | ARG | ARGS ',' ARG ;   ARG: EXPR | STRING ;   `

### Парсер

Достаточно добавить привычный [бизоний](http://habrahabr.ru/blogs/programming/99366/) заголовок, чтобы превратить грамматику в парсер-пустышку:

`%{       #include <iostream>       extern int yylineno;       extern int yylex();       void yyerror(char *s) {         std::cerr << s << ", line " << yylineno << std::endl;         exit(1);       }       #define YYSTYPE std::string   %}%token IF ELSE WHILE EXIT   %token EQ LE GE NE   %token STRING NUM ID%%PROGRAM: OPS   ;OPS:    OP   |       OPS OP   ;OP1:    '{' OPS '}'   |       EXPR ';'   |       IF '(' EXPR ')' OP1 ELSE OP1   |       WHILE '(' EXPR ')' OP1   |       EXIT ';'   ;OP2:    IF '(' EXPR ')' OP   |       IF '(' EXPR ')' OP1 ELSE OP2   |       WHILE '(' EXPR ')' OP2   ;OP:     OP1 | OP2 ;EXPR:   EXPR1   |       ID '=' EXPREXPR1:  EXPR2   |       EXPR1 EQ EXPR2   |       EXPR1 LE EXPR2   |       EXPR1 GE EXPR2   |       EXPR1 NE EXPR2   |       EXPR1 '>' EXPR2   |       EXPR1 '<' EXPR2   ;EXPR2: TERM   |       EXPR2 '+' TERM   |       EXPR2 '-' TERM   ;TERM:   VAL   |       TERM '*' VAL   |       TERM '/' VAL   ;VAL:    NUM   |       '-' VAL   |       '!' VAL   |       '(' EXPR ')'   |       ID   |       ID '(' ARGS ')'   ;ARGS:   |       ARG   |       ARGS ',' ARG   ;ARG:    EXPR   |       STRING   ;%%   int main() { return yyparse(); }   `  
В этот раз нам удобнее в каждом токене хранить не число, а строку (`std::string`). Тип для значений символов задаётся макросом `YYSTYPE`.

Осталось приделать к грамматике [лексер](http://habrahabr.ru/blogs/programming/99162/); в нём будет небольшая хитрость — именованные состояния, для распознавания искейпов внутри строк.  
Файлы нашего языка будем называть `jsk`.

`%{      #include <string>      #define YYSTYPE std::string      #include "jsk.tab.h"      void yyerror(char *s);   %}`

`%option yylineno   %option noyywrap`

`%x STR%%[/][/].*\n      ; // comment   if              return IF;   else            return ELSE;   while           return WHILE;   exit            return EXIT;   ==              return EQ;   [<]=            return LE;   >=              return GE;   !=              return NE;   [0-9]+          { yylval = yytext;                     return NUM;                   }   [a-zA-Z_][a-zA-Z0-9_]* { yylval = yytext;                     return ID;                   }   ["]             { yylval = ""; BEGIN(STR); }   <STR>[^\\\n"]+  yylval += yytext;   <STR>\\n        yylval += '\n';   <STR>\\["]      yylval += '"';   <STR>\\         yyerror("Invalid escape sequence");   <STR>\n         yyerror("Newline in string literal");   <STR>["]        { BEGIN(INITIAL); return STRING; }   [ \t\r\n]       ; // whitespace   [-{};()=<>+*/!,] { return *yytext; }   .               yyerror("Invalid character");%%   `  
Объявление **%x** определяет _именованное состояние_, в которое лексер переходит не в результате чтения входных символов, а в результате явного вызова `BEGIN(STR)`. Начальное состояние называется `INITIAL`; чтобы вернуться в него, вызываем `BEGIN(INITIAL)`. В результате у нас в лексере есть два разных набора регэкспов: один для основной программы, другой для строковых литералов. На каждой кавычке переключаемся между этими двумя наборами.

Получившийся парсер-пустышка ищет в программе ошибки синтаксиса; и если не находит, то не выводит ничего:  
`[tyomitch@home ~]$ **lex jsk.lex**   [tyomitch@home ~]$ **bison -d jsk.y**   [tyomitch@home ~]$ **c++ lex.yy.c jsk.tab.c**   [tyomitch@home ~]$ **./a.out < test.jsk**   [tyomitch@home ~]$ **./a.out**   **{ foo();   bar; }   }   **syntax error, line 3   `

## Синтаксическое дерево

Что можно сделать полезного в свёртке правила?  
В прошлые разы нам удавалось прямо в свёртках, прямо по ходу разбора, выполнять все необходимые действия (вычислять значение выражения).  
Более универсальный подход — строить для входного текста дерево, соответствующее синтаксической структуре текста, и после завершения разбора обрабатывать это дерево. Для получения информации из деревьев есть масса методов, не связанных с компиляцией: от рекурсивных обходов до XPath-запросов.

Определим для каждого типа узла в дереве отдельный класс, и в стеке парсера будем хранить указатели на объекты-узлы. Кроме них, в стеке могут лежать пришедшие от лексера строки, а также «промежуточные результаты», для которых решим не выделять в дереве отдельного узла. В нашем примере, символу `ARGS` не соответствует узел дерева: ссылки на все аргументы функции будем хранить прямо в узле «вызов функции». Иными словами, синтаксическое дерево не обязано соответствовать дереву разбора в точности; имеем право перестраивать его поудобнее. Другой пример несоответствия — что в нашем синтаксическом дереве не будет узла «оператор»; только «список операторов» — возможно, из одного элемента.

`%{       #include <iostream>       #include <list>       extern int yylineno;       extern int yylex();       void yyerror(char *s) {           std::cerr << s << ", line " << yylineno << std::endl;           exit(1);       }class oper_t { // abstract           protected: oper_t() {}           public: virtual ~oper_t() {}       };class expr_t { // abstract           protected: expr_t() {}           public: virtual ~expr_t() {}       };class block : public oper_t {           std::list<oper_t*> ops;           void append(oper_t* op) {               block* b = dynamic_cast<block*>(op);               if(b) {                   ops.splice(ops.end(), b->ops, b->ops.begin(), b->ops.end());                   delete b;               }               else ops.push_back(op);           }           public:               block() {}               block(oper_t* op) { append(op); }               block(oper_t* op1, oper_t* op2) { append(op1); append(op2); }       };class exprop : public oper_t {           expr_t* expr;           public: exprop(expr_t* expr) : expr(expr) {}       };class ifop : public oper_t {           expr_t* cond;           block thenops, elseops;           public: ifop(expr_t* cond, oper_t* thenops, oper_t* elseops) :                   cond(cond), thenops(thenops), elseops(elseops) {}       };class whileop : public oper_t {           expr_t* cond;           block ops;           public: whileop(expr_t* cond, oper_t* ops) : cond(cond), ops(ops) {}       };class exitop : public oper_t {};class binary : public expr_t {           const char* op;           expr_t *arg1, *arg2;           public: binary(const char* op, expr_t *arg1, expr_t *arg2) :                   op(op), arg1(arg1), arg2(arg2) {}       };class assign : public expr_t {           std::string name;           expr_t* value;           public: assign(const std::string& name, expr_t* value) :                   name(name), value(value) {}       };class unary : public expr_t {           const char* op;           expr_t* arg;           public: unary(const char* op, expr_t* arg) : op(op), arg(arg) {}       };class funcall : public expr_t {           std::string name;           std::list<expr_t*> args;           public: funcall(const std::string& name,                   const std::list<expr_t*>& args) :                   name(name), args(args) {}       };class value : public expr_t {           std::string text;           public: value(const std::string& text) : text(text) {}       };// возможные значения символа: строка, оператор, выражение, список аргументов       typedef struct {           std::string str;           oper_t* oper;           expr_t* expr;           std::list<expr_t*> args;       } YYSTYPE;       #define YYSTYPE YYSTYPE// глобальная замена       std::string replaceAll(const std::string& where, const std::string& what, const std::string& withWhat) {           std::string result = where;           while(1) {               int pos = result.find(what);               if (pos==-1) return result;               result.replace(pos, what.size(), withWhat);           }       }   %}%token IF ELSE WHILE EXIT   %token EQ LE GE NE   %token STRING NUM ID%type<str> ID NUM STRING   %type<oper> OPS OP1 OP2 OP   %type<expr> EXPR EXPR1 EXPR2 TERM VAL ARG   %type<args> ARGS%%PROGRAM: OPS                            // обработка дерева программы   ;OPS:    OP                              // inherit   |       OPS OP                          { $$ = new block($1, $2); }   ;OP1:    '{' OPS '}'                     { $$ = $2; }   |       EXPR ';'                        { $$ = new exprop($1); }   |       IF '(' EXPR ')' OP1 ELSE OP1    { $$ = new ifop($3, $5, $7); }   |       WHILE '(' EXPR ')' OP1          { $$ = new whileop($3, $5); }   |       EXIT ';'                        { $$ = new exitop(); }   ;OP2:    IF '(' EXPR ')' OP              { $$ = new ifop($3, $5, new block()); }   |       IF '(' EXPR ')' OP1 ELSE OP2    { $$ = new ifop($3, $5, $7); }   |       WHILE '(' EXPR ')' OP2          { $$ = new whileop($3, $5); }   ;OP:     OP1 | OP2 ;                     // inheritEXPR:   EXPR1                           // inherit   |       ID '=' EXPR                     { $$ = new assign($1, $3); }EXPR1:  EXPR2                           // inherit   |       EXPR1 EQ EXPR2                  { $$ = new binary("==", $1, $3); }   |       EXPR1 LE EXPR2                  { $$ = new binary("<=", $1, $3); }   |       EXPR1 GE EXPR2                  { $$ = new binary(">=", $1, $3); }   |       EXPR1 NE EXPR2                  { $$ = new binary("!=", $1, $3); }   |       EXPR1 '>' EXPR2                 { $$ = new binary(">", $1, $3); }   |       EXPR1 '<' EXPR2                 { $$ = new binary("<", $1, $3); }   ;EXPR2:  TERM                            // inherit   |       EXPR2 '+' TERM                  { $$ = new binary("+", $1, $3); }   |       EXPR2 '-' TERM                  { $$ = new binary("-", $1, $3); }   ;TERM:   VAL                             // inherit   |       TERM '*' VAL                    { $$ = new binary("*", $1, $3); }   |       TERM '/' VAL                    { $$ = new binary("/", $1, $3); }   ;VAL:    NUM                             { $$ = new value($1); }   |       '-' VAL                         { $$ = new unary("-", $2); }   |       '!' VAL                         { $$ = new unary("!", $2); }   |       '(' EXPR ')'                    { $$ = $2; }   |       ID                              { $$ = new value($1); }   |       ID '(' ARGS ')'                 { $$=new funcall($1, $3); }   ;ARGS:                                   { $$.clear(); }   |       ARG                             { $$.clear(); $$.push_back($1); }   |       ARGS ',' ARG                    { $$ = $1; $$.push_back($3); }   ;ARG:    EXPR                            // inherit   |       STRING                          { $$=new value('"'+replaceAll($1, "\n", "\\n")+'"'); }   ;%%   int main() { return yyparse(); }   `  
Объявление `%type<str>` задаёт для символов грамматики (терминалов и нетерминалов), каким из полей `YYSTYPE` следует пользоваться в качестве значения символа. Если поле задано, то бизон будет подставлять его каждый раз, когда **$**\-тег относится к такому символу грамматики. Если поле не задано (как в предыдущих примерах), то `YYSTYPE` используется целиком.  
В классических сишных парсерах `YYSTYPE` объявляли как `union`: каждый символ по-своему трактует одно и то же хранимое значение. Нам такое не подходит: объект с деструктором не может быть полем `union`; поэтому объявляем `YYSTYPE` как структуру, и ненужные символу поля структуры будут просто занимать зря память. Но мы не жадные.

Неприятный момент — что из-за починки конфликта с `else` в грамматике появилось два одинаковых правила `if..else` и два одинаковых правила `while`. На нашей совести выбрать, что неприятнее: задавать приоритет для `else` и **)**, как будто бы они операторы; или копипастить код свёртки дважды.

Итак, наш парсер строит в памяти дерево, и когда оно готово — просто выходит, даже не освобождая память. Не слишком-то впечатляюще?

## Pretty-printing

Нужно совсем немного усилий, чтобы парсер делал нечто осмысленное; например, расставлял в выражениях скобки, удалял избыточные **{}** и, и вдобавок выравнивал операторы по BSD Kernel Normal Form.  
Добавим в наши древесные классы рекурсивную распечатку.  
Меняются только определения классов, и свёртка символа `PROGRAM`.

`#define TOKENPASTE(x, y) x ## y   #define TOKENPASTE2(x, y) TOKENPASTE(x, y)   #define foreach(i, list) typedef typeof(list) TOKENPASTE2(T,__LINE__); \                       for(TOKENPASTE2(T,__LINE__)::iterator i = list.begin(); i != list.end(); i++)class oper_t { // abstract           protected: oper_t() {}           public: virtual ~oper_t() {}           **virtual void print(int indent=0) =0;**       };class expr_t { // abstract           protected: expr_t() {}           public: virtual ~expr_t() {}           **virtual void print() =0;**       };class block : public oper_t {           std::list<oper_t*> ops;           void append(oper_t* op) {               block* b = dynamic_cast<block*>(op);               if(b) {                   ops.splice(ops.end(), b->ops, b->ops.begin(), b->ops.end());                   delete b;               }               else ops.push_back(op);           }           public:               block() {}               block(oper_t* op) { append(op); }               block(oper_t* op1, oper_t* op2) { append(op1); append(op2); }           int size() { return ops.size(); }           **virtual void print(int indent=0) {               foreach(i, ops) {                   std::cout << std::string(indent, '\t');                   (*i)->print(indent);               }           }           virtual ~block() { foreach(i, ops) delete *i; }**       };class exprop : public oper_t {           expr_t* expr;           public: exprop(expr_t* expr) : expr(expr) {}           **virtual void print(int indent=0) {               expr->print();               std::cout << ";" << std::endl;           }           virtual ~exprop() { delete expr; }**       };class ifop : public oper_t {           expr_t* cond;           block thenops, elseops;           public: ifop(expr_t* cond, oper_t* thenops, oper_t* elseops) :                   cond(cond), thenops(thenops), elseops(elseops) {}           **virtual void print(int indent=0) {               std::cout << "if "; cond->print();  std::cout << " {" << std::endl;               thenops.print(indent+1);               if (elseops.size()) {                   std::cout << std::string(indent, '\t') << "} else {" << std::endl;                   elseops.print(indent+1);               }               std::cout << std::string(indent, '\t') << "}" << std::endl;           }           virtual ~ifop() { delete cond; }**       };class whileop : public oper_t {           expr_t* cond;           block ops;           public: whileop(expr_t* cond, oper_t* ops) : cond(cond), ops(ops) {}           **virtual void print(int indent=0) {               std::cout << "while "; cond->print();  std::cout << " {" << std::endl;               ops.print(indent+1);               std::cout << std::string(indent, '\t') << "}" << std::endl;           }           virtual ~whileop() { delete cond; }**       };class exitop : public oper_t {           **virtual void print(int indent=0) { std::cout << "exit;" << std::endl; }**       };class binary : public expr_t {           const char* op;           expr_t *arg1, *arg2;           public: binary(const char* op, expr_t *arg1, expr_t *arg2) :                   op(op), arg1(arg1), arg2(arg2) {}           **virtual void print() {               std::cout<<"(";               arg1->print();               std::cout<<op;               arg2->print();               std::cout<<")";           }           virtual ~binary() { delete arg1; delete arg2; }**       };class assign : public expr_t {           std::string name;           expr_t* value;           public: assign(const std::string& name, expr_t* value) :                   name(name), value(value) {}           **virtual void print() { std::cout<<name<<" = "; value->print(); }           virtual ~assign() { delete value; }**       };class unary : public expr_t {           const char* op;           expr_t* arg;           public: unary(const char* op, expr_t* arg) : op(op), arg(arg) {}           **virtual void print() { std::cout<<op; arg->print(); }           virtual ~unary() { delete arg; }**       };class funcall : public expr_t {           std::string name;           std::list<expr_t*> args;           public: funcall(const std::string& name,                   const std::list<expr_t*>& args) :                   name(name), args(args) {}           **virtual void print() {               std::cout<<name<<"(";               foreach(i,args) {                   if (i!=args.begin())                       std::cout<<", ";                   (*i)->print();               }               std::cout<<")";           }           virtual ~funcall() { foreach(i,args) delete *i; }**       };class value : public expr_t {           std::string text;           public: value(const std::string& text) : text(text) {}           **virtual void print() { std::cout<<text; }**       };PROGRAM: OPS                            { **$1->print(); delete $1;** }   ;   `  
Проверяем, что получилось:  
`[tyomitch@home ~]$ **lex jsk.lex**   [tyomitch@home ~]$ **bison -d jsk.y**   [tyomitch@home ~]$ **c++ jsk.tab.c lex.yy.c**   [tyomitch@home ~]$ **./a.out < test.jsk**   from = 0;   to = 1000;   echo("Задумай число от ", from, " до ", to, ", а я буду угадывать\n");   while (from <= to) {       guess = ((from + to) / 2);       echo("Это ", guess, "? (1=меньше, 2=больше, 3=попал) ");       i = input();       if (i == 1) {           to = (guess - 1);       } else {           if (i == 2) {               from = (guess + 1);           } else {               if (i == 3) {                   echo("Ура! Я молодец!\n");                   exit;               } else {                   echo("Я ничего не понял!\n");               }           }       }   }   echo("Врёшь, так не бывает!\n");   `  
Форматированная распечатка входного текста — общепринятый способ первоначальной проверки парсера. Пример кода из начала поста не слишком удачный в этом плане, т.к. покрывает далеко не все языковые конструкции. Но он и предназначен для иллюстрации языка, а не для тестирования.

Понятно, что ради одного лишь форматирования текста не было смысла заморачиваться с деревьями: достаточно было бы хранить в стеке для каждого оператора список текстовых строк, и в свёртках сливать эти строки, добавляя отступы. Да что там, ради отступов не нужно даже бизона: и flex бы справился. (Хотя расстановка скобок — это немного интереснее.)

В следующий раз [отдохнём от бизона](http://habrahabr.ru/blogs/programming/99466/).
---
created: 2023-03-14T12:01:00 (UTC +03:00)
tags: [компиляция,теория автоматов,синтаксический анализ]
source: https://habr.com/ru/post/99466/
author: Artyom Skrobov
---

# Компиляция. 5: нисходящий разбор / Хабр

> ## Excerpt
> До сих пор занимались восходящим синтаксическим разбором. Какие ещё есть варианты? Отложим бизона в сторону, и вернёмся к теории.  Далее в посте: Идея Воплощение...

---
Время на прочтение 10 мин

Количество просмотров 23K

До сих пор занимались восходящим синтаксическим разбором. Какие ещё есть варианты?  
Отложим бизона в сторону, и вернёмся к теории.

### Далее в посте:

1.  Идея
2.  Воплощение
3.  Холивар
4.  Бэктрекинг

### Идея

Помним, что [общая идея](http://habrahabr.ru/blogs/programming/99298/) восходящего разбора в следующем: читая входную строку, сдвигаем её по одному символу в стек; как только наверху стека образовывается комбинация, подходящая под какое-нибудь правило грамматики, сворачиваем её в один нетерминал, и продолжаем дальше.  
Важная особенность этого метода — что во время свёртки правила у нас уже есть на руках все его составляющие, и мы можем [строить из них дерево](http://habrahabr.ru/blogs/programming/99397/) с какой захотим структурой, или даже прямо на ходу [использовать для вычислений](http://habrahabr.ru/blogs/programming/99366/).

Противоположный подход состоит в том, что начинаем _разворачивать_ начальный символ грамматики, выбирая разворачиваемое правило в соответствии со следующим входным символом.  
Например, если у нас в грамматике есть правила

```
OP: '{' OPS '}' // блок
    | EXPR ';'  // выражение
    | 'if' '(' EXPR ')' OP
    | 'if' '(' EXPR ')' OP 'else' OP
    | 'while' '(' EXPR ')' OP
    | 'exit' ';' ;

```

и мы видим, что дальше в тексте идёт `while`, тогда разворачивать будем по правилу `OP: 'while' '(' EXPR ')' OP ;`

Для магазинного автомата такой парсинг можно реализовать следующим образом:

-   Во время развёртки, записываем в стек правую часть правила: продолжение текста будем разбирать в соответствии с ней.
-   Если наверху стека терминал, и во входном тексте такой же терминал, значит, текст соответствует ожидаемому. Удаляем верхний терминал из стека, читаем следующий символ текста.
-   Если наверху стека нетерминал, значит его надо развернуть. Правило для развёртки выбираем на основании входного символа.

Сразу же обратим внимание, что действие при развёртке выполнять бессмысленно: правая часть развёрнутого правила ещё не прочитана, и неизвестно, будет ли прочитана вообще. Можно было бы при развёртке класть в стек под символы правой части пустышку-сигнал «правило успешно прочитано, можно выполнять действие»; но к этому моменту вся правая часть уже стёрта из стека! С чем же действие будет работать?

Но основная сложность нисходящего разбора не в этом, а в том, как выбрать подходящее правило для развёртки.  
Вспомним грамматику, которая бизону не по зубам:

```
WORD: S1 'a' 'i' 'l' | S2 'a' 'l' 'e' ;
S1: 's' ;
S2: 's' ;

```

Как нам разворачивать `WORD`, когда следующий символ `'s'`?  
Непонятно, как выбирать: оба правила для `WORD` начинаются именно на `'s'`.

### Воплощение

Можно разрешить автомату заглядывать вперёд дальше, чем на один символ: этот подход, судя по отзывам, применили в ANTLR, популярном генераторе LL-парсеров.  
Техническая сложность в том, что каждый новый символ, от которого зависит выполнение развёртки, увеличивает _размерность_ таблиц перехода; так что несжатые таблицы для автомата из N состояний, читающего 3 символа из текста (плюс к символу из стека), содержали бы N·256<sup>4</sup> элементов, а это десятки гигабайт.  
Поэтому применимость LL-парсинга с далёким заглядыванием вперёд определяется именно способностью генератора парсеров эффективно сжимать таблицы (вспомним, как бизон сжал нам таблицу 258х14 в семь коротких одномерных массивов).

LR-парсеры с далёким заглядыванием вперёд, насколько я понимаю, не делают — потому, что и так всех всё устраивает: конфликты, вызванные недостаточно далёким заглядыванием, в LR-парсерах редки. Чтобы нашу грамматику мог разпознавать бизон, достаточно не просить его выбрать между двумя одинаковыми свёртками:

```
WORD: 's' 'a' 'i' 'l' | 's' 'a' 'l' 'e' ;

```

С другой стороны, для LL-парсера ничего не изменилось: по-прежнему оба правила соответствуют символу `'s'`. Поэтому, чтобы «адаптировать» грамматику для LL-разбора, общее начало разных правил для одного и того же нетерминала выносят во «вспомогательный нетерминал»:

```
WORD1: 's' 'a' WORD ;
WORD: 'i' 'l' | 'l' 'e' ;

```

Этот трюк называется «левая факторизация»: из одинаково начинающихся правил как будто бы выносится «общий множитель».  
Теперь развёртка `WORD1` однозначная, а две возможные развёртки для `WORD` начинаются на разные буквы.

Зачем заморачиваться с факторизацией и плодить в грамматике бессмысленные нетерминалы, если чудо-сжиматель ANTLR способен заглядывать сколько захочет вперёд?  
Вернёмся к грамматике

```
OP: '{' OPS '}' // блок
    | EXPR ';'  // выражение
    | 'if' '(' EXPR ')' OP
    | 'if' '(' EXPR ')' OP 'else' OP
    | 'while' '(' EXPR ')' OP
    | 'exit' ';' ;

```

Как разворачивать `OP`, когда следующий символ `if`? Есть два правила, которые могут так начинаться; и их общая часть — `'if' '(' EXPR ')' OP` — может быть _произвольной_ длины, так что как далеко бы парсер ни заглядывал вперёд, это его не спасёт.

Другая проблема, с которой LL не может справиться, — левая рекурсия. Помним грамматику калькулятора торговок с рынка:

```
EXPR: NUM | EXPR OP NUM ;

```

Оба правила для `EXPR` начинаются на `NUM`: первое явно, второе неявно; при этом нет общего «фактора», который можно было бы вынести из правил наружу. Если предположим ещё, что длина `NUM` не ограничена, — понятно, что никакое заглядывание вперёд проблему не решит.

Чтобы починить грамматику, отталкиваемся от её _смысла_: первый `NUM` в строке — готовое выражение, а все остальные выражения содержат по два операнда.

```
EXPR: NUM EXPR1 ;
EXPR1: | OP NUM EXPR1 ;

```

Левой факторизацией и устранением левой рекурсии можно любую однозначную грамматику приспособить для LL-парсинга, ценой добавления уймы вспомогательных нетерминалов, совершенно бессмысленных.  
Например, в свёртке правила `EXPR: EXPR OP NUM ;` мы запросто строили узел синтаксического дерева: левый аргумент — вот он, в `$1`; правый аргумент — вот он, в `$3`. А что можно сделать при развёртке `EXPR1: OP NUM EXPR1 ;`? Левый аргумент _уже развёрнут и стёрт из стека_; зато у нас в руках есть `EXPR1` — под-выражение после правого аргумента. Будто бы в нём какой-то прок!

Важно то, что левая рекурсия _естественна_ для всех левоассоциативных операций — а их большинство. Поэтому неразбериха типа вышеприведённой — не редкий курьёз, а типичный случай.

С одной стороны, приведение грамматики к LL-виду совершенно формально, и его можно поручить бездушной железяке. С другой стороны, как отлаживать автомат, который работает не по заданной грамматике, а по какой-то своей?  
В частности, нам не дадут писать действия для развёрток, потому что развёртываться всё равно будут не те правила, которые задали мы, — а какие-то другие, которые железяка задала себе сама. Хорошо ещё, если такой парсер сумеет сгенерировать заданное дерево разбора; для этого ему придётся соотносить правила заданной грамматики с теми правилами, по которым фактически работает автомат, и перестраивать дерево, «возвращая на место» узлы, переехавшие из одного правила в другое.

### Холивар

Спор о преимуществах LL vs. LR так же стар, как автоматический синтаксический разбор вообще; у обоих подходов свои сторонники. Например, глубоко уважаемый лично мной Никлаус Вирт был активным апологетом LL-разбора, и одним из design goals при разработке Паскаля была возможность LL(1)-разбора — т.е. автоматом, который видит только один следующий символ текста. Большинство «живых языков» в LL не укладываются: например, в Си на `int` может начинаться объявление либо переменной, либо функции, и мы не может отличить одно от другого, пока не дочитаем строку до конца.

По поводу удобства: в основном, каждый хвалит тот инструмент, к которому привык, и питает неприязнь к непривычному.  
Например, процитирую один «лучший ответ» со stackoverflow, касательно спора «[ANTLR vs. bison](http://stackoverflow.com/questions/212900/advantages-of-antlr-versus-say-lex-yacc-bison)»:

> In terms of personal taste, I think that LALR grammars are a lot easier to construct and debug. The downside is you have to deal with somewhat cryptic errors like shift-reduce and (the dreaded) reduce-reduce. These are errors that Bison catches when generating the parser, so it doesn't effect the end-user experience, but it can make the development process a bit more interesting.

В качестве преимуществ ANTLR в том споре приводят всё что угодно, кроме качеств собственно парсинга: удобную среду разработки, генерацию кода на разных языках, удобочитабельный генерируемый код.

Удобочитабельный генерируемый код — это самое сильное отличие ANTLR от табличных парсеров. Фактически, вместо специализированного стека разбора используется стек вызовов, и распознавание каждого правила грамматики реализуется как вызов функции (для рекурсивного правила — рекурсивная функция). Поэтому при отладке из стека вызовов непосредственно видно, как парсер попал в текущее состояние; тогда как с бизоном, как мы помним, приходится включать отладочную печать переходов между состояниями, и сверяться с распечаткой автомата, чтобы понять причину переходов.  
Недостатки рекурсивной реализации перед табличной также ясны: куда больший объём кода, а значит потребление памяти; невозможность написания «заплаток» на сгенерированный код, потому что он меняется при изменении грамматики, да ещё и размножается по десяткам функций.

### Бэктрекинг

LL-парсеры, предопределённым образом выбирающие правило для каждой развёртки, — не единственный вариант нисходящего синтаксического разбора. Альтернативная идея: когда есть несколько подходящих правил, попробуем _все_, какое-нибудь да подойдёт. Например, можно сделать нечто навроде `fork()`: создать клоны парсера в текущем состоянии, и каждый клон пусть пробует по одному из вариантов развёртки. Если клон натыкается на ошибку синтаксиса, он умирает. Если все клоны умерли, значит ни один вариант развёртки не подходит: во входном тексте синтаксическая ошибка.

Для правильных текстов этот подход более-менее приемлим; но с обнаружением ошибок возникают проблемы. Во-первых, которую из обнаруженных ошибок печатать? Большинство их — результат неверно выбранной развёртки, а не ошибки в тексте программы; но с точки зрения парсера, все совершенно равноправны.

Во-вторых, разбор может никогда не закончиться: каждый раз, когда делаем развёртку по леворекурсивному правилу, один из клонов будет точно в том же состоянии, как до развёртки; так что на каждом шаге будет получаться ещё один точно такой же клон, и так до бесконечности. Если один из клонов доберётся-таки до конца разбора, тогда всех остальных можно будет убить; а если, наоборот, все остальные клоны напорются на ошибки синтаксиса и умрут, и продолжать жить будет только бесполезно плодящийся клон?

Наконец, что делать с неоднозначными грамматиками? И LL-, и LR-парсеры обнаружат конфликты во время компиляции; здесь же компиляции, как таковой, нет: парсер руководствуется грамматикой практически в сыром виде, т.е. _интерпретирует_ её на ходу.  
Значит, может получиться, что для одного и того же текста будем получать то один разбор, то другой: смотря который клон раньше успеет закончить разбор.

Последнюю проблему решили наиболее оригинально: объявили, что возможность неоднозначного разбора — фундаментальная проблема грамматик, и вместо них нужно использовать _парсящие выражения_, которые отличаются по сути лишь тем, что между правилами развёртки задан строгий приоритет. Например, если грамматики  
`OP: EXPR ';' | 'if' '(' EXPR ')' OP | 'if' '(' EXPR ')' OP 'else' OP ;`  
и  
`OP: EXPR ';' | 'if' '(' EXPR ')' OP 'else' OP | 'if' '(' EXPR ')' OP ;`  
— это одна и та же самая неоднозначная грамматика, то парсящее выражение  
`OP: EXPR ';' / 'if' '(' EXPR ')' OP 'else' OP / 'if' '(' EXPR ')' OP`  
однозначно указывает парсеру «сначала попробуй распознать `if..else`, и только если не удастся, распознавай `if`\-без-`else`». А выражение  
`OP: EXPR ';' / 'if' '(' EXPR ')' OP / 'if' '(' EXPR ')' OP 'else' OP`  
означает «сначала распознавай `if`\-без-`else`», и поэтому `else` им вообще никогда не будет распознан.

Теперь вместо того, чтобы проверять все возможные развёртки одновременно, мы будем проверять их по очереди, в соответствии с приоритетом; к следующей развёртке переходим только тогда, когда предыдущая наткнулась на ошибку. По ссылке, упомянутой комментаторами, приводится [отличная метафора](http://thedeemon.livejournal.com/9974.html) для такого способа разбора:

> [![Изображение не загружено](data:text/html;base64,PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9InJ1IiBkYXRhLXZ1ZS1tZXRhPSIlN0IlMjJsYW5nJTIyOiU3QiUyMnNzciUyMjolMjJydSUyMiU3RCU3RCI+CjxoZWFkID4KICA8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CiAgPG1ldGEgbmFtZT0idmlld3BvcnQiIGNvbnRlbnQ9IndpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTEuMCx2aWV3cG9ydC1maXQ9Y292ZXIsbWF4aW11bS1zY2FsZT0xLHVzZXItc2NhbGFibGU9MCI+CiAgPG1ldGEgbmFtZT0icmVmZXJyZXIiIGNvbnRlbnQ9InVuc2FmZS11cmwiPgogIDx0aXRsZT7QodGC0YDQsNC90LjRhtCwINC90LUg0L3QsNC50LTQtdC90LAgLyDQpdCw0LHRgDwvdGl0bGU+CiAgPHN0eWxlPgogICAgLyogY3lyaWxsaWMtZXh0ICovCiAgICBAZm9udC1mYWNlIHsKICAgICAgZm9udC1mYW1pbHk6ICdGaXJhIFNhbnMnOwogICAgICBmb250LXN0eWxlOiBub3JtYWw7CiAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7CiAgICAgIGZvbnQtZGlzcGxheTogc3dhcDsKICAgICAgc3JjOiB1cmwoaHR0cHM6Ly9mb250cy5nc3RhdGljLmNvbS9zL2ZpcmFzYW5zL3YxMS92YTlCNGtETnhNWmRXZk1PRDVWblpLdmVTeGY2VEYwLndvZmYyKSBmb3JtYXQoJ3dvZmYyJyk7CiAgICAgIHVuaWNvZGUtcmFuZ2U6IFUrMDQ2MC0wNTJGLCBVKzFDODAtMUM4OCwgVSsyMEI0LCBVKzJERTAtMkRGRiwgVStBNjQwLUE2OUYsIFUrRkUyRS1GRTJGOwogICAgfQoKICAgIC8qIGN5cmlsbGljICovCiAgICBAZm9udC1mYWNlIHsKICAgICAgZm9udC1mYW1pbHk6ICdGaXJhIFNhbnMnOwogICAgICBmb250LXN0eWxlOiBub3JtYWw7CiAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7CiAgICAgIGZvbnQtZGlzcGxheTogc3dhcDsKICAgICAgc3JjOiB1cmwoaHR0cHM6Ly9mb250cy5nc3RhdGljLmNvbS9zL2ZpcmFzYW5zL3YxMS92YTlCNGtETnhNWmRXZk1PRDVWblpLdmVRaGY2VEYwLndvZmYyKSBmb3JtYXQoJ3dvZmYyJyk7CiAgICAgIHVuaWNvZGUtcmFuZ2U6IFUrMDQwMC0wNDVGLCBVKzA0OTAtMDQ5MSwgVSswNEIwLTA0QjEsIFUrMjExNjsKICAgIH0KCiAgICAvKiBsYXRpbi1leHQgKi8KICAgIEBmb250LWZhY2UgewogICAgICBmb250LWZhbWlseTogJ0ZpcmEgU2Fucyc7CiAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDsKICAgICAgZm9udC13ZWlnaHQ6IDUwMDsKICAgICAgZm9udC1kaXNwbGF5OiBzd2FwOwogICAgICBzcmM6IHVybChodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tL3MvZmlyYXNhbnMvdjExL3ZhOUI0a0ROeE1aZFdmTU9ENVZuWkt2ZVNCZjZURjAud29mZjIpIGZvcm1hdCgnd29mZjInKTsKICAgICAgdW5pY29kZS1yYW5nZTogVSswMTAwLTAyNEYsIFUrMDI1OSwgVSsxRTAwLTFFRkYsIFUrMjAyMCwgVSsyMEEwLTIwQUIsIFUrMjBBRC0yMENGLCBVKzIxMTMsIFUrMkM2MC0yQzdGLCBVK0E3MjAtQTdGRjsKICAgIH0KCiAgICAvKiBsYXRpbiAqLwogICAgQGZvbnQtZmFjZSB7CiAgICAgIGZvbnQtZmFtaWx5OiAnRmlyYSBTYW5zJzsKICAgICAgZm9udC1zdHlsZTogbm9ybWFsOwogICAgICBmb250LXdlaWdodDogNTAwOwogICAgICBmb250LWRpc3BsYXk6IHN3YXA7CiAgICAgIHNyYzogdXJsKGh0dHBzOi8vZm9udHMuZ3N0YXRpYy5jb20vcy9maXJhc2Fucy92MTEvdmE5QjRrRE54TVpkV2ZNT0Q1Vm5aS3ZlUmhmNi53b2ZmMikgZm9ybWF0KCd3b2ZmMicpOwogICAgICB1bmljb2RlLXJhbmdlOiBVKzAwMDAtMDBGRiwgVSswMTMxLCBVKzAxNTItMDE1MywgVSswMkJCLTAyQkMsIFUrMDJDNiwgVSswMkRBLCBVKzAyREMsIFUrMjAwMC0yMDZGLCBVKzIwNzQsIFUrMjBBQywgVSsyMTIyLCBVKzIxOTEsIFUrMjE5MywgVSsyMjEyLCBVKzIyMTUsIFUrRkVGRiwgVStGRkZEOwogICAgfQoKICAgIC8qIG5vbi1icmVha2luZyBoeXBoZW4gKi8KICAgIEBmb250LWZhY2UgewogICAgICBmb250LWZhbWlseTogJ0ZpcmEgU2Fucyc7CiAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDsKICAgICAgZm9udC13ZWlnaHQ6IDUwMDsKICAgICAgZm9udC1kaXNwbGF5OiBzd2FwOwogICAgICBzcmM6IHVybChodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tL2wvZm9udD9raXQ9S0ZPbENucUV1OTJGcjFNbUVVOXZCaDBfSXNIQWxtck82ZyZza2V5PWVlODgxNDUxYzU0MGZkZWMmdj12MjkpIGZvcm1hdCgnd29mZjInKTsKICAgICAgdW5pY29kZS1yYW5nZTogVSswMjAxMTsKICAgIH0KICA8L3N0eWxlPgogIDxsaW5rIHJlbD0icHJlbG9hZCIgaHJlZj0iaHR0cHM6Ly9hc3NldHMuaGFici5jb20vaGFici13ZWIvY3NzL2NodW5rLXZlbmRvcnMuYjYyMzg3MjYuY3NzIiBhcz0ic3R5bGUiPjxsaW5rIHJlbD0icHJlbG9hZCIgaHJlZj0iaHR0cHM6Ly9hc3NldHMuaGFici5jb20vaGFici13ZWIvanMvY2h1bmstdmVuZG9ycy40ZjY1NGYwYi5qcyIgYXM9InNjcmlwdCI+PGxpbmsgcmVsPSJwcmVsb2FkIiBocmVmPSJodHRwczovL2Fzc2V0cy5oYWJyLmNvbS9oYWJyLXdlYi9jc3MvYXBwLjMyYjg0MzYyLmNzcyIgYXM9InN0eWxlIj48bGluayByZWw9InByZWxvYWQiIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2pzL2FwcC40OTVhYTRiMC5qcyIgYXM9InNjcmlwdCI+PGxpbmsgcmVsPSJwcmVsb2FkIiBocmVmPSJodHRwczovL2Fzc2V0cy5oYWJyLmNvbS9oYWJyLXdlYi9qcy9wYWdlLWVycm9yLmUzZTc1NTA4LmpzIiBhcz0ic2NyaXB0Ij4KICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2Nzcy9jaHVuay12ZW5kb3JzLmI2MjM4NzI2LmNzcyI+PGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2Fzc2V0cy5oYWJyLmNvbS9oYWJyLXdlYi9jc3MvYXBwLjMyYjg0MzYyLmNzcyI+CiAgPHNjcmlwdD53aW5kb3cuaTE4bkZldGNoID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7CiAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTsKICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCAnL2pzL2kxOG4vcnUtY29tcGlsZWQuYmI1NDAzNmUyMGQ1ZjJmNDM2YzI2ZTZjMTc2OWI2YjguanNvbicpOwogICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJzsKICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7CiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7CiAgICAgICAgICAgICAgcmVzKHtydTogeGhyLnJlc3BvbnNlfSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmVqKGUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9OwogICAgICAgICAgeGhyLnNlbmQoKTsKICAgICAgICB9KTs8L3NjcmlwdD4KICAKICAKICA8c2NyaXB0IHNyYz0iLy93d3cuZ29vZ2xldGFnc2VydmljZXMuY29tL3RhZy9qcy9ncHQuanMiIGFzeW5jPjwvc2NyaXB0PgogIDxzdHlsZT4uZ3JlY2FwdGNoYS1iYWRnZXt2aXNpYmlsaXR5OiBoaWRkZW47fTwvc3R5bGU+CiAgPG1ldGEgbmFtZT0iaGFici12ZXJzaW9uIiBjb250ZW50PSIyLjExNS4wIj4KICA8bWV0YSBuYW1lPSJjc3JmLXRva2VuIiBjb250ZW50PSJWZ2VSNHluVC1YYnNzNTlRbFVBTDZZOHRCYTEzMnp5eGRGT0EiPgogIDxtZXRhIGRhdGEtdnVlLW1ldGE9InNzciIgaXRlbXByb3A9ImltYWdlIiBjb250ZW50PSIvaW1nL2hhYnJfcnUucG5nIiBkYXRhLXZtaWQ9ImltYWdlOml0ZW1wcm9wIj48bWV0YSBkYXRhLXZ1ZS1tZXRhPSJzc3IiIHByb3BlcnR5PSJvZzppbWFnZSIgY29udGVudD0iL2ltZy9oYWJyX3J1LnBuZyIgZGF0YS12bWlkPSJvZzppbWFnZSI+PG1ldGEgZGF0YS12dWUtbWV0YT0ic3NyIiBwcm9wZXJ0eT0ib2c6aW1hZ2U6d2lkdGgiIGNvbnRlbnQ9IjEyMDAiIGRhdGEtdm1pZD0ib2c6aW1hZ2U6d2lkdGgiPjxtZXRhIGRhdGEtdnVlLW1ldGE9InNzciIgcHJvcGVydHk9Im9nOmltYWdlOmhlaWdodCIgY29udGVudD0iNjMwIiBkYXRhLXZtaWQ9Im9nOmltYWdlOmhlaWdodCI+PG1ldGEgZGF0YS12dWUtbWV0YT0ic3NyIiBwcm9wZXJ0eT0iYWl0dXJlYzppbWFnZSIgY29udGVudD0iL2ltZy9oYWJyX3J1LnBuZyIgZGF0YS12bWlkPSJhaXR1cmVjOmltYWdlIj48bWV0YSBkYXRhLXZ1ZS1tZXRhPSJzc3IiIG5hbWU9InR3aXR0ZXI6aW1hZ2UiIGNvbnRlbnQ9Ii9pbWcvaGFicl9ydS5wbmciIGRhdGEtdm1pZD0idHdpdHRlcjppbWFnZSI+PG1ldGEgZGF0YS12dWUtbWV0YT0ic3NyIiBwcm9wZXJ0eT0idms6aW1hZ2UiIGNvbnRlbnQ9Ii9pbWcvaGFicl9ydS5wbmc/Zm9ybWF0PXZrIiBkYXRhLXZtaWQ9InZrOmltYWdlIj48bWV0YSBkYXRhLXZ1ZS1tZXRhPSJzc3IiIHByb3BlcnR5PSJmYjphcHBfaWQiIGNvbnRlbnQ9IjQ0NDczNjc4ODk4NjYxMyI+PG1ldGEgZGF0YS12dWUtbWV0YT0ic3NyIiBwcm9wZXJ0eT0iZmI6cGFnZXMiIGNvbnRlbnQ9IjQ3MjU5NzkyNjA5OTA4NCI+PG1ldGEgZGF0YS12dWUtbWV0YT0ic3NyIiBuYW1lPSJ0d2l0dGVyOmNhcmQiIGNvbnRlbnQ9InN1bW1hcnlfbGFyZ2VfaW1hZ2UiPjxtZXRhIGRhdGEtdnVlLW1ldGE9InNzciIgbmFtZT0idHdpdHRlcjpzaXRlIiBjb250ZW50PSJAaGFicl9jb20iPjxtZXRhIGRhdGEtdnVlLW1ldGE9InNzciIgcHJvcGVydHk9Im9nOmxvY2FsZSIgY29udGVudD0icnVfUlUiIGRhdGEtdm1pZD0ib2c6bG9jYWxlIj48bWV0YSBkYXRhLXZ1ZS1tZXRhPSJzc3IiIHByb3BlcnR5PSJvZzp0eXBlIiBjb250ZW50PSJ3ZWJzaXRlIiBkYXRhLXZtaWQ9Im9nOnR5cGUiPjxtZXRhIGRhdGEtdnVlLW1ldGE9InNzciIgcHJvcGVydHk9Im9nOnNpdGVfbmFtZSIgY29udGVudD0i0KXQsNCx0YAiIGRhdGEtdm1pZD0ib2c6c2l0ZV9uYW1lIj48bWV0YSBkYXRhLXZ1ZS1tZXRhPSJzc3IiIHByb3BlcnR5PSJvZzp0aXRsZSIgY29udGVudD0i0KXQsNCx0YAiIGRhdGEtdm1pZD0ib2c6dGl0bGUiPjxtZXRhIGRhdGEtdnVlLW1ldGE9InNzciIgcHJvcGVydHk9Im9nOnVybCIgY29udGVudD0iaHR0cHM6Ly9oYWJyLmNvbS9ydS9wb3N0Lzk5NDY2L251bGwvIiBkYXRhLXZtaWQ9Im9nOnVybCI+CiAgPGxpbmsgZGF0YS12dWUtbWV0YT0ic3NyIiByZWw9ImltYWdlX3NyYyIgaHJlZj0iL2ltZy9oYWJyX3J1LnBuZyIgZGF0YS12bWlkPSJpbWFnZTpocmVmIj48bGluayBkYXRhLXZ1ZS1tZXRhPSJzc3IiIGhyZWY9Imh0dHBzOi8vaGFici5jb20vcnUvcG9zdC85OTQ2Ni9udWxsLyIgcmVsPSJjYW5vbmljYWwiIGRhdGEtdm1pZD0iY2Fub25pY2FsIj4KICA8bWV0YSBuYW1lPSJhcHBsZS1tb2JpbGUtd2ViLWFwcC1zdGF0dXMtYmFyLXN0eWxlIiBjb250ZW50PSIjMzAzYjQ0Ij4KICA8bWV0YSBuYW1lPSJtc2FwcGxpY2F0aW9uLVRpbGVDb2xvciIgY29udGVudD0iIzYyOUZCQyI+CiAgPG1ldGEgbmFtZT0iYXBwbGUtbW9iaWxlLXdlYi1hcHAtY2FwYWJsZSIgY29udGVudD0ieWVzIj4KICA8bWV0YSBuYW1lPSJtb2JpbGUtd2ViLWFwcC1jYXBhYmxlIiBjb250ZW50PSJ5ZXMiPgogIDxsaW5rCiAgICByZWw9InNob3J0Y3V0IGljb24iCiAgICB0eXBlPSJpbWFnZS9wbmciCiAgICBzaXplcz0iMTZ4MTYiCiAgICBocmVmPSJodHRwczovL2Fzc2V0cy5oYWJyLmNvbS9oYWJyLXdlYi9pbWcvZmF2aWNvbnMvZmF2aWNvbi0xNi5wbmciCiAgPgogIDxsaW5rCiAgICByZWw9InNob3J0Y3V0IGljb24iCiAgICB0eXBlPSJpbWFnZS9wbmciCiAgICBzaXplcz0iMzJ4MzIiCiAgICBocmVmPSJodHRwczovL2Fzc2V0cy5oYWJyLmNvbS9oYWJyLXdlYi9pbWcvZmF2aWNvbnMvZmF2aWNvbi0zMi5wbmciCiAgPgogIDxsaW5rCiAgICByZWw9ImFwcGxlLXRvdWNoLWljb24iCiAgICB0eXBlPSJpbWFnZS9wbmciCiAgICBzaXplcz0iNzZ4NzYiCiAgICBocmVmPSJodHRwczovL2Fzc2V0cy5oYWJyLmNvbS9oYWJyLXdlYi9pbWcvZmF2aWNvbnMvYXBwbGUtdG91Y2gtaWNvbi03Ni5wbmciCiAgPgogIDxsaW5rCiAgICByZWw9ImFwcGxlLXRvdWNoLWljb24iCiAgICB0eXBlPSJpbWFnZS9wbmciCiAgICBzaXplcz0iMTIweDEyMCIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9mYXZpY29ucy9hcHBsZS10b3VjaC1pY29uLTEyMC5wbmciCiAgPgogIDxsaW5rCiAgICByZWw9ImFwcGxlLXRvdWNoLWljb24iCiAgICB0eXBlPSJpbWFnZS9wbmciCiAgICBzaXplcz0iMTUyeDE1MiIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9mYXZpY29ucy9hcHBsZS10b3VjaC1pY29uLTE1Mi5wbmciCiAgPgogIDxsaW5rCiAgICByZWw9ImFwcGxlLXRvdWNoLWljb24iCiAgICB0eXBlPSJpbWFnZS9wbmciCiAgICBzaXplcz0iMTgweDE4MCIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9mYXZpY29ucy9hcHBsZS10b3VjaC1pY29uLTE4MC5wbmciCiAgPgogIDxsaW5rCiAgICByZWw9ImFwcGxlLXRvdWNoLWljb24iCiAgICB0eXBlPSJpbWFnZS9wbmciCiAgICBzaXplcz0iMjU2eDI1NiIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9mYXZpY29ucy9hcHBsZS10b3VjaC1pY29uLTI1Ni5wbmciCiAgPgogIDxsaW5rCiAgICByZWw9ImFwcGxlLXRvdWNoLXN0YXJ0dXAtaW1hZ2UiCiAgICBtZWRpYT0ic2NyZWVuIGFuZCAoZGV2aWNlLXdpZHRoOiAzMjBweCkgYW5kIChkZXZpY2UtaGVpZ2h0OiA1NjhweCkgYW5kICgtd2Via2l0LWRldmljZS1waXhlbC1yYXRpbzogMikgYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKSIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9zcGxhc2hlcy9zcGxhc2hfMTEzNng2NDAucG5nIgogID4KICA8bGluawogICAgcmVsPSJhcHBsZS10b3VjaC1zdGFydHVwLWltYWdlIgogICAgbWVkaWE9InNjcmVlbiBhbmQgKGRldmljZS13aWR0aDogMzc1cHgpIGFuZCAoZGV2aWNlLWhlaWdodDogODEycHgpIGFuZCAoLXdlYmtpdC1kZXZpY2UtcGl4ZWwtcmF0aW86IDMpIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSkiCiAgICBocmVmPSJodHRwczovL2Fzc2V0cy5oYWJyLmNvbS9oYWJyLXdlYi9pbWcvc3BsYXNoZXMvc3BsYXNoXzI0MzZ4MTEyNS5wbmciCiAgPgogIDxsaW5rCiAgICByZWw9ImFwcGxlLXRvdWNoLXN0YXJ0dXAtaW1hZ2UiCiAgICBtZWRpYT0ic2NyZWVuIGFuZCAoZGV2aWNlLXdpZHRoOiA0MTRweCkgYW5kIChkZXZpY2UtaGVpZ2h0OiA4OTZweCkgYW5kICgtd2Via2l0LWRldmljZS1waXhlbC1yYXRpbzogMikgYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKSIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9zcGxhc2hlcy9zcGxhc2hfMTc5Mng4MjgucG5nIgogID4KICA8bGluawogICAgcmVsPSJhcHBsZS10b3VjaC1zdGFydHVwLWltYWdlIgogICAgbWVkaWE9InNjcmVlbiBhbmQgKGRldmljZS13aWR0aDogNDE0cHgpIGFuZCAoZGV2aWNlLWhlaWdodDogODk2cHgpIGFuZCAoLXdlYmtpdC1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KSIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9zcGxhc2hlcy9zcGxhc2hfODI4eDE3OTIucG5nIgogID4KICA8bGluawogICAgcmVsPSJhcHBsZS10b3VjaC1zdGFydHVwLWltYWdlIgogICAgbWVkaWE9InNjcmVlbiBhbmQgKGRldmljZS13aWR0aDogMzc1cHgpIGFuZCAoZGV2aWNlLWhlaWdodDogNjY3cHgpIGFuZCAoLXdlYmtpdC1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSkiCiAgICBocmVmPSJodHRwczovL2Fzc2V0cy5oYWJyLmNvbS9oYWJyLXdlYi9pbWcvc3BsYXNoZXMvc3BsYXNoXzEzMzR4NzUwLnBuZyIKICA+CiAgPGxpbmsKICAgIHJlbD0iYXBwbGUtdG91Y2gtc3RhcnR1cC1pbWFnZSIKICAgIG1lZGlhPSJzY3JlZW4gYW5kIChkZXZpY2Utd2lkdGg6IDQxNHB4KSBhbmQgKGRldmljZS1oZWlnaHQ6IDg5NnB4KSBhbmQgKC13ZWJraXQtZGV2aWNlLXBpeGVsLXJhdGlvOiAzKSBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCkiCiAgICBocmVmPSJodHRwczovL2Fzc2V0cy5oYWJyLmNvbS9oYWJyLXdlYi9pbWcvc3BsYXNoZXMvc3BsYXNoXzEyNDJ4MjY2OC5wbmciCiAgPgogIDxsaW5rCiAgICByZWw9ImFwcGxlLXRvdWNoLXN0YXJ0dXAtaW1hZ2UiCiAgICBtZWRpYT0ic2NyZWVuIGFuZCAoZGV2aWNlLXdpZHRoOiA0MTRweCkgYW5kIChkZXZpY2UtaGVpZ2h0OiA3MzZweCkgYW5kICgtd2Via2l0LWRldmljZS1waXhlbC1yYXRpbzogMykgYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKSIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9zcGxhc2hlcy9zcGxhc2hfMjIwOHgxMjQyLnBuZyIKICA+CiAgPGxpbmsKICAgIHJlbD0iYXBwbGUtdG91Y2gtc3RhcnR1cC1pbWFnZSIKICAgIG1lZGlhPSJzY3JlZW4gYW5kIChkZXZpY2Utd2lkdGg6IDM3NXB4KSBhbmQgKGRldmljZS1oZWlnaHQ6IDgxMnB4KSBhbmQgKC13ZWJraXQtZGV2aWNlLXBpeGVsLXJhdGlvOiAzKSBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCkiCiAgICBocmVmPSJodHRwczovL2Fzc2V0cy5oYWJyLmNvbS9oYWJyLXdlYi9pbWcvc3BsYXNoZXMvc3BsYXNoXzExMjV4MjQzNi5wbmciCiAgPgogIDxsaW5rCiAgICByZWw9ImFwcGxlLXRvdWNoLXN0YXJ0dXAtaW1hZ2UiCiAgICBtZWRpYT0ic2NyZWVuIGFuZCAoZGV2aWNlLXdpZHRoOiA0MTRweCkgYW5kIChkZXZpY2UtaGVpZ2h0OiA3MzZweCkgYW5kICgtd2Via2l0LWRldmljZS1waXhlbC1yYXRpbzogMykgYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpIgogICAgaHJlZj0iaHR0cHM6Ly9hc3NldHMuaGFici5jb20vaGFici13ZWIvaW1nL3NwbGFzaGVzL3NwbGFzaF8xMjQyeDIyMDgucG5nIgogID4KICA8bGluawogICAgcmVsPSJhcHBsZS10b3VjaC1zdGFydHVwLWltYWdlIgogICAgbWVkaWE9InNjcmVlbiBhbmQgKGRldmljZS13aWR0aDogMTAyNHB4KSBhbmQgKGRldmljZS1oZWlnaHQ6IDEzNjZweCkgYW5kICgtd2Via2l0LWRldmljZS1waXhlbC1yYXRpbzogMikgYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKSIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9zcGxhc2hlcy9zcGxhc2hfMjczMngyMDQ4LnBuZyIKICA+CiAgPGxpbmsKICAgIHJlbD0iYXBwbGUtdG91Y2gtc3RhcnR1cC1pbWFnZSIKICAgIG1lZGlhPSJzY3JlZW4gYW5kIChkZXZpY2Utd2lkdGg6IDQxNHB4KSBhbmQgKGRldmljZS1oZWlnaHQ6IDg5NnB4KSBhbmQgKC13ZWJraXQtZGV2aWNlLXBpeGVsLXJhdGlvOiAzKSBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpIgogICAgaHJlZj0iaHR0cHM6Ly9hc3NldHMuaGFici5jb20vaGFici13ZWIvaW1nL3NwbGFzaGVzL3NwbGFzaF8yNjg4eDEyNDIucG5nIgogID4KICA8bGluawogICAgcmVsPSJhcHBsZS10b3VjaC1zdGFydHVwLWltYWdlIgogICAgbWVkaWE9InNjcmVlbiBhbmQgKGRldmljZS13aWR0aDogODM0cHgpIGFuZCAoZGV2aWNlLWhlaWdodDogMTExMnB4KSBhbmQgKC13ZWJraXQtZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpIgogICAgaHJlZj0iaHR0cHM6Ly9hc3NldHMuaGFici5jb20vaGFici13ZWIvaW1nL3NwbGFzaGVzL3NwbGFzaF8yMjI0eDE2NjgucG5nIgogID4KICA8bGluawogICAgcmVsPSJhcHBsZS10b3VjaC1zdGFydHVwLWltYWdlIgogICAgbWVkaWE9InNjcmVlbiBhbmQgKGRldmljZS13aWR0aDogMzc1cHgpIGFuZCAoZGV2aWNlLWhlaWdodDogNjY3cHgpIGFuZCAoLXdlYmtpdC1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KSIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9zcGxhc2hlcy9zcGxhc2hfNzUweDEzMzQucG5nIgogID4KICA8bGluawogICAgcmVsPSJhcHBsZS10b3VjaC1zdGFydHVwLWltYWdlIgogICAgbWVkaWE9InNjcmVlbiBhbmQgKGRldmljZS13aWR0aDogMTAyNHB4KSBhbmQgKGRldmljZS1oZWlnaHQ6IDEzNjZweCkgYW5kICgtd2Via2l0LWRldmljZS1waXhlbC1yYXRpbzogMikgYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpIgogICAgaHJlZj0iaHR0cHM6Ly9hc3NldHMuaGFici5jb20vaGFici13ZWIvaW1nL3NwbGFzaGVzL3NwbGFzaF8yMDQ4eDI3MzIucG5nIgogID4KICA8bGluawogICAgcmVsPSJhcHBsZS10b3VjaC1zdGFydHVwLWltYWdlIgogICAgbWVkaWE9InNjcmVlbiBhbmQgKGRldmljZS13aWR0aDogODM0cHgpIGFuZCAoZGV2aWNlLWhlaWdodDogMTE5NHB4KSBhbmQgKC13ZWJraXQtZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpIgogICAgaHJlZj0iaHR0cHM6Ly9hc3NldHMuaGFici5jb20vaGFici13ZWIvaW1nL3NwbGFzaGVzL3NwbGFzaF8yMzg4eDE2NjgucG5nIgogID4KICA8bGluawogICAgcmVsPSJhcHBsZS10b3VjaC1zdGFydHVwLWltYWdlIgogICAgbWVkaWE9InNjcmVlbiBhbmQgKGRldmljZS13aWR0aDogODM0cHgpIGFuZCAoZGV2aWNlLWhlaWdodDogMTExMnB4KSBhbmQgKC13ZWJraXQtZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCkiCiAgICBocmVmPSJodHRwczovL2Fzc2V0cy5oYWJyLmNvbS9oYWJyLXdlYi9pbWcvc3BsYXNoZXMvc3BsYXNoXzE2Njh4MjIyNC5wbmciCiAgPgogIDxsaW5rCiAgICByZWw9ImFwcGxlLXRvdWNoLXN0YXJ0dXAtaW1hZ2UiCiAgICBtZWRpYT0ic2NyZWVuIGFuZCAoZGV2aWNlLXdpZHRoOiAzMjBweCkgYW5kIChkZXZpY2UtaGVpZ2h0OiA1NjhweCkgYW5kICgtd2Via2l0LWRldmljZS1waXhlbC1yYXRpbzogMikgYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpIgogICAgaHJlZj0iaHR0cHM6Ly9hc3NldHMuaGFici5jb20vaGFici13ZWIvaW1nL3NwbGFzaGVzL3NwbGFzaF82NDB4MTEzNi5wbmciCiAgPgogIDxsaW5rCiAgICByZWw9ImFwcGxlLXRvdWNoLXN0YXJ0dXAtaW1hZ2UiCiAgICBtZWRpYT0ic2NyZWVuIGFuZCAoZGV2aWNlLXdpZHRoOiA4MzRweCkgYW5kIChkZXZpY2UtaGVpZ2h0OiAxMTk0cHgpIGFuZCAoLXdlYmtpdC1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KSIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9zcGxhc2hlcy9zcGxhc2hfMTY2OHgyMzg4LnBuZyIKICA+CiAgPGxpbmsKICAgIHJlbD0iYXBwbGUtdG91Y2gtc3RhcnR1cC1pbWFnZSIKICAgIG1lZGlhPSJzY3JlZW4gYW5kIChkZXZpY2Utd2lkdGg6IDc2OHB4KSBhbmQgKGRldmljZS1oZWlnaHQ6IDEwMjRweCkgYW5kICgtd2Via2l0LWRldmljZS1waXhlbC1yYXRpbzogMikgYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKSIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9zcGxhc2hlcy9zcGxhc2hfMjA0OHgxNTM2LnBuZyIKICA+CiAgPGxpbmsKICAgIHJlbD0iYXBwbGUtdG91Y2gtc3RhcnR1cC1pbWFnZSIKICAgIG1lZGlhPSJzY3JlZW4gYW5kIChkZXZpY2Utd2lkdGg6IDc2OHB4KSBhbmQgKGRldmljZS1oZWlnaHQ6IDEwMjRweCkgYW5kICgtd2Via2l0LWRldmljZS1waXhlbC1yYXRpbzogMikgYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpIgogICAgaHJlZj0iaHR0cHM6Ly9hc3NldHMuaGFici5jb20vaGFici13ZWIvaW1nL3NwbGFzaGVzL3NwbGFzaF8xNTM2eDIwNDgucG5nIgogID4KICA8bGluawogICAgcmVsPSJtYXNrLWljb24iCiAgICBjb2xvcj0iIzc3YTJiNiIKICAgIGhyZWY9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2ltZy9mYXZpY29ucy9hcHBsZS10b3VjaC1pY29uLTEyMC5zdmciCiAgPgogIDxsaW5rCiAgICBjcm9zc29yaWdpbj0idXNlLWNyZWRlbnRpYWxzIgogICAgaHJlZj0iL21hbmlmZXN0LndlYm1hbmlmZXN0IgogICAgcmVsPSJtYW5pZmVzdCIKICA+CiAgPHNjcmlwdCBhc3luYyBzcmM9Imh0dHBzOi8vdW5wa2cuY29tL3B3YWNvbXBhdCIgY3Jvc3NvcmlnaW49ImFub255bW91cyI+PC9zY3JpcHQ+CiAgPHNjcmlwdD53aW5kb3cueWFDb250ZXh0Q2IgPSB3aW5kb3cueWFDb250ZXh0Q2IgfHwgW108L3NjcmlwdD4KICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly95YW5kZXgucnUvYWRzL3N5c3RlbS9jb250ZXh0LmpzIiBhc3luYz48L3NjcmlwdD4KPC9oZWFkPgo8Ym9keT4KCgo8ZGl2IGlkPSJhcHAiIGRhdGEtc2VydmVyLXJlbmRlcmVkPSJ0cnVlIiBkYXRhLWFzeW5jLWNhbGxlZD0idHJ1ZSI+PGRpdiBjbGFzcz0idG0tbGF5b3V0X193cmFwcGVyIj48IS0tLS0+IDxkaXY+PC9kaXY+IDwhLS0tLT4gPGhlYWRlciBjbGFzcz0idG0taGVhZGVyIj48ZGl2IGNsYXNzPSJ0bS1wYWdlLXdpZHRoIj48ZGl2IGNsYXNzPSJ0bS1oZWFkZXJfX2NvbnRhaW5lciI+PCEtLS0tPiA8c3BhbiBjbGFzcz0idG0taGVhZGVyX19sb2dvLXdyYXAiPjxhIGhyZWY9Ii9ydS8iIGNsYXNzPSJ0bS1oZWFkZXJfX2xvZ28gdG0taGVhZGVyX19sb2dvX3J1Ij48c3ZnIGhlaWdodD0iMTYiIHdpZHRoPSIxNiIgY2xhc3M9InRtLXN2Zy1pbWcgdG0taGVhZGVyX19pY29uIj48dGl0bGU+0KXQsNCx0YA8L3RpdGxlPiA8dXNlIHhsaW5rOmhyZWY9Ii9pbWcvaGFici1sb2dvLXJ1LnN2ZyNsb2dvIj48L3VzZT48L3N2Zz48L2E+IDxzcGFuIGNsYXNzPSJ0bS1oZWFkZXJfX2JldGEtc2lnbiIgc3R5bGU9ImRpc3BsYXk6bm9uZTsiPs6yPC9zcGFuPjwvc3Bhbj4gPGRpdiBjbGFzcz0idG0tZHJvcGRvd24gdG0taGVhZGVyX19wcm9qZWN0cyI+PGRpdiBjbGFzcz0idG0tZHJvcGRvd25fX2hlYWQiPjxidXR0b24gY2xhc3M9InRtLWhlYWRlcl9fZHJvcGRvd24tdG9nZ2xlIj48c3ZnIGhlaWdodD0iMTYiIHdpZHRoPSIxNiIgY2xhc3M9InRtLXN2Zy1pbWcgdG0taGVhZGVyX19pY29uIHRtLWhlYWRlcl9faWNvbl9kcm9wZG93biI+PHRpdGxlPtCe0YLQutGA0YvRgtGMINGB0L/QuNGB0L7QujwvdGl0bGU+IDx1c2UgeGxpbms6aHJlZj0iL2ltZy9tZWdhem9yZC12MjguNjE3ZTE2Y2EuLnN2ZyNhcnJvdy1kb3duIj48L3VzZT48L3N2Zz48L2J1dHRvbj48L2Rpdj4gPCEtLS0tPjwvZGl2PiA8YSBocmVmPSIvcnUvc2FuZGJveC9zdGFydC8iIGNsYXNzPSJ0bS1oZWFkZXJfX2JlY29tZS1hdXRob3ItYnRuIj4KICAgICAgICAgICAg0JrQsNC6INGB0YLQsNGC0Ywg0LDQstGC0L7RgNC+0LwKICAgICAgICAgIDwvYT4gPGRpdiBjbGFzcz0idG0tZmVhdHVyZSB0bS1oZWFkZXJfX2ZlYXR1cmUgdG0tZmVhdHVyZSB0bS1mZWF0dXJlX3ZhcmlhbnQtaW5saW5lIj48IS0tLS0+PC9kaXY+IDwhLS0tLT4gPCEtLS0tPjwvZGl2PjwvZGl2PjwvaGVhZGVyPiA8ZGl2IGNsYXNzPSJ0bS1sYXlvdXQiPjxkaXYgY2xhc3M9InRtLXBhZ2UtcHJvZ3Jlc3MtYmFyIj48L2Rpdj4gPGRpdiBkYXRhLW1lbnUtc3RpY2t5PSJ0cnVlIiBjbGFzcz0idG0tYmFzZS1sYXlvdXRfX2hlYWRlciB0bS1iYXNlLWxheW91dF9faGVhZGVyX2lzLXN0aWNreSI+PGRpdiBjbGFzcz0idG0tcGFnZS13aWR0aCI+PGRpdiBjbGFzcz0idG0tYmFzZS1sYXlvdXRfX2hlYWRlci13cmFwcGVyIj48ZGl2IGNsYXNzPSJ0bS1tYWluLW1lbnUiPjxkaXYgY2xhc3M9InRtLW1haW4tbWVudV9fc2VjdGlvbiI+PG5hdiBjbGFzcz0idG0tbWFpbi1tZW51X19zZWN0aW9uLWNvbnRlbnQiPjxhIGhyZWY9Ii9ydS9mZWVkLyIgY2xhc3M9InRtLW1haW4tbWVudV9faXRlbSB0bS1tYWluLW1lbnVfX2l0ZW1faGFzLW5ldyI+CiAgICAgICAg0JzQvtGPINC70LXQvdGC0LAKICAgICAgPC9hPiA8YSBocmVmPSIvcnUvZmxvd3MvYWxsLyIgY2xhc3M9InRtLW1haW4tbWVudV9faXRlbSI+CiAgICAgICAg0JLRgdC1INC/0L7RgtC+0LrQuAogICAgICA8L2E+IDxhIGhyZWY9Ii9ydS9mbG93cy9kZXZlbG9wLyIgY2xhc3M9InRtLW1haW4tbWVudV9faXRlbSI+CiAgICAgICAgICDQoNCw0LfRgNCw0LHQvtGC0LrQsAogICAgICAgIDwvYT48YSBocmVmPSIvcnUvZmxvd3MvYWRtaW4vIiBjbGFzcz0idG0tbWFpbi1tZW51X19pdGVtIj4KICAgICAgICAgINCQ0LTQvNC40L3QuNGB0YLRgNC40YDQvtCy0LDQvdC40LUKICAgICAgICA8L2E+PGEgaHJlZj0iL3J1L2Zsb3dzL2Rlc2lnbi8iIGNsYXNzPSJ0bS1tYWluLW1lbnVfX2l0ZW0iPgogICAgICAgICAg0JTQuNC30LDQudC9CiAgICAgICAgPC9hPjxhIGhyZWY9Ii9ydS9mbG93cy9tYW5hZ2VtZW50LyIgY2xhc3M9InRtLW1haW4tbWVudV9faXRlbSI+CiAgICAgICAgICDQnNC10L3QtdC00LbQvNC10L3RggogICAgICAgIDwvYT48YSBocmVmPSIvcnUvZmxvd3MvbWFya2V0aW5nLyIgY2xhc3M9InRtLW1haW4tbWVudV9faXRlbSI+CiAgICAgICAgICDQnNCw0YDQutC10YLQuNC90LMKICAgICAgICA8L2E+PGEgaHJlZj0iL3J1L2Zsb3dzL3BvcHNjaS8iIGNsYXNzPSJ0bS1tYWluLW1lbnVfX2l0ZW0iPgogICAgICAgICAg0J3QsNGD0YfQv9C+0L8KICAgICAgICA8L2E+PC9uYXY+PC9kaXY+PC9kaXY+IDxkaXYgY2xhc3M9InRtLWhlYWRlci11c2VyLW1lbnUgdG0tYmFzZS1sYXlvdXRfX3VzZXItbWVudSI+PGEgaHJlZj0iL3J1L3NlYXJjaC8iIGNsYXNzPSJ0bS1oZWFkZXItdXNlci1tZW51X19pdGVtIHRtLWhlYWRlci11c2VyLW1lbnVfX3NlYXJjaCI+PHN2ZyBoZWlnaHQ9IjI0IiB3aWR0aD0iMjQiIGNsYXNzPSJ0bS1zdmctaW1nIHRtLWhlYWRlci11c2VyLW1lbnVfX2ljb24gdG0taGVhZGVyLXVzZXItbWVudV9faWNvbl9zZWFyY2ggdG0taGVhZGVyLXVzZXItbWVudV9faWNvbl9kYXJrIj48dGl0bGU+0J/QvtC40YHQujwvdGl0bGU+IDx1c2UgeGxpbms6aHJlZj0iL2ltZy9tZWdhem9yZC12MjguNjE3ZTE2Y2EuLnN2ZyNzZWFyY2giPjwvdXNlPjwvc3ZnPjwvYT4gPCEtLS0tPiA8IS0tLS0+IDxkaXYgY2xhc3M9InRtLWhlYWRlci11c2VyLW1lbnVfX2l0ZW0gdG0taGVhZGVyLXVzZXItbWVudV9fd3JpdGUiPjxhIGhyZWY9Ii9ydS9wdWJsaWNhdGlvbi9uZXcvIj48c3ZnIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgY2xhc3M9InRtLXN2Zy1pbWcgdG0taGVhZGVyLXVzZXItbWVudV9faWNvbiB0bS1oZWFkZXItdXNlci1tZW51X19pY29uX3dyaXRlIHRtLWhlYWRlci11c2VyLW1lbnVfX2ljb25fZGFyayI+PHRpdGxlPtCd0LDQv9C40YHQsNGC0Ywg0L/Rg9Cx0LvQuNC60LDRhtC40Y48L3RpdGxlPiA8dXNlIHhsaW5rOmhyZWY9Ii9pbWcvbWVnYXpvcmQtdjI4LjYxN2UxNmNhLi5zdmcjd3JpdGUiPjwvdXNlPjwvc3ZnPjwvYT4gPCEtLS0tPjwvZGl2PiA8ZGl2IGNsYXNzPSJ0bS1oZWFkZXItdXNlci1tZW51X19pdGVtIHRtLWhlYWRlci11c2VyLW1lbnVfX3VzZXJfZGVza3RvcCI+PGRpdiBjbGFzcz0idG0tZHJvcGRvd24iPjxkaXYgY2xhc3M9InRtLWRyb3Bkb3duX19oZWFkIj48ZGl2IGRhdGEtdGVzdC1pZD0ibWVudS10b2dnbGUtdXNlciIgY2xhc3M9InRtLWVudGl0eS1pbWFnZSI+PGltZyBhbHQ9IiIgaGVpZ2h0PSIzMiIgc3JjPSIvL2hhYnJhc3RvcmFnZS5vcmcvZ2V0cHJvL2hhYnIvYXZhdGFycy83NmIvMjYxLzI0ZC83NmIyNjEyNGQxOTA3NGEyYWNjZDZmMWQyM2FhODVmOS5wbmciIHdpZHRoPSIzMiIgY2xhc3M9InRtLWVudGl0eS1pbWFnZV9fcGljIj48L2Rpdj4gPCEtLS0tPjwvZGl2PiA8IS0tLS0+PC9kaXY+IDwhLS0tLT48L2Rpdj4gPCEtLS0tPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PiA8IS0tLS0+IDxkaXYgY2xhc3M9InRtLXBhZ2Utd2lkdGgiPjwvZGl2PiA8bWFpbiBjbGFzcz0idG0tbGF5b3V0X19jb250YWluZXIiPjxkaXYgY2xhc3M9InRtLXBhZ2UgdG0tcGFnZV9fZXJyb3IiPjxkaXYgY2xhc3M9InRtLXBhZ2Utd2lkdGgiPjwhLS0tLT4gPGRpdiBjbGFzcz0idG0tcGFnZV9fd3JhcHBlciI+PGRpdiBjbGFzcz0idG0tcGFnZV9fbWFpbiI+PGRpdiBjbGFzcz0icHVsbC1kb3duIj48IS0tLS0+IDxkaXYgY2xhc3M9InB1bGwtZG93bl9faGVhZGVyIiBzdHlsZT0iaGVpZ2h0OjBweDsiPjxkaXYgY2xhc3M9InB1bGwtZG93bl9fY29udGVudCIgc3R5bGU9ImJvdHRvbToxMHB4OyI+PHN2ZyBoZWlnaHQ9IjI0IiB3aWR0aD0iMjQiIGNsYXNzPSJ0bS1zdmctaW1nIHB1bGwtZG93bl9fYXJyb3ciPjx0aXRsZT7QntCx0L3QvtCy0LjRgtGMPC90aXRsZT4gPHVzZSB4bGluazpocmVmPSIvaW1nL21lZ2F6b3JkLXYyOC42MTdlMTZjYS4uc3ZnI3B1bGwtYXJyb3ciPjwvdXNlPjwvc3ZnPjwvZGl2PjwvZGl2PiA8ZGl2IGNsYXNzPSJ0bS1lcnJvci1tZXNzYWdlIj48aDEgY2xhc3M9InRtLWVycm9yLW1lc3NhZ2VfX3RpdGxlIj4KICAgICAg0KHRgtGA0LDQvdC40YbQsCDQvdC1INC90LDQudC00LXQvdCwCiAgICA8L2gxPiA8ZGl2IGNsYXNzPSJ0bS1lcnJvci1tZXNzYWdlX19ib2R5Ij4KICAgICAg0KHRgtGA0LDQvdC40YbQsCDRg9GB0YLQsNGA0LXQu9CwLCDQsdGL0LvQsCDRg9C00LDQu9C10L3QsCDQuNC70Lgg0L3QtSDRgdGD0YnQtdGB0YLQstC+0LLQsNC70LAg0LLQvtCy0YHQtQogICAgPC9kaXY+IDxkaXY+PC9kaXY+PC9kaXY+PC9kaXY+PC9kaXY+IDwhLS0tLT48L2Rpdj48L2Rpdj48L2Rpdj48L21haW4+IDwhLS0tLT48L2Rpdj4gPGRpdiBjbGFzcz0idG0tZm9vdGVyLW1lbnUiPjxkaXYgY2xhc3M9InRtLXBhZ2Utd2lkdGgiPjxkaXYgY2xhc3M9InRtLWZvb3Rlci1tZW51X19jb250YWluZXIiPjxkaXYgY2xhc3M9InRtLWZvb3Rlci1tZW51X19ibG9jayI+PHAgY2xhc3M9InRtLWZvb3Rlci1tZW51X19ibG9jay10aXRsZSI+CiAgICAgICAgICDQktCw0Ygg0LDQutC60LDRg9C90YIKICAgICAgICA8L3A+IDxkaXYgY2xhc3M9InRtLWZvb3Rlci1tZW51X19ibG9jay1jb250ZW50Ij48dWwgY2xhc3M9InRtLWZvb3Rlci1tZW51X19saXN0Ij48bGkgY2xhc3M9InRtLWZvb3Rlci1tZW51X19saXN0LWl0ZW0iPjxhIGhyZWY9Ii9ydS91c2Vycy9NYXN0ZXJNZW50b3IvcG9zdHMvIiBjbGFzcz0iZm9vdGVyLW1lbnVfX2l0ZW0tbGluayI+CiAgICAgICAgICAgICAgICDQn9GA0L7RhNC40LvRjAogICAgICAgICAgICAgIDwvYT48L2xpPjxsaSBjbGFzcz0idG0tZm9vdGVyLW1lbnVfX2xpc3QtaXRlbSI+PGEgaHJlZj0iL3J1L3RyYWNrZXIvIiBjbGFzcz0iZm9vdGVyLW1lbnVfX2l0ZW0tbGluayI+CiAgICAgICAgICAgICAgICDQotGA0LXQutC10YAKICAgICAgICAgICAgICA8L2E+PC9saT48bGkgY2xhc3M9InRtLWZvb3Rlci1tZW51X19saXN0LWl0ZW0iPjxhIGhyZWY9Ii9ydS9jb252ZXJzYXRpb25zLyIgY2xhc3M9ImZvb3Rlci1tZW51X19pdGVtLWxpbmsiPgogICAgICAgICAgICAgICAg0JTQuNCw0LvQvtCz0LgKICAgICAgICAgICAgICA8L2E+PC9saT48bGkgY2xhc3M9InRtLWZvb3Rlci1tZW51X19saXN0LWl0ZW0iPjxhIGhyZWY9Ii9ydS9hdXRoL3NldHRpbmdzL3Byb2ZpbGUvIiBjbGFzcz0iZm9vdGVyLW1lbnVfX2l0ZW0tbGluayI+CiAgICAgICAgICAgICAgICDQndCw0YHRgtGA0L7QudC60LgKICAgICAgICAgICAgICA8L2E+PC9saT48bGkgY2xhc3M9InRtLWZvb3Rlci1tZW51X19saXN0LWl0ZW0iPjxhIGhyZWY9Ii9ydS9wcGEvIiBjbGFzcz0iZm9vdGVyLW1lbnVfX2l0ZW0tbGluayI+CiAgICAgICAgICAgICAgICDQn9Cf0JAKICAgICAgICAgICAgICA8L2E+PC9saT48L3VsPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9InRtLWZvb3Rlci1tZW51X19ibG9jayI+PHAgY2xhc3M9InRtLWZvb3Rlci1tZW51X19ibG9jay10aXRsZSI+CiAgICAgICAgICDQoNCw0LfQtNC10LvRiwogICAgICAgIDwvcD4gPGRpdiBjbGFzcz0idG0tZm9vdGVyLW1lbnVfX2Jsb2NrLWNvbnRlbnQiPjx1bCBjbGFzcz0idG0tZm9vdGVyLW1lbnVfX2xpc3QiPjxsaSBjbGFzcz0idG0tZm9vdGVyLW1lbnVfX2xpc3QtaXRlbSI+PGEgaHJlZj0iL3J1LyIgY2xhc3M9ImZvb3Rlci1tZW51X19pdGVtLWxpbmsgcm91dGVyLWxpbmstYWN0aXZlIj4KICAgICAgICAgICAgICAgINCf0YPQsdC70LjQutCw0YbQuNC4CiAgICAgICAgICAgICAgPC9hPjwvbGk+PGxpIGNsYXNzPSJ0bS1mb290ZXItbWVudV9fbGlzdC1pdGVtIj48YSBocmVmPSIvcnUvbmV3cy8iIGNsYXNzPSJmb290ZXItbWVudV9faXRlbS1saW5rIj4KICAgICAgICAgICAgICAgINCd0L7QstC+0YHRgtC4CiAgICAgICAgICAgICAgPC9hPjwvbGk+PGxpIGNsYXNzPSJ0bS1mb290ZXItbWVudV9fbGlzdC1pdGVtIj48YSBocmVmPSIvcnUvaHVicy8iIGNsYXNzPSJmb290ZXItbWVudV9faXRlbS1saW5rIj4KICAgICAgICAgICAgICAgINCl0LDQsdGLCiAgICAgICAgICAgICAgPC9hPjwvbGk+PGxpIGNsYXNzPSJ0bS1mb290ZXItbWVudV9fbGlzdC1pdGVtIj48YSBocmVmPSIvcnUvY29tcGFuaWVzLyIgY2xhc3M9ImZvb3Rlci1tZW51X19pdGVtLWxpbmsiPgogICAgICAgICAgICAgICAg0JrQvtC80L/QsNC90LjQuAogICAgICAgICAgICAgIDwvYT48L2xpPjxsaSBjbGFzcz0idG0tZm9vdGVyLW1lbnVfX2xpc3QtaXRlbSI+PGEgaHJlZj0iL3J1L3VzZXJzLyIgY2xhc3M9ImZvb3Rlci1tZW51X19pdGVtLWxpbmsiPgogICAgICAgICAgICAgICAg0JDQstGC0L7RgNGLCiAgICAgICAgICAgICAgPC9hPjwvbGk+PGxpIGNsYXNzPSJ0bS1mb290ZXItbWVudV9fbGlzdC1pdGVtIj48YSBocmVmPSIvcnUvc2FuZGJveC8iIGNsYXNzPSJmb290ZXItbWVudV9faXRlbS1saW5rIj4KICAgICAgICAgICAgICAgINCf0LXRgdC+0YfQvdC40YbQsAogICAgICAgICAgICAgIDwvYT48L2xpPjwvdWw+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0idG0tZm9vdGVyLW1lbnVfX2Jsb2NrIj48cCBjbGFzcz0idG0tZm9vdGVyLW1lbnVfX2Jsb2NrLXRpdGxlIj4KICAgICAgICAgINCY0L3RhNC+0YDQvNCw0YbQuNGPCiAgICAgICAgPC9wPiA8ZGl2IGNsYXNzPSJ0bS1mb290ZXItbWVudV9fYmxvY2stY29udGVudCI+PHVsIGNsYXNzPSJ0bS1mb290ZXItbWVudV9fbGlzdCI+PGxpIGNsYXNzPSJ0bS1mb290ZXItbWVudV9fbGlzdC1pdGVtIj48YSBocmVmPSIvcnUvZG9jcy9oZWxwLyIgY2xhc3M9ImZvb3Rlci1tZW51X19pdGVtLWxpbmsiPgogICAgICAgICAgICAgICAg0KPRgdGC0YDQvtC50YHRgtCy0L4g0YHQsNC50YLQsAogICAgICAgICAgICAgIDwvYT48L2xpPjxsaSBjbGFzcz0idG0tZm9vdGVyLW1lbnVfX2xpc3QtaXRlbSI+PGEgaHJlZj0iL3J1L2RvY3MvYXV0aG9ycy9jb2RleC8iIGNsYXNzPSJmb290ZXItbWVudV9faXRlbS1saW5rIj4KICAgICAgICAgICAgICAgINCU0LvRjyDQsNCy0YLQvtGA0L7QsgogICAgICAgICAgICAgIDwvYT48L2xpPjxsaSBjbGFzcz0idG0tZm9vdGVyLW1lbnVfX2xpc3QtaXRlbSI+PGEgaHJlZj0iL3J1L2RvY3MvY29tcGFuaWVzL2NvcnBibG9ncy8iIGNsYXNzPSJmb290ZXItbWVudV9faXRlbS1saW5rIj4KICAgICAgICAgICAgICAgINCU0LvRjyDQutC+0LzQv9Cw0L3QuNC5CiAgICAgICAgICAgICAgPC9hPjwvbGk+PGxpIGNsYXNzPSJ0bS1mb290ZXItbWVudV9fbGlzdC1pdGVtIj48YSBocmVmPSIvcnUvZG9jcy9kb2NzL3RyYW5zcGFyZW5jeS8iIGNsYXNzPSJmb290ZXItbWVudV9faXRlbS1saW5rIj4KICAgICAgICAgICAgICAgINCU0L7QutGD0LzQtdC90YLRiwogICAgICAgICAgICAgIDwvYT48L2xpPjxsaSBjbGFzcz0idG0tZm9vdGVyLW1lbnVfX2xpc3QtaXRlbSI+PGEgaHJlZj0iaHR0cHM6Ly9hY2NvdW50LmhhYnIuY29tL2luZm8vYWdyZWVtZW50IiB0YXJnZXQ9Il9ibGFuayI+CiAgICAgICAgICAgICAgICDQodC+0LPQu9Cw0YjQtdC90LjQtQogICAgICAgICAgICAgIDwvYT48L2xpPjxsaSBjbGFzcz0idG0tZm9vdGVyLW1lbnVfX2xpc3QtaXRlbSI+PGEgaHJlZj0iaHR0cHM6Ly9hY2NvdW50LmhhYnIuY29tL2luZm8vY29uZmlkZW50aWFsLyIgdGFyZ2V0PSJfYmxhbmsiPgogICAgICAgICAgICAgICAg0JrQvtC90YTQuNC00LXQvdGG0LjQsNC70YzQvdC+0YHRgtGMCiAgICAgICAgICAgICAgPC9hPjwvbGk+PC91bD48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSJ0bS1mb290ZXItbWVudV9fYmxvY2siPjxwIGNsYXNzPSJ0bS1mb290ZXItbWVudV9fYmxvY2stdGl0bGUiPgogICAgICAgICAg0KPRgdC70YPQs9C4CiAgICAgICAgPC9wPiA8ZGl2IGNsYXNzPSJ0bS1mb290ZXItbWVudV9fYmxvY2stY29udGVudCI+PHVsIGNsYXNzPSJ0bS1mb290ZXItbWVudV9fbGlzdCI+PGxpIGNsYXNzPSJ0bS1mb290ZXItbWVudV9fbGlzdC1pdGVtIj48YSBocmVmPSJodHRwczovL2NvbXBhbnkuaGFici5jb20vcnUvY29ycG9yYXRlLWJsb2dzLyIgdGFyZ2V0PSJfYmxhbmsiPgogICAgICAgICAgICAgICAg0JrQvtGA0L/QvtGA0LDRgtC40LLQvdGL0Lkg0LHQu9C+0LMKICAgICAgICAgICAgICA8L2E+PC9saT48bGkgY2xhc3M9InRtLWZvb3Rlci1tZW51X19saXN0LWl0ZW0iPjxhIGhyZWY9Imh0dHBzOi8vY29tcGFueS5oYWJyLmNvbS9ydS9hZHZlcnRpc2luZy8iIHRhcmdldD0iX2JsYW5rIj4KICAgICAgICAgICAgICAgINCc0LXQtNC40LnQvdCw0Y8g0YDQtdC60LvQsNC80LAKICAgICAgICAgICAgICA8L2E+PC9saT48bGkgY2xhc3M9InRtLWZvb3Rlci1tZW51X19saXN0LWl0ZW0iPjxhIGhyZWY9Imh0dHBzOi8vY29tcGFueS5oYWJyLmNvbS9ydS9uYXRpdmUtc3BlY2lhbC8iIHRhcmdldD0iX2JsYW5rIj4KICAgICAgICAgICAgICAgINCd0LDRgtC40LLQvdGL0LUg0L/RgNC+0LXQutGC0YsKICAgICAgICAgICAgICA8L2E+PC9saT48bGkgY2xhc3M9InRtLWZvb3Rlci1tZW51X19saXN0LWl0ZW0iPjxhIGhyZWY9Imh0dHBzOi8vY29tcGFueS5oYWJyLmNvbS9ydS9lZHVjYXRpb24tcHJvZ3JhbXMvIiB0YXJnZXQ9Il9ibGFuayI+CiAgICAgICAgICAgICAgICDQntCx0YDQsNC30L7QstCw0YLQtdC70YzQvdGL0LUg0L/RgNC+0LPRgNCw0LzQvNGLCiAgICAgICAgICAgICAgPC9hPjwvbGk+PGxpIGNsYXNzPSJ0bS1mb290ZXItbWVudV9fbGlzdC1pdGVtIj48YSBocmVmPSJodHRwczovL2NvbXBhbnkuaGFici5jb20vcnUvaGVsbG8tc3RhcnR1cC8iIHRhcmdldD0iX2JsYW5rIj4KICAgICAgICAgICAgICAgINCh0YLQsNGA0YLQsNC/0LDQvAogICAgICAgICAgICAgIDwvYT48L2xpPjxsaSBjbGFzcz0idG0tZm9vdGVyLW1lbnVfX2xpc3QtaXRlbSI+PGEgaHJlZj0iL3J1L21lZ2Fwcm9qZWN0cy8iIGNsYXNzPSJmb290ZXItbWVudV9faXRlbS1saW5rIj4KICAgICAgICAgICAgICAgINCc0LXQs9Cw0L/RgNC+0LXQutGC0YsKICAgICAgICAgICAgICA8L2E+PC9saT48L3VsPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PiA8ZGl2IGNsYXNzPSJ0bS1mb290ZXIiPjxkaXYgY2xhc3M9InRtLXBhZ2Utd2lkdGgiPjxkaXYgY2xhc3M9InRtLWZvb3Rlcl9fY29udGFpbmVyIj48IS0tLS0+IDxkaXYgY2xhc3M9InRtLWZvb3Rlcl9fc29jaWFsIj48YSBocmVmPSJodHRwczovL3d3dy5mYWNlYm9vay5jb20vaGFicmFoYWJyLnJ1IiByZWw9Im5vZm9sbG93IG5vb3BlbmVyIG5vcmVmZXJyZXIiIHRhcmdldD0iX2JsYW5rIiBjbGFzcz0idG0tc3ZnLWljb25fX3dyYXBwZXIgdG0tc29jaWFsLWljb25zX19pY29uIj48c3ZnIGhlaWdodD0iMTYiIHdpZHRoPSIxNiIgY2xhc3M9InRtLXN2Zy1pbWcgdG0tc3ZnLWljb24iPjx0aXRsZT5GYWNlYm9vazwvdGl0bGU+IDx1c2UgeGxpbms6aHJlZj0iL2ltZy9zb2NpYWwtaWNvbnMtc3ByaXRlLnN2ZyNzb2NpYWwtbG9nby1mYWNlYm9vayI+PC91c2U+PC9zdmc+PC9hPjxhIGhyZWY9Imh0dHBzOi8vdHdpdHRlci5jb20vaGFicl9jb20iIHJlbD0ibm9mb2xsb3cgbm9vcGVuZXIgbm9yZWZlcnJlciIgdGFyZ2V0PSJfYmxhbmsiIGNsYXNzPSJ0bS1zdmctaWNvbl9fd3JhcHBlciB0bS1zb2NpYWwtaWNvbnNfX2ljb24iPjxzdmcgaGVpZ2h0PSIxNiIgd2lkdGg9IjE2IiBjbGFzcz0idG0tc3ZnLWltZyB0bS1zdmctaWNvbiI+PHRpdGxlPlR3aXR0ZXI8L3RpdGxlPiA8dXNlIHhsaW5rOmhyZWY9Ii9pbWcvc29jaWFsLWljb25zLXNwcml0ZS5zdmcjc29jaWFsLWxvZ28tdHdpdHRlciI+PC91c2U+PC9zdmc+PC9hPjxhIGhyZWY9Imh0dHBzOi8vdmsuY29tL2hhYnIiIHJlbD0ibm9mb2xsb3cgbm9vcGVuZXIgbm9yZWZlcnJlciIgdGFyZ2V0PSJfYmxhbmsiIGNsYXNzPSJ0bS1zdmctaWNvbl9fd3JhcHBlciB0bS1zb2NpYWwtaWNvbnNfX2ljb24iPjxzdmcgaGVpZ2h0PSIxNiIgd2lkdGg9IjE2IiBjbGFzcz0idG0tc3ZnLWltZyB0bS1zdmctaWNvbiI+PHRpdGxlPlZLPC90aXRsZT4gPHVzZSB4bGluazpocmVmPSIvaW1nL3NvY2lhbC1pY29ucy1zcHJpdGUuc3ZnI3NvY2lhbC1sb2dvLXZrb250YWt0ZSI+PC91c2U+PC9zdmc+PC9hPjxhIGhyZWY9Imh0dHBzOi8vdGVsZWdyYW0ubWUvaGFicl9jb20iIHJlbD0ibm9mb2xsb3cgbm9vcGVuZXIgbm9yZWZlcnJlciIgdGFyZ2V0PSJfYmxhbmsiIGNsYXNzPSJ0bS1zdmctaWNvbl9fd3JhcHBlciB0bS1zb2NpYWwtaWNvbnNfX2ljb24iPjxzdmcgaGVpZ2h0PSIxNiIgd2lkdGg9IjE2IiBjbGFzcz0idG0tc3ZnLWltZyB0bS1zdmctaWNvbiI+PHRpdGxlPlRlbGVncmFtPC90aXRsZT4gPHVzZSB4bGluazpocmVmPSIvaW1nL3NvY2lhbC1pY29ucy1zcHJpdGUuc3ZnI3NvY2lhbC1sb2dvLXRlbGVncmFtIj48L3VzZT48L3N2Zz48L2E+PGEgaHJlZj0iaHR0cHM6Ly93d3cueW91dHViZS5jb20vY2hhbm5lbC9VQ2Rfc1R3S3FWcndlVHQ0b0FLWTV5NHciIHJlbD0ibm9mb2xsb3cgbm9vcGVuZXIgbm9yZWZlcnJlciIgdGFyZ2V0PSJfYmxhbmsiIGNsYXNzPSJ0bS1zdmctaWNvbl9fd3JhcHBlciB0bS1zb2NpYWwtaWNvbnNfX2ljb24iPjxzdmcgaGVpZ2h0PSIxNiIgd2lkdGg9IjE2IiBjbGFzcz0idG0tc3ZnLWltZyB0bS1zdmctaWNvbiI+PHRpdGxlPllvdXR1YmU8L3RpdGxlPiA8dXNlIHhsaW5rOmhyZWY9Ii9pbWcvc29jaWFsLWljb25zLXNwcml0ZS5zdmcjc29jaWFsLWxvZ28teW91dHViZSI+PC91c2U+PC9zdmc+PC9hPjxhIGhyZWY9Imh0dHBzOi8vemVuLnlhbmRleC5ydS9oYWJyIiByZWw9Im5vZm9sbG93IG5vb3BlbmVyIG5vcmVmZXJyZXIiIHRhcmdldD0iX2JsYW5rIiBjbGFzcz0idG0tc3ZnLWljb25fX3dyYXBwZXIgdG0tc29jaWFsLWljb25zX19pY29uIj48c3ZnIGhlaWdodD0iMTYiIHdpZHRoPSIxNiIgY2xhc3M9InRtLXN2Zy1pbWcgdG0tc3ZnLWljb24iPjx0aXRsZT7Qr9C90LTQtdC60YEg0JTQt9C10L08L3RpdGxlPiA8dXNlIHhsaW5rOmhyZWY9Ii9pbWcvc29jaWFsLWljb25zLXNwcml0ZS5zdmcjc29jaWFsLWxvZ28temVuIj48L3VzZT48L3N2Zz48L2E+PC9kaXY+IDxESVYgY2xhc3M9InYtcG9ydGFsIiBzdHlsZT0iZGlzcGxheTpub25lOyI+PC9ESVY+IDxidXR0b24gY2xhc3M9InRtLWZvb3Rlcl9fbGluayI+PCEtLS0tPgogICAgICAgINCd0LDRgdGC0YDQvtC50LrQsCDRj9C30YvQutCwCiAgICAgIDwvYnV0dG9uPiA8YSBocmVmPSIvcnUvZmVlZGJhY2svIiBjbGFzcz0idG0tZm9vdGVyX19saW5rIj4KICAgICAgICDQotC10YXQvdC40YfQtdGB0LrQsNGPINC/0L7QtNC00LXRgNC20LrQsAogICAgICA8L2E+IDxhIGhyZWY9Ii9iZXJzZXJrLW1vZGUtbm9wZSIgY2xhc3M9InRtLWZvb3Rlcl9fbGluayI+CiAgICAgICAg0JLQtdGA0L3Rg9GC0YzRgdGPINC90LAg0YHRgtCw0YDRg9GOINCy0LXRgNGB0LjRjgogICAgICA8L2E+IDxkaXYgY2xhc3M9InRtLWZvb3Rlci1jb3B5cmlnaHQiPjxzcGFuIGNsYXNzPSJ0bS1jb3B5cmlnaHQiPjxzcGFuIGNsYXNzPSJ0bS1jb3B5cmlnaHRfX3llYXJzIj7CqSAyMDA24oCTMjAyMywgPC9zcGFuPiA8c3BhbiBjbGFzcz0idG0tY29weXJpZ2h0X19uYW1lIj48YSBocmVmPSJodHRwczovL2NvbXBhbnkuaGFici5jb20vIiByZWw9Im5vb3BlbmVyIiB0YXJnZXQ9Il9ibGFuayIgY2xhc3M9InRtLWNvcHlyaWdodF9fbGluayI+SGFicjwvYT48L3NwYW4+PC9zcGFuPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PiA8IS0tLS0+IDwhLS0tLT48L2Rpdj4gPGRpdiBjbGFzcz0idnVlLXBvcnRhbC10YXJnZXQiPjwvZGl2PjwvZGl2Pgo8c2NyaXB0PndpbmRvdy5fX0lOSVRJQUxfU1RBVEVfXz17ImFkYmxvY2siOnsiaGFzQWNjZXB0YWJsZUFkc0ZpbHRlciI6ZmFsc2UsImhhc0FkYmxvY2siOmZhbHNlfSwiYXJ0aWNsZXNMaXN0Ijp7ImFydGljbGVzTGlzdCI6e30sImFydGljbGVzSWRzIjp7fSwiaXNMb2FkaW5nIjpmYWxzZSwicGFnZXNDb3VudCI6e30sInJvdXRlIjp7fSwicmVhc29uc0xpc3QiOm51bGwsInZpZXciOiJjYXJkcyIsImxhc3RWaXNpdGVkUm91dGUiOnt9LCJzc3JDb21tZW50c0FydGljbGVJZHMiOltdLCJrYXJtYSI6eyJ1c2VyUmVhc29uc0xpc3QiOm51bGx9fSwiYXV0aG9yQ29udHJpYnV0aW9uIjp7ImF1dGhvcnMiOnt9fSwiYmV0YVRlc3QiOnsiY3VycmVudEFubm91bmNlbWVudCI6bnVsbCwiYW5ub3VuY2VtZW50cyI6e30sImFubm91bmNlbWVudENhcmRzIjpudWxsLCJhbm5vdW5jZW1lbnRDb21tZW50cyI6e30sImFubm91bmNlbWVudENvbW1lbnRUaHJlYWRzIjp7fSwiYW5ub3VuY2VtZW50Q29tbWVudGluZ1N0YXR1c2VzIjp7fSwiYXJjaGl2ZWRMaXN0IjpbXX0sImF1dGhvclN0YXRpc3RpY3MiOnsiYXJ0aWNsZVJlZnMiOnt9LCJhcnRpY2xlSWRzIjp7fSwicGFnZXNDb3VudCI6e30sInJvdXRlIjp7fSwidmlld3NDb3VudCI6W10sIm1heFN0YXRzQ291bnQiOnt9fSwiY2FyZWVyIjp7InNlb0xhbmRpbmdzIjpbXSwiaHVicyI6IiJ9LCJjb21tZW50cyI6eyJhcnRpY2xlQ29tbWVudHMiOnt9LCJhcnRpY2xlUGlubmVkQ29tbWVudHMiOnt9LCJzZWFyY2hDb21tZW50c1Jlc3VsdHMiOm51bGwsInBhZ2VzQ291bnQiOm51bGwsImNvbW1lbnRBY2Nlc3MiOnt9LCJzY3JvbGxQYXJlbnRzIjp7fSwicGFnZUFydGljbGVDb21tZW50cyI6eyJsYXN0Vmlld2VkQ29tbWVudCI6MCwicG9zdElkIjpudWxsLCJsYXN0Q29tbWVudFRpbWVzdGFtcCI6IiIsIm1vZGVyYXRlZCI6W10sIm1vZGVyYXRlZElkcyI6W10sImNvbW1lbnRSb3V0ZSI6IiJ9fSwiY29tcGFuaWVzIjp7ImNvbXBhbnlSZWZzIjp7fSwiY29tcGFueUlkcyI6e30sImNvbXBhbnlUb3BJZHMiOnt9LCJwYWdlc0NvdW50Ijp7fSwiY29tcGFueVByb2ZpbGVzIjp7fSwiY29tcGFuaWVzQ2F0ZWdvcmllcyI6W10sImNvbXBhbmllc0NhdGVnb3JpZXNUb3RhbENvdW50IjowLCJjb21wYW5pZXNXaWRnZXRzIjp7fSwiY29tcGFuaWVzV29ya2VycyI6e30sImNvbXBhbmllc0ZhbnMiOnt9LCJyb3V0ZSI6e30sImlzTG9hZGluZyI6ZmFsc2UsImNvbXBhbnlXb3JrZXJzTG9hZGluZyI6ZmFsc2UsImNvbXBhbnlGYW5zTG9hZGluZyI6ZmFsc2UsInZhY2FuY2llcyI6e30sImNvbXBhbmllc0dhbGxlcmllcyI6e30sImNvbXBhbmllc0Jhbm5lcnMiOnt9LCJjb21wYW5pZXNMYW5kaW5nVmFjYW5jaWVzIjp7fSwiY29tcGFuaWVzVGVjaG5vbG9naWVzIjp7fSwid29ya3BsYWNlSW5mbyI6bnVsbH0sImNvbXBhbnlBZG1pbiI6eyJjb21wYW55SW5mbyI6bnVsbCwiY29tcGFueUluZm9Mb2FkaW5nIjpmYWxzZSwiZmFxQXJ0aWNsZXMiOm51bGwsImJyYW5kaW5nUHJldmlld0ltYWdlVXJsIjpudWxsLCJqaXZvU3RhdHVzIjowLCJhZG1pbk5vdGlmaWNhdGlvbnMiOm51bGx9LCJjb21wYW5pZXNDb250cmlidXRpb24iOnsiaHVicyI6e30sImZsb3dzIjp7fSwiY29tcGFueVJlZnMiOnt9fSwiY29tcGFueUh1YnNDb250cmlidXRpb24iOnsiY29udHJpYnV0aW9uUmVmcyI6eyJodWJSZWZzIjp7fSwiaHViSWRzIjp7fX19LCJjb252ZXJzYXRpb24iOnsibWVzc2FnZXMiOltdLCJyZXNwb25kZW50IjpudWxsLCJpc0xvYWRNb3JlIjpmYWxzZX0sImNvbnZlcnNhdGlvbnMiOnsiY29udmVyc2F0aW9ucyI6W10sInVucmVhZENvdW50IjowLCJwYWdlc0NvdW50IjowfSwiZGVza3RvcFN0YXRlIjp7ImRlc2t0b3BGbCI6bnVsbCwiZGVza3RvcEhsIjpudWxsLCJpc0NoZWNrZWQiOmZhbHNlLCJpc0xvZ2luRGVtYW5kZWQiOmZhbHNlfSwiZG9jcyI6eyJtZW51Ijp7fSwiYXJ0aWNsZXMiOnt9LCJtYWluTWVudSI6W10sImxvYWRpbmciOnsibWFpbiI6ZmFsc2UsImRyb3Bkb3duIjpmYWxzZSwiYXJ0aWNsZSI6ZmFsc2V9fSwiZmVhdHVyZSI6eyJpc1Byb2JhYmx5VmlzaWJsZSI6dHJ1ZX0sImZsb3dzIjp7InVwZGF0ZXMiOnsiY291bnROZXdQb3N0c0J5U3Vic2NyaXB0aW9uIjoyLCJjb3VudE5ld1Bvc3RzQWxsIjo3NiwiY291bnROZXdOZXdzQWxsIjo0N30sImZsb3dzIjpbeyJhbGlhcyI6ImRldmVsb3AiLCJpZCI6IjEiLCJyb3V0ZSI6eyJuYW1lIjoiRkxPV19QQUdFIiwicGFyYW1zIjp7ImZsb3dOYW1lIjoiZGV2ZWxvcCJ9fX0seyJhbGlhcyI6ImFkbWluIiwiaWQiOiI2Iiwicm91dGUiOnsibmFtZSI6IkZMT1dfUEFHRSIsInBhcmFtcyI6eyJmbG93TmFtZSI6ImFkbWluIn19fSx7ImFsaWFzIjoiZGVzaWduIiwiaWQiOiIyIiwicm91dGUiOnsibmFtZSI6IkZMT1dfUEFHRSIsInBhcmFtcyI6eyJmbG93TmFtZSI6ImRlc2lnbiJ9fX0seyJhbGlhcyI6Im1hbmFnZW1lbnQiLCJpZCI6IjMiLCJyb3V0ZSI6eyJuYW1lIjoiRkxPV19QQUdFIiwicGFyYW1zIjp7ImZsb3dOYW1lIjoibWFuYWdlbWVudCJ9fX0seyJhbGlhcyI6Im1hcmtldGluZyIsImlkIjoiNCIsInJvdXRlIjp7Im5hbWUiOiJGTE9XX1BBR0UiLCJwYXJhbXMiOnsiZmxvd05hbWUiOiJtYXJrZXRpbmcifX19LHsiYWxpYXMiOiJwb3BzY2kiLCJpZCI6IjciLCJyb3V0ZSI6eyJuYW1lIjoiRkxPV19QQUdFIiwicGFyYW1zIjp7ImZsb3dOYW1lIjoicG9wc2NpIn19fV19LCJnbG9iYWwiOnsiaXNQd2EiOmZhbHNlLCJkZXZpY2UiOiJkZXNrdG9wIiwiaXNIYWJyQ29tIjp0cnVlfSwiaHVicyI6eyJodWJSZWZzIjp7fSwiaHViSWRzIjp7fSwicGFnZXNDb3VudCI6e30sImlzTG9hZGluZyI6ZmFsc2UsInJvdXRlIjp7fX0sImh1YnNCbG9jayI6eyJodWJSZWZzIjp7fSwiaHViSWRzIjp7fX0sImkxOG4iOnsiZmwiOiJydSIsImhsIjoicnUifSwiaW5mbyI6eyJpbmZvUGFnZSI6e30sImlzTG9hZGluZyI6dHJ1ZX0sImxvY2F0aW9uIjp7InVybFN0cnVjdCI6eyJwcm90b2NvbCI6bnVsbCwic2xhc2hlcyI6bnVsbCwiYXV0aCI6bnVsbCwiaG9zdCI6bnVsbCwicG9ydCI6bnVsbCwiaG9zdG5hbWUiOm51bGwsImhhc2giOm51bGwsInNlYXJjaCI6bnVsbCwicXVlcnkiOnt9LCJwYXRobmFtZSI6bnVsbCwicGF0aCI6bnVsbCwiaHJlZiI6IiJ9fSwibWUiOnsidXNlciI6eyJpZCI6IjMyODIxNjUiLCJhbGlhcyI6Ik1hc3Rlck1lbnRvciIsImZ1bGxuYW1lIjpudWxsLCJhdmF0YXJVcmwiOiJcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRmF2YXRhcnNcdTAwMkY3NmJcdTAwMkYyNjFcdTAwMkYyNGRcdTAwMkY3NmIyNjEyNGQxOTA3NGEyYWNjZDZmMWQyM2FhODVmOS5wbmciLCJncm91cHMiOlsibm9ybWFsIl0sInNldHRpbmdzIjp7Im1pc2NTZXR0aW5ncyI6eyJ2aWV3Q29tbWVudHNSZWZyZXNoIjp0cnVlLCJlbmFibGVTaG9ydGN1dHMiOnRydWUsImhpZGVBZHYiOnRydWUsImRpZ2VzdFN1YnNjcmlwdGlvbiI6bnVsbCwidXNlTWFya2Rvd24iOmZhbHNlLCJ1c2VNYXJrZG93bkluQ29tbWVudHMiOmZhbHNlLCJ1c2VNYXJrZG93bkluQXJ0aWNsZXMiOmZhbHNlLCJ1c2VNYXJrZG93bkluUG9zdHMiOmZhbHNlfSwibGFuZ1NldHRpbmdzIjp7ImhsIjoicnUiLCJmbCI6InJ1In0sImNoYXJnZVNldHRpbmdzIjp7InBvc3RWb3RlQ291bnQiOjE3LCJjb21tZW50Vm90ZUNvdW50IjozNH0sInBlcm1pc3Npb25TZXR0aW5ncyI6eyJjYW5BZGRDb21wbGFpbnRzIjpmYWxzZSwiY2FuQ3JlYXRlVm9pY2VzIjpmYWxzZX19LCJjcmMzMiI6IjMwMTY5MDg0MDkiLCJnYVVpZCI6IjI5YzlmNTYzMTFmNzc2ZWRkYzkwNzYxNzg5YTkyOWM1IiwiYXZhaWxhYmxlSW52aXRlc0NvdW50IjowLCJlbWFpbCI6Im1hc3Rlci1tZW50b3JAbWFpbC5ydSIsInNjb3JlU3RhdHMiOnsic2NvcmUiOjE3LCJ2b3Rlc0NvdW50IjoyM30sInBwYUJhbGFuY2UiOm51bGwsInVucmVhZENvbnZlcnNhdGlvbkNvdW50IjowLCJub3RpZmljYXRpb25VbnJlYWRDb3VudGVycyI6eyJwb3N0c19hbmRfY29tbWVudHMiOjAsInN1YnNjcmliZXJzIjowLCJtZW50aW9ucyI6MCwic3lzdGVtIjowLCJhcHBsaWNhdGlvbnMiOjB9LCJub3RpY2VzIjpbXSwicnNzS2V5IjoiYTZhMGU2YzBkODFhMWZjNjFjZWZmNjUyNTNiODYzMzUiLCJjb21wYW5pZXNBZG1pbiI6W10sInBwZyI6bnVsbH0sInV1aWQiOm51bGwsInBwZ0RlbWFuZGVkIjpmYWxzZSwia2FybWFSZXNldEluZm8iOnsiY2FuUmVpbmNhcm5hdGUiOm51bGwsIndhc1JlaW5jYXJuYXRlZCI6bnVsbCwiY3VycmVudFNjb3JlIjpudWxsfSwibm90ZXMiOm51bGx9LCJtb2RhbCI6eyJtb2RhbHMiOltdfSwibW9zdFJlYWRpbmdMaXN0Ijp7Im1vc3RSZWFkaW5nTGlzdElkcyI6W10sIm1vc3RSZWFkaW5nTGlzdFJlZnMiOm51bGwsInByb21vUG9zdCI6bnVsbH0sInBwYSI6eyJhcnRpY2xlcyI6e30sImNhcmQiOm51bGwsInRyYW5zYWN0aW9ucyI6bnVsbCwidG90YWxUcmFuc2FjdGlvbnMiOm51bGwsImlzQWNjZXNzaWJsZSI6bnVsbH0sInByb2plY3RzQmxvY2tzIjp7ImFjdGl2ZUJsb2NrcyI6e319LCJwcm9tb0RhdGEiOnsiaXNMb2FkaW5nIjpmYWxzZSwiaGFzTG9hZGVkIjpmYWxzZSwiZmVhdHVyZXIiOm51bGwsIm1lZ2Fwb3N0cyI6bnVsbCwicHJvbW9MaW5rcyI6bnVsbCwicHJvbW9Qb3N0cyI6bnVsbH0sInB1bGxSZWZyZXNoIjp7InNob3VsZFJlZnJlc2giOmZhbHNlfSwic2FuZGJveCI6eyJhcnRpY2xlSWRzIjpbXSwiYXJ0aWNsZVJlZnMiOnt9LCJwYWdlc0NvdW50IjpudWxsLCJyb3V0ZSI6e30sImxhc3RWaXNpdGVkUm91dGUiOnt9LCJpc0xvYWRpbmciOmZhbHNlfSwic2VhcmNoIjp7InNlYXJjaFF1ZXJ5RXJyb3IiOm51bGx9LCJzZXR0aW5nc090aGVyIjp7ImlucHV0cyI6eyJ1aUxhbmciOnsiZXJyb3JzIjpbXSwicmVmIjpudWxsLCJ2YWx1ZSI6IiJ9LCJhcnRpY2xlc0xhbmdFbmdsaXNoIjp7ImVycm9ycyI6W10sInJlZiI6bnVsbCwidmFsdWUiOmZhbHNlfSwiYXJ0aWNsZXNMYW5nUnVzc2lhbiI6eyJlcnJvcnMiOltdLCJyZWYiOm51bGwsInZhbHVlIjpmYWxzZX0sImFncmVlbWVudCI6eyJlcnJvcnMiOltdLCJyZWYiOm51bGwsInZhbHVlIjpmYWxzZX0sImVtYWlsIjp7ImVycm9ycyI6W10sInJlZiI6bnVsbCwidmFsdWUiOnRydWV9LCJkaWdlc3QiOnsiZXJyb3JzIjpbXSwicmVmIjpudWxsLCJ2YWx1ZSI6dHJ1ZX19fSwic2ltaWxhckxpc3QiOnsic2ltaWxhckxpc3RJZHMiOltdLCJzaW1pbGFyTGlzdFJlZnMiOm51bGx9LCJzc3IiOnsiZXJyb3IiOm51bGwsImlzRGF0YUxvYWRlZCI6ZmFsc2UsImlzRGF0YUxvYWRpbmciOmZhbHNlLCJpc0h5ZHJhdGlvbkZhaWxlZCI6ZmFsc2UsImlzU2VydmVyIjpmYWxzZX0sInN0b3JpZXMiOnsic3RvcmllcyI6W3siaWQiOiJzdG9yeS0yOTYiLCJhdXRob3IiOnsibG9nbyI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGZDU5XHUwMDJGYTRiXHUwMDJGYzc0XHUwMDJGZDU5YTRiYzc0ZGVlYzU1OTg4ODcyOGJhYzYzYzg3NDQucG5nIiwidGl0bGUiOiLQpdCw0LHRgCDQmtCw0YDRjNC10YDQsCIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZ1LmhhYnIuY29tXHUwMDJGZm5vTzkifSwidGl0bGUiOiLQmtC10Lwg0YDQsNCx0L7RgtCw0YLRjCDQsiBJVDogU2NydW0t0LzQsNGB0YLQtdGAIiwibGFuZyI6InJ1Iiwic3RhcnRUaW1lIjoiMjAyMy0wMy0xNFQxMToxMDowMCswMzowMCIsImZpbmlzaFRpbWUiOiIyMDIzLTAzLTIxVDIzOjU5OjAwKzAzOjAwIiwic2xpZGVzIjpbeyJpZCI6InN0b3J5LTI5Nl8xIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjUwY1x1MDAyRmY0ZVx1MDAyRmIwYlx1MDAyRjUwY2Y0ZWIwYjYzYmFjZjk0ZmU0OTczN2QwZTAwOTU4LnBuZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI5Nl8yIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjRjZlx1MDAyRjk4MVx1MDAyRmI5NVx1MDAyRjRjZjk4MWI5NWVmOWFmZWI3NzNkMTkxNjEyZGRmZWMzLnBuZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI5Nl8zIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjNhYlx1MDAyRmU3OVx1MDAyRjVkYVx1MDAyRjNhYmU3OTVkYTc4ZGNkNGMxZjk1MWE3ZWI2NDgxNjA4LnBuZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCf0L7QtNGA0L7QsdC90LXQtSIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZ1LmhhYnIuY29tXHUwMDJGZm5vTzkiLCJjb2xvclR5cGUiOiJkYXJrIn19LHsiaWQiOiJzdG9yeS0yOTZfNCIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkY3MmZcdTAwMkZlM2VcdTAwMkY0NmZcdTAwMkY3MmZlM2U0NmZhYWY2MGVjNTE4MTAwYjE1NWI2MWQ3My5wbmciLCJidXR0b24iOnsidGl0bGUiOiLQn9C+0LTRgNC+0LHQvdC10LUiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRmZub085IiwiY29sb3JUeXBlIjoiZGFyayJ9fSx7ImlkIjoic3RvcnktMjk2XzUiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGNDcxXHUwMDJGMDYwXHUwMDJGOWExXHUwMDJGNDcxMDYwOWExZGZhNmE1MDhmZWY4ZWM2MmYwMzE2MjEucG5nIiwiYnV0dG9uIjp7InRpdGxlIjoi0J/QvtC00YDQvtCx0L3QtdC1IiwibGluayI6Imh0dHBzOlx1MDAyRlx1MDAyRnUuaGFici5jb21cdTAwMkZmbm9POSIsImNvbG9yVHlwZSI6ImRhcmsifX0seyJpZCI6InN0b3J5LTI5Nl82IiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjY3Zlx1MDAyRjQ5Ylx1MDAyRjg4Y1x1MDAyRjY3ZjQ5Yjg4YzVlMzk5YjRkNzVjNTYwMjg4YjcyNzk2LnBuZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCf0L7QtNGA0L7QsdC90LXQtSIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZ1LmhhYnIuY29tXHUwMDJGZm5vTzkiLCJjb2xvclR5cGUiOiJkYXJrIn19XX0seyJpZCI6InN0b3J5LTI5NCIsImF1dGhvciI6eyJsb2dvIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkY1YjRcdTAwMkZmODBcdTAwMkYyZTlcdTAwMkY1YjRmODAyZTk0MDA1YTVmOGZkZjM0YWU0MmQ2Y2QwMC5wbmciLCJ0aXRsZSI6ItCl0LDQsdGAINCd0L7QstC+0YHRgtC4IiwibGluayI6Imh0dHBzOlx1MDAyRlx1MDAyRnUuaGFici5jb21cdTAwMkYwUjNCNyJ9LCJ0aXRsZSI6ItCt0LrQt9C+0YHQutC10LvQtdGCINC00LvRjyDQv9GD0YLQtdGI0LXRgdGC0LLQuNC5IiwibGFuZyI6InJ1Iiwic3RhcnRUaW1lIjoiMjAyMy0wMy0xMFQxODoxNTowMCswMzowMCIsImZpbmlzaFRpbWUiOiIyMDIzLTAzLTE0VDE4OjI1OjAwKzAzOjAwIiwic2xpZGVzIjpbeyJpZCI6InN0b3J5LTI5NF8xIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjU1OFx1MDAyRjFmNlx1MDAyRjZlNlx1MDAyRjU1ODFmNjZlNmI4YmQ0ODMwZjJiNzRlM2JjZjU4YzI4LmpwZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI5NF8yIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjBjOFx1MDAyRjY5N1x1MDAyRmVjNFx1MDAyRjBjODY5N2VjNDc3ZGVhOWZhYWEwNTlmYmVhMjQ5MjU2LmpwZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI5NF8zIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjU1N1x1MDAyRjgxNVx1MDAyRjhiY1x1MDAyRjU1NzgxNThiY2NlNGFmMmM2OGFhZDZmZTg2NmM2MDJiLmpwZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCj0LfQvdCw0YLRjCDQsdC+0LvRjNGI0LUiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRjBSM0I3IiwiY29sb3JUeXBlIjoiZGFyayJ9fV19LHsiaWQiOiJzdG9yeS0yOTAiLCJhdXRob3IiOnsibG9nbyI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGZWY5XHUwMDJGNjA2XHUwMDJGMWUzXHUwMDJGZWY5NjA2MWUzYjAwNzJlZDY4ZDZhMjBiMTdhMGI2YzAucG5nIiwidGl0bGUiOiLQpdCw0LHRgCDQndC+0LLQvtGB0YLQuCIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZ1LmhhYnIuY29tXHUwMDJGeVowQzgifSwidGl0bGUiOiJCaW5nINGB0YLQsNC7INC40LzQuNGC0LjRgNC+0LLQsNGC0Ywg0LfQvdCw0LzQtdC90LjRgtC+0YHRgtC10LkiLCJsYW5nIjoicnUiLCJzdGFydFRpbWUiOiIyMDIzLTAzLTEwVDE4OjAwOjAwKzAzOjAwIiwiZmluaXNoVGltZSI6IjIwMjMtMDMtMTRUMTc6MzA6MDArMDM6MDAiLCJzbGlkZXMiOlt7ImlkIjoic3RvcnktMjkwXzEiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGY2ZkXHUwMDJGMzI2XHUwMDJGNzE3XHUwMDJGY2ZkMzI2NzE3MGY3MmE3MWU5ZDgyNzQ3ZmNiMjkwZDguanBnIiwiYnV0dG9uIjpudWxsfSx7ImlkIjoic3RvcnktMjkwXzIiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGYjMxXHUwMDJGN2QxXHUwMDJGMDQzXHUwMDJGYjMxN2QxMDQzMTMyZDhiNDcxNTU4ZDMzNDAzMzBhNTcuanBnIiwiYnV0dG9uIjpudWxsfSx7ImlkIjoic3RvcnktMjkwXzMiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGMzVmXHUwMDJGYjliXHUwMDJGOGE5XHUwMDJGMzVmYjliOGE5NzdmODg3NmY0NmEwODM5YWU2YzZkYjguanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0J/QvtC00YDQvtCx0L3QtdC1IiwibGluayI6Imh0dHBzOlx1MDAyRlx1MDAyRnUuaGFici5jb21cdTAwMkZ5WjBDOCIsImNvbG9yVHlwZSI6ImxpZ2h0In19XX0seyJpZCI6InN0b3J5LTI4MCIsImF1dGhvciI6eyJsb2dvIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkY4ZjNcdTAwMkZmODlcdTAwMkZhYTVcdTAwMkY4ZjNmODlhYTUwMGE1ZmM0MDdmN2UxZTkyNzAwMmNlMC5wbmciLCJ0aXRsZSI6IkdlZWsgVHJhdmVsIiwibGluayI6bnVsbH0sInRpdGxlIjoi0JPQtNC1INCyINCg0L7RgdGB0LjQuCDQv9C+0LrQsNGC0LDRgtGM0YHRjyDQvdCwINC00YDQtdC30LjQvdC1IiwibGFuZyI6InJ1Iiwic3RhcnRUaW1lIjoiMjAyMy0wMy0wOVQxMDowMDowMCswMzowMCIsImZpbmlzaFRpbWUiOiIyMDIzLTAzLTE5VDIzOjU5OjAwKzAzOjAwIiwic2xpZGVzIjpbeyJpZCI6InN0b3J5LTI4MF8xIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRmI0NFx1MDAyRjY4Ylx1MDAyRmQ1MVx1MDAyRmI0NDY4YmQ1MTQ5NDcyMzgwN2E0NDM4ZjAzYTk4MjRkLmpwZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI4MF8yIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjNhYVx1MDAyRmFmZVx1MDAyRjBmYlx1MDAyRjNhYWFmZTBmYjgwM2MwMDQzYWZmNzBhZTQwN2E2ZGEwLmpwZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI4MF8zIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRmNhNlx1MDAyRjhlZFx1MDAyRjNkOFx1MDAyRmNhNjhlZDNkODI1MWY1ZTI1MDM0ZDI3YzRlNzNkYTNhLmpwZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI4MF80IiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRmYwMlx1MDAyRmYwNVx1MDAyRmFmZFx1MDAyRmYwMmYwNWFmZGE2ZjU5MjVlNGFhYTM3NDg5NTM1NzVjLmpwZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI4MF81IiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRmNhOVx1MDAyRmE2YVx1MDAyRmFkMlx1MDAyRmNhOWE2YWFkMjExM2EyOTI1NjY5MjRiMDE1YTQ0ZDg4LmpwZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI4MF82IiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjRmOFx1MDAyRjcwOFx1MDAyRmFhOVx1MDAyRjRmODcwOGFhOTUyNmIwNWRkOGJjMGUyM2RiYmI1OWQ3LmpwZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI4MF83IiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjJhZlx1MDAyRjlkMlx1MDAyRjg1Mlx1MDAyRjJhZjlkMjg1MmE0NjBkNjkzNjRlMDk2OWNiYjdkMDRmLmpwZyIsImJ1dHRvbiI6bnVsbH1dfSx7ImlkIjoic3RvcnktMjg4IiwiYXV0aG9yIjp7ImxvZ28iOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjgxYlx1MDAyRjRmN1x1MDAyRjFlOFx1MDAyRjgxYjRmNzFlOGZkYzc2NmY2ZDkxNDkxYTUxNzllY2IwLnBuZyIsInRpdGxlIjoi0KXQsNCx0YAg0JrQsNGA0YzQtdGA0LAiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFici5jb21cdTAwMkZydVx1MDAyRnVzZXJzXHUwMDJGaGFicl9jYXJlZXJcdTAwMkZwb3N0c1x1MDAyRiJ9LCJ0aXRsZSI6ItCg0LDQt9Cx0L7RgCDRgNC10LfRjtC80LUg0YHQv9C10YbQuNCw0LvQuNGB0YLQvtCyINC90LAg0KXQsNCx0YAg0JrQsNGA0YzQtdGA0LUiLCJsYW5nIjoicnUiLCJzdGFydFRpbWUiOiIyMDIzLTAzLTA4VDEzOjAwOjAwKzAzOjAwIiwiZmluaXNoVGltZSI6IjIwMjMtMDMtMTVUMjM6NTk6MDArMDM6MDAiLCJzbGlkZXMiOlt7ImlkIjoic3RvcnktMjg4XzEiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGODVhXHUwMDJGMGVjXHUwMDJGZGUwXHUwMDJGODVhMGVjZGUwMzhhMzVmMDFmZjMyOGEzZTY3ZjU0NTAucG5nIiwiYnV0dG9uIjpudWxsfSx7ImlkIjoic3RvcnktMjg4XzIiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGODg1XHUwMDJGMDc4XHUwMDJGM2UxXHUwMDJGODg1MDc4M2UxMjdjMDQyZjRkYjdhMzFjYmU0M2M1NjEucG5nIiwiYnV0dG9uIjpudWxsfSx7ImlkIjoic3RvcnktMjg4XzMiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGODc2XHUwMDJGMzRjXHUwMDJGNWI4XHUwMDJGODc2MzRjNWI4NTVlYTE4NDY5YTMwMjRlMzg2YmIxNjAucG5nIiwiYnV0dG9uIjp7InRpdGxlIjoi0KHQvNC+0YLRgNC10YLRjCDRgNCw0LfQsdC+0YAiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRnlEZm9UIiwiY29sb3JUeXBlIjoiZGFyayJ9fV19LHsiaWQiOiJzdG9yeS0yODYiLCJhdXRob3IiOnsibG9nbyI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGZmJjXHUwMDJGYjVkXHUwMDJGMzYwXHUwMDJGZmJjYjVkMzYwOWRlYzY2NTM3MzRmZjYyYWUwNzE2YmUucG5nIiwidGl0bGUiOiLQpdCw0LHRgCDQmtCw0YDRjNC10YDQsCIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZ1LmhhYnIuY29tXHUwMDJGN3ZWWlQifSwidGl0bGUiOiLQlNCw0LnQtNC20LXRgdGCINGB0L7QsdGL0YLQuNC5INC00LvRjyBJVCBIUiDQsiDQvNCw0YDRgtC1IiwibGFuZyI6InJ1Iiwic3RhcnRUaW1lIjoiMjAyMy0wMy0wN1QxNDo1NDo0MiswMzowMCIsImZpbmlzaFRpbWUiOiIyMDIzLTAzLTE0VDIzOjU5OjAwKzAzOjAwIiwic2xpZGVzIjpbeyJpZCI6InN0b3J5LTI4Nl8xIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjZlY1x1MDAyRjkxOFx1MDAyRmQ2ZVx1MDAyRjZlYzkxOGQ2ZWUxNDQzZDcxMzRjMmU2ZjUxYmRhNjZiLnBuZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI4Nl8yIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjU1MFx1MDAyRmJhY1x1MDAyRmMzZlx1MDAyRjU1MGJhY2MzZjcwMTc3MDMyNTMwNzJjZjFkZjNmOGNjLnBuZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI4Nl8zIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjExNlx1MDAyRjE2YVx1MDAyRjM2OVx1MDAyRjExNjE2YTM2OTJkOGFmNmNlMDY2NDMzOGU1ZDYyN2I1LnBuZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCh0LzQvtGC0YDQtdGC0Ywg0YHQvtCx0YvRgtC40Y8iLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRjd2VlpUIiwiY29sb3JUeXBlIjoiZGFyayJ9fV19LHsiaWQiOiJzdG9yeS0yODIiLCJhdXRob3IiOnsibG9nbyI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGMWEyXHUwMDJGOWRlXHUwMDJGMDE1XHUwMDJGMWEyOWRlMDE1NDdmYzRhMjgwYTMxZjViNmY3ODg1ZTgucG5nIiwidGl0bGUiOiLQpdCw0LHRgCIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyLmNvbVx1MDAyRnJ1XHUwMDJGY29tcGFueVx1MDAyRmhhYnJcdTAwMkZibG9nXHUwMDJGIn0sInRpdGxlIjoi0KLQvtC/LTcg0LPQvtC00L3QvtGC0Ysg0LjQtyDQsdC70L7Qs9C+0LIg0LrQvtC80L/QsNC90LjQuSIsImxhbmciOiJydSIsInN0YXJ0VGltZSI6IjIwMjMtMDMtMDdUMTA6MzA6MDArMDM6MDAiLCJmaW5pc2hUaW1lIjoiMjAyMy0wMy0xNFQyMzo1OTowMCswMzowMCIsInNsaWRlcyI6W3siaWQiOiJzdG9yeS0yODJfMSIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkYyMjZcdTAwMkZkMTFcdTAwMkY2ZGNcdTAwMkYyMjZkMTE2ZGNhYzMwZDI2OWIyMjJkNTYwYjFmM2ExZS5qcGciLCJidXR0b24iOm51bGx9LHsiaWQiOiJzdG9yeS0yODJfMiIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkYzZDZcdTAwMkY5ZDVcdTAwMkY2OWVcdTAwMkYzZDY5ZDU2OWVhYjVjZjg0OWUyNzNjNDg5ZTNkOWIxMC5qcGciLCJidXR0b24iOnsidGl0bGUiOiLQoNC10LnRgSDQsiDQv9GA0L7RiNC70L7QtSIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyLmNvbVx1MDAyRnJ1XHUwMDJGY29tcGFueVx1MDAyRnR1dHVydVx1MDAyRmJsb2dcdTAwMkY3MTkwODRcdTAwMkYiLCJjb2xvclR5cGUiOiJsaWdodCJ9fSx7ImlkIjoic3RvcnktMjgyXzMiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGNGUxXHUwMDJGMjJhXHUwMDJGZTcxXHUwMDJGNGUxMjJhZTcxZDc4NTQ2ZTY5YTVmYWZjYmZjOGRjY2YuanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0J/QvtGC0YvQutCw0YLRjCDQutC90L7Qv9C60LgiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFici5jb21cdTAwMkZydVx1MDAyRmNvbXBhbnlcdTAwMkZzZWxlY3RlbFx1MDAyRmJsb2dcdTAwMkY3MTg0ODhcdTAwMkYiLCJjb2xvclR5cGUiOiJsaWdodCJ9fSx7ImlkIjoic3RvcnktMjgyXzQiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGN2JmXHUwMDJGYTg5XHUwMDJGMzNjXHUwMDJGN2JmYTg5MzNjYzZjMjJkYjc3OTk2MjgwZWMwMDRjMjQuanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0KPQt9C90LDRgtGMINCx0L7Qu9GM0YjQtSIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyLmNvbVx1MDAyRnJ1XHUwMDJGY29tcGFueVx1MDAyRmdldG1hdGNoXHUwMDJGYmxvZ1x1MDAyRjcxOTIxNFx1MDAyRiIsImNvbG9yVHlwZSI6ImxpZ2h0In19LHsiaWQiOiJzdG9yeS0yODJfNSIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkZkMjRcdTAwMkYzNDRcdTAwMkZjMmFcdTAwMkZkMjQzNDRjMmFkY2NiY2ExYjYyNTVjMzRjNDY3YWI2Ni5qcGciLCJidXR0b24iOnsidGl0bGUiOiLQp9C40YLQsNGC0Ywg0YLRg9GC0L7RgNC40LDQuyIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyLmNvbVx1MDAyRnJ1XHUwMDJGY29tcGFueVx1MDAyRnNraWxsZmFjdG9yeVx1MDAyRmJsb2dcdTAwMkY3MTg4OTRcdTAwMkYiLCJjb2xvclR5cGUiOiJsaWdodCJ9fSx7ImlkIjoic3RvcnktMjgyXzYiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGOTU3XHUwMDJGOGE5XHUwMDJGNmM3XHUwMDJGOTU3OGE5NmM3YzE1YjFmZmRhOThhZmJlZjlkZmRlZjYuanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0KPQstC40LTQtdGC0Ywg0LzQsNCz0LjRjiIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyLmNvbVx1MDAyRnJ1XHUwMDJGY29tcGFueVx1MDAyRnJ1dmRzXHUwMDJGYmxvZ1x1MDAyRjcxODM4NFx1MDAyRiIsImNvbG9yVHlwZSI6ImxpZ2h0In19LHsiaWQiOiJzdG9yeS0yODJfNyIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkZhYmVcdTAwMkY1ZTFcdTAwMkY4ZGRcdTAwMkZhYmU1ZTE4ZGQwNzljYjk3M2UwNWNmNzZmZDQwZmQxZS5qcGciLCJidXR0b24iOnsidGl0bGUiOiLQn9C+0LvQtdGC0LXQu9C4IiwibGluayI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnIuY29tXHUwMDJGcnVcdTAwMkZjb21wYW55XHUwMDJGcnV2ZHNcdTAwMkZibG9nXHUwMDJGNzE4NDQ2XHUwMDJGIiwiY29sb3JUeXBlIjoibGlnaHQifX0seyJpZCI6InN0b3J5LTI4Ml84IiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjUzZVx1MDAyRjVlM1x1MDAyRjMwZlx1MDAyRjUzZTVlMzMwZjM5OTY1NDY0ZWM1ZjY5MDg2OTVhNjA2LmpwZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCf0YDQvtGC0L7QutC+0Lsg0L7Qv9C10YDQsNGG0LjQuCIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyLmNvbVx1MDAyRnJ1XHUwMDJGY29tcGFueVx1MDAyRnRpbWV3ZWJcdTAwMkZibG9nXHUwMDJGNzE3OTU2XHUwMDJGIiwiY29sb3JUeXBlIjoibGlnaHQifX1dfSx7ImlkIjoic3RvcnktMjc4IiwiYXV0aG9yIjp7ImxvZ28iOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjNiMlx1MDAyRjJiOVx1MDAyRjg3NFx1MDAyRjNiMjJiOTg3NGMzMGQyZTk1ZjA2ZThiYTU5MWQ3MjI2LnBuZyIsInRpdGxlIjoi0KXQsNCx0YAiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFici5jb21cdTAwMkZydVx1MDAyRmNvbXBhbnlcdTAwMkZoYWJyXHUwMDJGYmxvZ1x1MDAyRiJ9LCJ0aXRsZSI6ItCh0YXQstCw0YLQuNC7INC30LAg0LzQvtC30LMiLCJsYW5nIjoicnUiLCJzdGFydFRpbWUiOiIyMDIzLTAzLTA2VDExOjAwOjAwKzAzOjAwIiwiZmluaXNoVGltZSI6IjIwMjMtMDMtMTlUMjM6NTk6MDArMDM6MDAiLCJzbGlkZXMiOlt7ImlkIjoic3RvcnktMjc4XzEiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGNmQyXHUwMDJGNTE1XHUwMDJGNjQ5XHUwMDJGNmQyNTE1NjQ5YTk4ZWJmZjBmZmYyYzk1ZjEzYWE5ZTYuanBnIiwiYnV0dG9uIjpudWxsfSx7ImlkIjoic3RvcnktMjc4XzIiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGNmJhXHUwMDJGMzdjXHUwMDJGNzU2XHUwMDJGNmJhMzdjNzU2NzE5NDFiYjIxMmUwYmY4MTVmOTk1NTAuanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0KfRgtC+INC+0LrQsNC30LDQu9C+0YHRjD8iLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRmJyYWluMDEiLCJjb2xvclR5cGUiOiJsaWdodCJ9fSx7ImlkIjoic3RvcnktMjc4XzMiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGNzAyXHUwMDJGYmU4XHUwMDJGYThmXHUwMDJGNzAyYmU4YThmZTIxZDQ4MzkzNmRmNTRkYzA3NGI5NmEuanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0J7RgdC+0LfQvdCw0YLRjCIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZ1LmhhYnIuY29tXHUwMDJGYnJhaW4wMiIsImNvbG9yVHlwZSI6ImxpZ2h0In19LHsiaWQiOiJzdG9yeS0yNzhfNCIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkY5ZTJcdTAwMkYyYzJcdTAwMkY0OTlcdTAwMkY5ZTIyYzI0OTkwMThjMzdkYmI0MDY0MDUzZWY3ZTBhMC5qcGciLCJidXR0b24iOnsidGl0bGUiOiLQntGC0LvQvtC20LjRgtGMINGC0LDQsdC70LXRgtC60YMiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRmJyYWluMDMiLCJjb2xvclR5cGUiOiJkYXJrIn19LHsiaWQiOiJzdG9yeS0yNzhfNSIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkY3NTZcdTAwMkY4NWZcdTAwMkY5OWJcdTAwMkY3NTY4NWY5OWIwMGY3YTIzMjMwMjg5NDg4MThhMWI2Ni5qcGciLCJidXR0b24iOnsidGl0bGUiOiLQodC80L7RgtGA0LXRgtGMINGB0L7QstC10YLRiyIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZ1LmhhYnIuY29tXHUwMDJGYnJhaW4wNCIsImNvbG9yVHlwZSI6ImRhcmsifX0seyJpZCI6InN0b3J5LTI3OF82IiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjQ0Mlx1MDAyRjlhOFx1MDAyRjE1OVx1MDAyRjQ0MjlhODE1OWE0MjgwNTc1YTMwY2YxYmJiZGIzYjA4LmpwZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCj0LTQtdC70LjRgtGMINCy0L3QuNC80LDQvdC40LUiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRmJyYWluMDUiLCJjb2xvclR5cGUiOiJsaWdodCJ9fSx7ImlkIjoic3RvcnktMjc4XzciLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGODkyXHUwMDJGZTNlXHUwMDJGYThiXHUwMDJGODkyZTNlYThiNGFkODkzNGM2ODU4MzQ4OTQzODA0ZmQuanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0JfQsNC/0LjRgdCw0YLRjCDQvdGD0LbQvdC+0LUiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRmJyYWluMDYiLCJjb2xvclR5cGUiOiJsaWdodCJ9fSx7ImlkIjoic3RvcnktMjc4XzgiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGZmE1XHUwMDJGZmU5XHUwMDJGN2JiXHUwMDJGZmE1ZmU5N2JiMWVjNGFmMWU3YjFlMTY0MTcxYjc5NWMuanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0JrQsNC60L7QtSDQuNC80LXQvdC90L4/IiwibGluayI6Imh0dHBzOlx1MDAyRlx1MDAyRnUuaGFici5jb21cdTAwMkZicmFpbjA3IiwiY29sb3JUeXBlIjoibGlnaHQifX1dfSx7ImlkIjoic3RvcnktMjc2IiwiYXV0aG9yIjp7ImxvZ28iOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjM3MVx1MDAyRjE2ZVx1MDAyRjlhZVx1MDAyRjM3MTE2ZTlhZWMyNGE5OTMwOGI1ZDU1ZmQzMzg1MDYyLnBuZyIsInRpdGxlIjoi0KXQsNCx0YAiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRnN0b3JpZXNfaGFicmFwcCJ9LCJ0aXRsZSI6ItCf0YDQuNC70L7QttC10L3QuNC1INCl0LDQsdGA0LAg0LTQu9GPIEFuZHJvaWQg0LggaU9TIiwibGFuZyI6InJ1Iiwic3RhcnRUaW1lIjoiMjAyMy0wMy0wNlQxMDowMDowMCswMzowMCIsImZpbmlzaFRpbWUiOiIyMDIzLTAzLTE5VDIzOjU5OjAwKzAzOjAwIiwic2xpZGVzIjpbeyJpZCI6InN0b3J5LTI3Nl8xIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjVkNVx1MDAyRmFkYlx1MDAyRjFkZFx1MDAyRjVkNWFkYjFkZDJhYmY2YTJlN2Y4OTU2ZjQ4NzllY2VkLmpwZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCS0L7RgiDRjdGC0L4g0L3QvtCy0L7RgdGC0YwhIiwibGluayI6Imh0dHBzOlx1MDAyRlx1MDAyRnUuaGFici5jb21cdTAwMkZzdG9yaWVzX2hhYnJhcHAiLCJjb2xvclR5cGUiOiJsaWdodCJ9fSx7ImlkIjoic3RvcnktMjc2XzIiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGMmUxXHUwMDJGZDc1XHUwMDJGOTljXHUwMDJGMmUxZDc1OTljMzhlM2MxMWQxMjRkNWU4YmVlY2U2Y2MuanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0JAg0YfRgtC+INGDINCy0LDRgSDQt9CwINGB0YLQtdC6PyIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZ1LmhhYnIuY29tXHUwMDJGc3Rvcmllc19oYWJyYXBwIiwiY29sb3JUeXBlIjoiZGFyayJ9fSx7ImlkIjoic3RvcnktMjc2XzMiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGNDQ4XHUwMDJGZTgzXHUwMDJGMWY5XHUwMDJGNDQ4ZTgzMWY5ZGE5MjU2NzI5ZGZmNDc3MThhZWZkYWIuanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0J/QtdGA0LXQudGC0Lgg0Log0L/RgNC40LvQvtC20LXQvdC40Y4iLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRks4SWI4IiwiY29sb3JUeXBlIjoibGlnaHQifX0seyJpZCI6InN0b3J5LTI3Nl80IiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRmFhMFx1MDAyRjM5NVx1MDAyRjA4MFx1MDAyRmFhMDM5NTA4MGRiMmY2ZWViYmMyMjYyMGEzMTUzYzFjLmpwZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCf0LXRgNC10LnRgtC4INC6INC/0YDQuNC70L7QttC10L3QuNGOIiwibGluayI6Imh0dHBzOlx1MDAyRlx1MDAyRnUuaGFici5jb21cdTAwMkZGYXR5ViIsImNvbG9yVHlwZSI6ImRhcmsifX1dfSx7ImlkIjoic3RvcnktMjcyIiwiYXV0aG9yIjp7ImxvZ28iOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjgyYlx1MDAyRmRkN1x1MDAyRjdkOFx1MDAyRjgyYmRkNzdkOGVmNzMwNGQzYjFiNTk5MTkxYzJiYjFjLnBuZyIsInRpdGxlIjoi0KHQtdC30L7QvdGLINCl0LDQsdGA0LAiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRjVQNmk3In0sInRpdGxlIjoi0J7RgtC60YDRi9GCINGB0LXQt9C+0L0gTUwiLCJsYW5nIjoicnUiLCJzdGFydFRpbWUiOiIyMDIzLTAzLTAyVDA5OjAwOjQxKzAzOjAwIiwiZmluaXNoVGltZSI6IjIwMjMtMDMtMzFUMjA6NTM6MDArMDM6MDAiLCJzbGlkZXMiOlt7ImlkIjoic3RvcnktMjcyXzEiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGMjdmXHUwMDJGZDNhXHUwMDJGZGRmXHUwMDJGMjdmZDNhZGRmZTA2ZGEwOTU5MmJkY2Y2MWRiMTU3OTUuanBnIiwiYnV0dG9uIjpudWxsfSx7ImlkIjoic3RvcnktMjcyXzIiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGOTM1XHUwMDJGNTgyXHUwMDJGOTkyXHUwMDJGOTM1NTgyOTkyZTM3OGFkZDMzYzg5ODQ1MWIyYTBkOWYuanBnIiwiYnV0dG9uIjpudWxsfSx7ImlkIjoic3RvcnktMjcyXzMiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGZTEzXHUwMDJGZWI4XHUwMDJGYTI0XHUwMDJGZTEzZWI4YTI0YjYwNjIyZDNkYTcyZmQ2ZTdlZDNmZGEuanBnIiwiYnV0dG9uIjpudWxsfSx7ImlkIjoic3RvcnktMjcyXzQiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGYTg1XHUwMDJGODNmXHUwMDJGNWNjXHUwMDJGYTg1ODNmNWNjZmFlNzQ3MTM1MzQzZjBlNjhjODQxMTIuanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0J/QvtC00YDQvtCx0L3QtdC1IiwibGluayI6Imh0dHBzOlx1MDAyRlx1MDAyRnUuaGFici5jb21cdTAwMkY1UDZpNyIsImNvbG9yVHlwZSI6ImxpZ2h0In19LHsiaWQiOiJzdG9yeS0yNzJfNSIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkY2MGRcdTAwMkYxY2JcdTAwMkY5OGNcdTAwMkY2MGQxY2I5OGNkZDQyZDI2OTZlYmMwZWM1NDc0MGEyMy5qcGciLCJidXR0b24iOnsidGl0bGUiOiLQn9C+0LTRgNC+0LHQvdC10LUiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRjVQNmk3IiwiY29sb3JUeXBlIjoibGlnaHQifX1dfSx7ImlkIjoic3RvcnktMjYyIiwiYXV0aG9yIjp7ImxvZ28iOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjJmYVx1MDAyRmM4YVx1MDAyRmJhOFx1MDAyRjJmYWM4YWJhODJiOTk1Mjk3YWJlYTU5NWRhNzk5MGQxLnBuZyIsInRpdGxlIjoi0KXQsNCx0YAiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFici5jb21cdTAwMkZydVx1MDAyRmNvbXBhbnlcdTAwMkZoYWJyXHUwMDJGYmxvZ1x1MDAyRiJ9LCJ0aXRsZSI6ItCd0LDRg9C60LAg0YHQvdCwIiwibGFuZyI6InJ1Iiwic3RhcnRUaW1lIjoiMjAyMy0wMi0yOFQxMjoxNTowMCswMzowMCIsImZpbmlzaFRpbWUiOiIyMDIzLTAzLTE1VDIzOjU5OjAwKzAzOjAwIiwic2xpZGVzIjpbeyJpZCI6InN0b3J5LTI2Ml8xIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRmE5MFx1MDAyRjcyNVx1MDAyRjYxY1x1MDAyRmE5MDcyNTYxYzI4MGM0NjkzM2ZmNTRmZDg3MDJjYWRlLmpwZyIsImJ1dHRvbiI6bnVsbH0seyJpZCI6InN0b3J5LTI2Ml8yIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRmZkN1x1MDAyRjY1OFx1MDAyRjk1Nlx1MDAyRmZkNzY1ODk1NmVhODI1YjFjMzE3YzdmNjg4YzQ4MDU4LmpwZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCn0LjRgtCw0YLRjCDQu9C10LrRhtC40Y4iLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRnNvbjAxIiwiY29sb3JUeXBlIjoibGlnaHQifX0seyJpZCI6InN0b3J5LTI2Ml8zIiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjM2Nlx1MDAyRmQyZVx1MDAyRjcwN1x1MDAyRjM2NmQyZTcwNzI1MjA5MTc3ZmE4MmE0MTE5MTM5Yzg2LmpwZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCf0YDQuCDRh9GR0Lwg0LbQtT8iLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRnNvbjAyIiwiY29sb3JUeXBlIjoibGlnaHQifX0seyJpZCI6InN0b3J5LTI2Ml80IiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjRiZFx1MDAyRjQwZlx1MDAyRjczMVx1MDAyRjRiZDQwZjczMWJmYmY1NzFhNzA5ZGQyZjM1N2YwNmI0LmpwZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCX0LDQs9C70Y/QvdGD0YLRjCDQsiDQtNC90LXQstC90LjQuiIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZ1LmhhYnIuY29tXHUwMDJGc29uMDMiLCJjb2xvclR5cGUiOiJsaWdodCJ9fSx7ImlkIjoic3RvcnktMjYyXzUiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGOTQ0XHUwMDJGN2FkXHUwMDJGZTJmXHUwMDJGOTQ0N2FkZTJmMzhjM2MzNjc5MGJlNzViZjQ0NjIwNDcuanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0J/QvtGB0LvQtdC00YHRgtCy0LjRjyIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZ1LmhhYnIuY29tXHUwMDJGc29uMDQiLCJjb2xvclR5cGUiOiJsaWdodCJ9fSx7ImlkIjoic3RvcnktMjYyXzYiLCJpbWFnZSI6Imh0dHBzOlx1MDAyRlx1MDAyRmhhYnJhc3RvcmFnZS5vcmdcdTAwMkZnZXRwcm9cdTAwMkZoYWJyXHUwMDJGdXBsb2FkX2ZpbGVzXHUwMDJGNzRjXHUwMDJGY2UxXHUwMDJGNGRjXHUwMDJGNzRjY2UxNGRjOTAzYjI0NWRjYTkwZGYzZjI3NDdhYmIuanBnIiwiYnV0dG9uIjp7InRpdGxlIjoi0KHQvNC+0YLRgNC10YLRjCDRgdC/0LjRgdC+0LoiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRnNvbjA1IiwiY29sb3JUeXBlIjoibGlnaHQifX0seyJpZCI6InN0b3J5LTI2Ml83IiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRmJjOVx1MDAyRmE2Mlx1MDAyRjlmMFx1MDAyRmJjOWE2MjlmMGM1ZWYyMDI3Y2Y3Nzk2NzQ5YTA2OTE0LmpwZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCh0LvQtdC00Ysg0LIg0LjRgdGC0L7RgNC40LgiLCJsaW5rIjoiaHR0cHM6XHUwMDJGXHUwMDJGdS5oYWJyLmNvbVx1MDAyRnNvbjA2IiwiY29sb3JUeXBlIjoibGlnaHQifX0seyJpZCI6InN0b3J5LTI2Ml84IiwiaW1hZ2UiOiJodHRwczpcdTAwMkZcdTAwMkZoYWJyYXN0b3JhZ2Uub3JnXHUwMDJGZ2V0cHJvXHUwMDJGaGFiclx1MDAyRnVwbG9hZF9maWxlc1x1MDAyRjA4NVx1MDAyRjBlZVx1MDAyRjg2OFx1MDAyRjA4NTBlZTg2ODEzMmUxZWM0ZWMzYjI0Y2FmN2U3MTlhLmpwZyIsImJ1dHRvbiI6eyJ0aXRsZSI6ItCn0YLQviDQv9GA0LjQtNGD0LzQsNC70Lg/IiwibGluayI6Imh0dHBzOlx1MDAyRlx1MDAyRnUuaGFici5jb21cdTAwMkZzb24wNyIsImNvbG9yVHlwZSI6ImxpZ2h0In19XX0seyJpZCI6InN0b3J5LTE1MiIsImF1dGhvciI6eyJsb2dvIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkZhNDlcdTAwMkYwZDNcdTAwMkY2MDlcdTAwMkZhNDkwZDM2MDlmMjliNmRmYzUzYTdiODhhYjQ3Y2E2NC5wbmciLCJ0aXRsZSI6ItCl0LDQsdGAIiwibGluayI6Imh0dHBzOlx1MDAyRlx1MDAyRnUuaGFici5jb21cdTAwMkZzdG9yeV9IaU0tYW5rZXRhIn0sInRpdGxlIjoi0KHQtdC90YzQvtGA0Ysg4oCUINC+0YfQtdC90Ywg0YHRgtGA0LDQvdC90YvQtSDQu9GO0LTQuCIsImxhbmciOiJydSIsInN0YXJ0VGltZSI6IjIwMjMtMDEtMjNUMTE6MDA6MDArMDM6MDAiLCJmaW5pc2hUaW1lIjoiMjAyMy0wMy0zMVQyMzo1OTowMCswMzowMCIsInNsaWRlcyI6W3siaWQiOiJzdG9yeS0xNTJfMSIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkZiYmJcdTAwMkY5MDFcdTAwMkYwNjNcdTAwMkZiYmI5MDEwNjMwYWU0ODNlZDFmNDFlYzRlMjU3MmMxMy5wbmciLCJidXR0b24iOm51bGx9LHsiaWQiOiJzdG9yeS0xNTJfMiIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkY0ZjhcdTAwMkY2NmNcdTAwMkYxNGZcdTAwMkY0Zjg2NmMxNGYwY2E4OTk5MzM0NDM4ZDdmMTdjMGUzYS5wbmciLCJidXR0b24iOm51bGx9LHsiaWQiOiJzdG9yeS0xNTJfMyIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkY2YjlcdTAwMkZhMDdcdTAwMkZhNjFcdTAwMkY2YjlhMDdhNjEyZGYyMTNhYzNhMWMxNzkzMDE4MjhkZi5wbmciLCJidXR0b24iOm51bGx9LHsiaWQiOiJzdG9yeS0xNTJfNCIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkZmNmJcdTAwMkZhZGJcdTAwMkZiOTlcdTAwMkZmNmJhZGJiOTk2OWQ3ZTM0ZWY0Zjc0OTI3NjdjNmE3Ny5wbmciLCJidXR0b24iOm51bGx9LHsiaWQiOiJzdG9yeS0xNTJfNSIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkZkOWNcdTAwMkY5YWNcdTAwMkY4NzhcdTAwMkZkOWM5YWM4NzhiZWM1YjQ5NDY5OWUwMDgwZGQyZTgxMy5wbmciLCJidXR0b24iOm51bGx9LHsiaWQiOiJzdG9yeS0xNTJfNiIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkZkYjFcdTAwMkZhZjlcdTAwMkZjM2JcdTAwMkZkYjFhZjljM2JiNTU3ZjZjZWU2OThjZjY3NjEwZjk3Ny5wbmciLCJidXR0b24iOm51bGx9LHsiaWQiOiJzdG9yeS0xNTJfNyIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkY1Y2ZcdTAwMkZiZWRcdTAwMkY2NWJcdTAwMkY1Y2ZiZWQ2NWJkMjBiNzA1MWIxYWFjMmI5ZDZlODA3ZS5wbmciLCJidXR0b24iOm51bGx9LHsiaWQiOiJzdG9yeS0xNTJfOCIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkZmYThcdTAwMkYyNTFcdTAwMkY0YTlcdTAwMkZmYTgyNTE0YTk0NzFjZDQ1NTMzOWU5NzE3OGQ4YzAyMS5wbmciLCJidXR0b24iOm51bGx9LHsiaWQiOiJzdG9yeS0xNTJfOSIsImltYWdlIjoiaHR0cHM6XHUwMDJGXHUwMDJGaGFicmFzdG9yYWdlLm9yZ1x1MDAyRmdldHByb1x1MDAyRmhhYnJcdTAwMkZ1cGxvYWRfZmlsZXNcdTAwMkZiZDVcdTAwMkY5MDFcdTAwMkZlOTVcdTAwMkZiZDU5MDFlOTUyZDljZjYzODM1NWEzY2M4YjBjMDkxMS5wbmciLCJidXR0b24iOnsidGl0bGUiOiLQpdC+0YfRgyDQv9C+0LzQvtGH0Ywg0LTQttGD0L3RgyIsImxpbmsiOiJodHRwczpcdTAwMkZcdTAwMkZ1LmhhYnIuY29tXHUwMDJGc3RvcnlfSGlNLWFua2V0YSIsImNvbG9yVHlwZSI6ImxpZ2h0In19XX1dfSwidGVjaG5vdGV4dCI6eyJ5ZWFycyI6W10sInRlY2hub3RleHREb2NGb3JOb21pbmVlcyI6bnVsbCwidGVjaG5vdGV4dERvY0Zvcldpbm5lcnMiOm51bGwsInRlY2hub3RleHRJbmZvIjp7fSwidGVjaG5vdGV4dEluZm9Mb2FkaW5nIjpmYWxzZSwidGVjaG5vdGV4dFdpbm5lcnMiOnt9LCJ0ZWNobm90ZXh0V2lubmVyc0xvYWRpbmciOmZhbHNlfSwidXNlckh1YnNDb250cmlidXRpb24iOnsiY29udHJpYnV0aW9uUmVmcyI6eyJodWJSZWZzIjp7fSwiaHViSWRzIjp7fX19LCJ1c2VySW52aXRlcyI6eyJhdmFpbGFibGVJbnZpdGVzIjowLCJ1c2VkSW52aXRlc0lkcyI6W10sInVzZWRJbnZpdGVzUmVmcyI6e30sInVzZWRJbnZpdGVzUGFnZXNDb3VudCI6MCwidW51c2VkSW52aXRlc0lkcyI6W10sInVudXNlZEludml0ZXNSZWZzIjp7fSwidW51c2VkSW52aXRlc1BhZ2VzQ291bnQiOjB9LCJ1c2VyVm90ZXMiOnsia2FybWFWb3Rlc0xpc3QiOltdLCJrYXJtYVZvdGVzUGFnZXNDb3VudCI6bnVsbCwia2FybWFWb3Rlc0xpc3RMb2FkaW5nIjpmYWxzZSwiY29tbWVudHNWb3Rlc0xpc3QiOltdLCJjb21tZW50c1ZvdGVzUGFnZXNDb3VudCI6bnVsbCwiY29tbWVudHNWb3Rlc0xpc3RMb2FkaW5nIjpmYWxzZSwicG9zdHNWb3Rlc0xpc3QiOltdLCJwb3N0c1ZvdGVzUGFnZXNDb3VudCI6bnVsbCwicG9zdHNWb3Rlc0xpc3RMb2FkaW5nIjpmYWxzZSwidXNlclZvdGVzTGlzdCI6W10sInVzZXJWb3Rlc1BhZ2VzQ291bnQiOm51bGwsInVzZXJWb3Rlc0xpc3RMb2FkaW5nIjpmYWxzZX0sInVzZXJzIjp7ImF1dGhvclJlZnMiOnt9LCJhdXRob3JJZHMiOnt9LCJwYWdlc0NvdW50Ijp7fSwiYXV0aG9yUHJvZmlsZXMiOnt9LCJ1c2VySHVicyI6e30sInVzZXJJbnZpdGF0aW9ucyI6e30sImF1dGhvckZvbGxvd2VycyI6e30sImF1dGhvckZvbGxvd2VkIjp7fSwidXNlclNwZWNpYWxpemF0aW9uIjp7fSwia2FybWFTdGF0cyI6W10sInN0YXRpc3RpY3MiOm51bGwsImlzTG9hZGluZyI6ZmFsc2UsImF1dGhvckZvbGxvd2Vyc0xvYWRpbmciOmZhbHNlLCJhdXRob3JGb2xsb3dlZExvYWRpbmciOmZhbHNlLCJ1c2VySHVic0xvYWRpbmciOmZhbHNlLCJ1c2VySW52aXRhdGlvbnNMb2FkaW5nIjpmYWxzZSwicm91dGUiOnt9fSwidmlld3BvcnQiOnsicHJldlNjcm9sbFkiOnt9LCJzY3JvbGxZIjowLCJ3aWR0aCI6MH0sInRyYWNrZXIiOnsiaXRlbXMiOnt9LCJwYWdlc0NhY2hlIjp7fSwibWFya2VkVmlld2VkU2lsZW50bHkiOnt9LCJtYXJrZWRSZWFkIjp7fSwidW5yZWFkQ291bnRlcnMiOnsiYXBwbGljYXRpb25zIjpudWxsLCJzeXN0ZW0iOm51bGwsIm1lbnRpb25zIjpudWxsLCJzdWJzY3JpYmVycyI6bnVsbCwicG9zdHNfYW5kX2NvbW1lbnRzIjpudWxsfSwidW52aWV3ZWRDb3VudGVycyI6eyJhcHBsaWNhdGlvbnMiOm51bGwsInN5c3RlbSI6bnVsbCwibWVudGlvbnMiOm51bGwsInN1YnNjcmliZXJzIjpudWxsLCJwb3N0c19hbmRfY29tbWVudHMiOm51bGx9fX07KGZ1bmN0aW9uKCl7dmFyIHM7KHM9ZG9jdW1lbnQuY3VycmVudFNjcmlwdHx8ZG9jdW1lbnQuc2NyaXB0c1tkb2N1bWVudC5zY3JpcHRzLmxlbmd0aC0xXSkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzKTt9KCkpOzwvc2NyaXB0Pgo8c2NyaXB0IHNyYz0iaHR0cHM6Ly9hc3NldHMuaGFici5jb20vaGFici13ZWIvanMvY2h1bmstdmVuZG9ycy40ZjY1NGYwYi5qcyIgZGVmZXI+PC9zY3JpcHQ+PHNjcmlwdCBzcmM9Imh0dHBzOi8vYXNzZXRzLmhhYnIuY29tL2hhYnItd2ViL2pzL3BhZ2UtZXJyb3IuZTNlNzU1MDguanMiIGRlZmVyPjwvc2NyaXB0PjxzY3JpcHQgc3JjPSJodHRwczovL2Fzc2V0cy5oYWJyLmNvbS9oYWJyLXdlYi9qcy9hcHAuNDk1YWE0YjAuanMiIGRlZmVyPjwvc2NyaXB0PgoKCgogICAgPHNjcmlwdCBhc3luYyBzcmM9Imh0dHBzOi8vd3d3Lmdvb2dsZXRhZ21hbmFnZXIuY29tL2d0YWcvanM/aWQ9VUEtNzI2MDk0LTEiPjwvc2NyaXB0PgogICAgPHNjcmlwdD4KICAgICAgd2luZG93LmRhdGFMYXllciA9IHdpbmRvdy5kYXRhTGF5ZXIgfHwgW107CiAgICAgIGZ1bmN0aW9uIGd0YWcoKXtkYXRhTGF5ZXIucHVzaChhcmd1bWVudHMpO30KICAgICAgZ3RhZygnanMnLCBuZXcgRGF0ZSgpKTsKICAgIDwvc2NyaXB0PgogIAogIDxzY3JpcHQgdHlwZT0idGV4dC9qYXZhc2NyaXB0IiA+CiAgICAoZnVuY3Rpb24obSxlLHQscixpLGssYSl7bVtpXT1tW2ldfHxmdW5jdGlvbigpeyhtW2ldLmE9bVtpXS5hfHxbXSkucHVzaChhcmd1bWVudHMpfTsKICAgIG1baV0ubD0xKm5ldyBEYXRlKCk7az1lLmNyZWF0ZUVsZW1lbnQodCksYT1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKHQpWzBdLGsuYXN5bmM9MSxrLnNyYz1yLGEucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoayxhKX0pCiAgICAod2luZG93LCBkb2N1bWVudCwgInNjcmlwdCIsICJodHRwczovL21jLnlhbmRleC5ydS9tZXRyaWthL3RhZy5qcyIsICJ5bSIpOwoKICAgIHltKDI0MDQ5MjEzLCAiaW5pdCIsIHsKICAgICAgZGVmZXI6dHJ1ZSwKICAgICAgdHJhY2tMaW5rczp0cnVlLAogICAgICBhY2N1cmF0ZVRyYWNrQm91bmNlOnRydWUsCiAgICAgIHdlYnZpc29yOmZhbHNlLAogICAgfSk7CiAgPC9zY3JpcHQ+CiAgPG5vc2NyaXB0PgogICAgPGRpdj4KICAgICAgPGltZyBzcmM9Imh0dHBzOi8vbWMueWFuZGV4LnJ1L3dhdGNoLzI0MDQ5MjEzIiBzdHlsZT0icG9zaXRpb246YWJzb2x1dGU7IGxlZnQ6LTk5OTlweDsiIGFsdD0iIiAvPgogICAgPC9kaXY+CiAgPC9ub3NjcmlwdD4KICAKICAgIDxzY3JpcHQgdHlwZT0idGV4dC9qYXZhc2NyaXB0Ij4KICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTsKICAgICAgICAgIGltZy5zcmMgPSAnaHR0cHM6Ly92ay5jb20vcnRyZz9wPVZLLVJUUkctNDIxMzQzLTU3dktFJzsKICAgICAgICB9LCAwKTsKICAgICAgfSk7CiAgICA8L3NjcmlwdD4KICAKPHNjcmlwdCBzcmM9Ii9qcy9hZHMuanMiIG9ubG9hZD0id2luZG93Wyd6aFk0aTRuSjlLJ10gPSB0cnVlIj48L3NjcmlwdD4KPC9ib2R5Pgo8L2h0bWw+Cg==)](http://habreffect.ru/237/35f2fcaad/k4vs1.jpg) Вы когда-нибудь ездили на ленивом слоне? Он идет медленно и сильно раскачивается. И не идет по дороге, а блуждает во всех направлениях, которые сочтет интересными, но если они не совпадают с нужным, то погонщик слону говорит «не, нам не сюда». Так, перепробовав все варианты, слон оказывается в той точке, про которую _не_ сказали «не сюда». Вот и парсер-комбинаторы так же, перепробуют все комбинации вариантов, пока какой-нибудь один из них не сработает. И после каждого отката начинают заново делать одну и ту же работу. <...> Программа в пару строчек разбиралась быстро. В три строчки уже несколько секунд. Пять строчек я не дождался. Запомните, дети, такие парсер-комбинаторы годятся только для очень простых грамматик.

Осталось обнаружить зацикливания парсинга, достичь приемлемого времени работы, и, недурно бы — локализацию ошибки.

С зацикливанием проще: если мы дважды оказались в одном состоянии, не продвинувшись по входному тексту, — значит, окажемся в нём и в третий раз, и сколько угодно. Выходит, нужно для каждой позиции во входном тексте хранить список всех состояний, в которых в этой позиции уже побывали: если второй раз приходим в то же состояние, говорим, «не, хватит, больше туда не пойду».

В качестве бесплатного бонуса получаем «линейное» время работы, если запоминать будем не просто галочку «ага, тут были», а ещё и результат прошлого разбора (развёртка подошла / не подошла); тогда самый худший вариант по времени работы — если в каждой позиции текста побываем во всех возможных состояниях. Если текст длиной _N_ символов, и в

~грамматике~

парсящем выражении _M_ правил (включая альтернативные варианты развёртки каждого нетерминала) — то получаем время работы _O_(_M_\*_N_). Если хитро прищуриться и сделать вид, что _M_ константа — ага, время линейное. Для сравнения, у традиционных LL- и LR-парсеров с предопределённым действием в каждом состоянии точно так же в худшем случае _O_(_M_\*_N_):

```
S: | T1 S ;
T1: T2 ;
T2: T3 ;
...
TM: 't' ;

```

Здесь LR будет после каждого сдвига `'t'` выполнять _M_ свёрток `'t' -> TM -> ... -> T3 -> T2 -> T1`; а LL, перед «съедением» каждого `'t'`, делает _M_ развёрток `T1 -> T2 -> T3 -> ... -> TM -> 't'`.  
Весь вопрос в том, насколько отличается средний случай от худшего: как минимум, «линейный слон» при любом разборе выполняет больше развёрток, чем LL на такой же грамматике.

Другой подвох в расходе памяти. Нам потребуется хранить _M_\*_N_ результатов прошлых развёрток — и это впридачу к тому, что входной текст придётся хранить в памяти весь целиком, потому что слону нужно без конца бегать по нему взад и вперёд. Это при том, что магазинно-автоматные парсеры к уже прочитанному тексту никогда не возвращаются, и поэтому их требования к памяти зависят только от грамматики, но не от текста.  
«Историю одного байта» читали все? Тем более, что одно из самых естественных применений для новых компиляторов — поддержка всяких компактных платформ, где сэкономленная память имеет значение.

И по поводу обнаружения синтаксических ошибок. Наш слон, который на самом деле получил название packrat (_скопидом_), заключает, что в тексте ошибка, когда ни одна развёртка не подошла. Поэтому позиция, в которой ошибка будет обнаружена, может намного предшествовать месту собственно ошибки: предположим парсящее выражение

```
DECL: DECLVAR / DECLFN ;
DECLVAR: TYPE ID ';' ;
DECLFN: TYPE ID '(' ARGS ')' ;

```

— отдалённо напоминающее синтаксис объявлений в Си.  
Если во входном тексте встретили последовательность, которую можно разобрать как `TYPE ID '!'`, то в какой позиции ошибка синтаксиса? Packrat проверит первую развёртку, она не подойдёт, парсер откатывается к началу `TYPE` и пробует вторую развёртку; она тоже не подходит. Получается, ошибка будет обнаружена перед `TYPE`; а что, если `TYPE` — хардкорное выражение на полстроки?  
Логично в качестве позиции ошибки показывать самую правую, до которой сумела добраться хотя бы одна развёртка, — т.е. последнюю позицию, до которой у парсера ещё были надежды, что текст распарсится удачно.  
Предполагаю, что есть реализации packrat, в которых локализация ошибки реализована именно так.

Всё, это был последний пост серии, в котором занимаемся синтаксическим разбором.  
В следующий раз перейдём к семантике, и тогда наш игрушечный язык действительно станет языком _программирования_.
---
created: 2023-03-14T12:13:56 (UTC +03:00)
tags: [компиляция,промежуточный код,генерация кода]
source: https://habr.com/ru/post/99592/
author: Artyom Skrobov
---

# Компиляция. 6: промежуточный код / Хабр

> ## Excerpt
> Первый этап &mdash; разбор синтаксиса нашего джей-скрипа &mdash; пройден; подбираемся к генерации кода.  Начнём с генерации п-кода (промежуточного переносимого псевдокода) &mdash;...

---
Время на прочтение 17 мин

Количество просмотров 9.8K

Первый этап — [разбор синтаксиса](http://habrahabr.ru/blogs/programming/99397/) нашего джей-скрипа — пройден; подбираемся к генерации кода.

Начнём с генерации п-кода (промежуточного переносимого псевдокода) — нечто вроде «абстрактного машинного языка». Его выбирают так, чтобы

-   его было легко генерировать;
-   его было легко обрабатывать.

Обработка п-кода — это, как правило, его переработка в исполнимый машинно-зависимый код. Тем не менее, можно ограничиться лишь генерацией п-кода, и объявить его готовой скомпилированной программой. Запуск такой программы будет, по сути, интерпретацией п-кода. У этого подхода всё больше и больше сторонников; так что и мы для начала ограничимся компиляцией в п-код.

### Далее в посте:

1.  Выбор кода
2.  Компиляция
3.  Выполнение
4.  Backpatching

### Выбор кода

Часто п-код делают стековым (например, MSIL): вообразим себе процессор, внутри которого нет пронумерованных регистров, а есть один большой стек, и все действия выполняются с верхними значениями на стеке. (Те, кому довелось программировать для х87, с такой моделью знакомы.) Стековый код действительно удобно генерировать и удобно выполнять, но не слишком удобно обрабатывать — например, в нём тяжело отслеживать зависимости между командами.

О выборе между стековым и регистровым промежуточным кодом выразительно отзывается [создатель языка Beep](http://dmzlj.livejournal.com/129758.html):

> ###### Регистровый без вариантов:
> 
>   
> Упрощение рантайма. Меньше манипуляций с указателями. Отсутствует понятие переполнения стека. Меньше кода, меньше работы с памятью — меньше места для критических ошибок.  
> Увеличивается сложность компиляции: появляется фаза выделения регистров. В случе исполнения на виртуальной машине нам не важно количество регистров, можем сделать их достаточное количество для того, что бы вообще не делать аллокацию, а просто маппить все параметры и переменные функции на регистры (см. Lua). Если количество параметров будет превышать количество регистров, то можно выделять часть activation record в хипе, но проще сделать так, что бы компилятор предлагал автору такого кода лечить голову.  
> В любом случае, если стоит вопрос упрощения рантайма ценой усложнения компилятора, так и следует поступать.  
> Возможность оптимизации: маппинг N регистров виртуальной машины на регистры процессора. На стековой машине это сделать значительно сложнее.  

Так что и мы вместо стекового возьмём трёхадресный код в духе MIPS:

-   Все команды равной длины (у нас — по 4 байта)
-   Первый байт — номер команды (по отдельному опкоду под каждую возможную операцию)
-   Второй байт — номер регистра для результата _(256 регистров достаточно любому!)_
-   Остаток — либо два номера регистров-операндов, либо непосредственное значение—операнд.

Регистр №0 зарезервируем для хранения нуля: он нам пригодится. Вообще, полезно имено зарезервированный «недействительный» номер регистра, чтобы обозначать «отсутствие регистра вообще».

Кроме команд, соответствующих вычислительным операциям, нужны также:

-   загрузка непосредственного значения в регистр;
-   чтение из памяти в регистр;
-   запись из регистра в память;
-   условный переход;
-   вывод строки или числа;
-   ввод числа;
-   остановка.

Все вычислительные команды принимают по два регистра, а все остальные — непосредственное значение.

Работа с памятью для нас пока не актуальна: если не все переменные удастся разместить в регистрах, значит программисту не повезло. Операции, которых в джей-скрипе пока нет, вроде вызова функций, тем более не закладываем в п-код.

Упорядочим опкоды так, чтобы команды похожей структуры (в плане используемых регистров) шли подряд, и вынесем определение структуры команды в отдельный файл `jsk.h`: она потребуется и компилятору, и интерпретатору.  
`typedef unsigned char regnum;struct command {       enum opcodes {           hlt,           store, // dst>           jz,    // dst>           echo,  // dst>           mov,   // >dst           load,  // >dst           input, // >dst           add,   // src>dst           sub,   // src>dst           mul,   // src>dst           div,   // src>dst           eq,    // src>dst           ne,    // src>dst           ge,    // src>dst           le,    // src>dst           gt,    // src>dst           lt     // src>dst       };`

    `opcodes opcode;       regnum dest;`

`union {           struct {               regnum src1, src2;           };           short imm;       };       command(opcodes opcode, regnum dest, regnum src1, regnum src2) :                   opcode(opcode), dest(dest), src1(src1), src2(src2) {}       command(opcodes opcode, regnum dest, short imm) :                   opcode(opcode), dest(dest), imm(imm) {}   };   `  
Чтобы под опкод действительно выделялся один байт, при компиляции придётся указывать ключ

`-fshort-enums`

### Компиляция

Строки для `echo` будем хранить вместе с кодом программы, в самом конце; одинаковые строки объединим, чтобы хранилась только одна копия. Для этого будем хранить `map` всех строк, где значением будет «идентификатор» строки (её порядковый номер в программе).

Все переменные в джей-скрипе — глобальные. В отдельном `map` будем хранить по имени переменной номер выделенного ей регистра.

В общем, идея та же, что с форматированной распечаткой; только теперь в каждом узле дерева храним не текст, а список команд. Для элементов выражения также храним номер регистра, в котором результат вычисления.

Берём парсер, и поехали: заменяем метод `print()` на аналогичный по сути `emit()`, склеивающий списки команд дочерних узлов в один большой список.

_(340 строк кода вынесены на [http://tyomitch.net.ru/jsk.y.html](http://tyomitch.net.ru/jsk.y.html), чтобы сохранить размер поста в пределах допустимого.)_

Как видим, понадобилось «расщепить» узел `value` на три разных типа: литерал-число, литерал-строка, и ссылка на переменную. При форматировании кода различия между ними были несущественны, но при генерации уже понадобилось их различать.

### Выполнение

Отобразим файл с п-кодом в память, и будем работать с ним, как с массивом структур `command`. Собственно выполнение — это цикл из 4 строк, и реализация функций-команд; большая же часть кода — вспомогательная шелуха.

`#include <fcntl.h>   #include <stdio.h>   #include <stdlib.h>   #include <unistd.h>   #include <sys/mman.h>   #include "jsk.h"int pc = 0;     // индекс команды (не смещение)   bool halted = false;   int mem[1000];  // размер не важен: всё равно пока не пользуемсяtypedef int (*op)(int src1, int src2, int dest, int imm); // все возможные входные значенияconst char* fdata = NULL; // весь прочитанный п-кодextern op ops[]; // объявлен нижеint main(int argc, char** argv) {if(argc!=2) {           printf("Missing pcode file name.\n");           exit(1);       }int fd = open(argv[1], O_RDONLY);       if (fd<0) {           printf("Cannot open pcode file.\n");           exit(1);       }       struct stat finfo;       fstat(fd, &finfo);       fdata = (const char*)mmap(0, finfo.st_size, PROT_READ, MAP_PRIVATE, fd, 0);       if (!fdata) {           printf("Cannot read pcode file.\n");           exit(1);       }const command* pcode = (const command*) fdata;int r[256] = {0}; // registerswhile (!halted) {           command next = pcode[pc++];           r[next.dest] = ops[next.opcode](r[next.src1], r[next.src2], r[next.dest], next.imm);       }`

    `munmap((`

`void*)fdata, finfo.st_size);       close(fd);       return 0;   }int hlt(int src1, int src2, int dest, int imm) { halted = true; return dest; }   int store(int src1, int src2, int dest, int imm) { mem[imm] = dest; return dest; }   int jz(int src1, int src2, int dest, int imm) { if (!dest) pc+=imm; return dest; }   int echo(int src1, int src2, int dest, int imm) { if (imm) printf("%s", fdata+imm); else printf("%d", dest); return dest; }   int mov(int src1, int src2, int dest, int imm) { return imm; }   int load(int src1, int src2, int dest, int imm) { return mem[imm]; }   int input(int src1, int src2, int dest, int imm) { int d; scanf(" %d", &d); return d; }   int add(int src1, int src2, int dest, int imm) { return src1+src2; }   int sub(int src1, int src2, int dest, int imm) { return src1-src2; }   int mul(int src1, int src2, int dest, int imm) { return src1*src2; }   int div(int src1, int src2, int dest, int imm) { return src1/src2; }   int eq(int src1, int src2, int dest, int imm) { return src1==src2; }   int ne(int src1, int src2, int dest, int imm) { return src1!=src2; }   int ge(int src1, int src2, int dest, int imm) { return src1>=src2; }   int le(int src1, int src2, int dest, int imm) { return src1<=src2; }   int gt(int src1, int src2, int dest, int imm) { return src1>src2; }   int lt(int src1, int src2, int dest, int imm) { return src1<src2; }  op ops[] = {hlt, store, jz, echo, mov, load, input, add, sub, mul, div, eq, ne, ge, le, gt, lt};  `

Фанфары! Запускаем первую в мире программу на джей-скрипе:

`[tyomitch@home ~]$ **bison jsk.y**   [tyomitch@home ~]$ **c++ -fshort-enums jsk.tab.c lex.yy.c -o jskc**   [tyomitch@home ~]$ **c++ -fshort-enums jsk.c -o jsk**   [tyomitch@home ~]$ **./jskc < test.jsk > pcode**   [tyomitch@home ~]$ **hexdump -C pcode**   00000000 04 01 00 00 04 02 e8 03 03 00 26 01 03 01 00 00 |..........&.....|   00000010 03 00 a0 00 03 02 00 00 03 00 a7 00 0e 03 01 02 |................|   00000020 02 03 1d 00 07 04 01 02 04 05 02 00 0a 06 04 05 |................|   00000030 03 00 62 01 03 06 00 00 03 00 cc 00 06 07 00 00 |..b.............|   00000040 04 08 01 00 0b 09 07 08 02 09 04 00 04 0a 01 00 |................|   00000050 08 0b 06 0a 07 02 0b 00 02 00 0e 00 04 0c 02 00 |................|   00000060 0b 0d 07 0c 02 0d 04 00 04 0e 01 00 07 0f 06 0e |................|   00000070 07 01 0f 00 02 00 07 00 04 10 03 00 0b 11 07 10 |................|   00000080 02 11 03 00 03 00 46 01 00 00 00 00 02 00 01 00 |......F.........|   00000090 03 00 6a 01 02 00 e1 ff 03 00 ff 00 00 00 00 00 |..j.............|   000000a0 20 d0 b4 d0 be 20 00 2c 20 d0 b0 20 d1 8f 20 d0 | .... ., .. .. .|   000000b0 b1 d1 83 d0 b4 d1 83 20 d1 83 d0 b3 d0 b0 d0 b4 |....... ........|   000000c0 d1 8b d0 b2 d0 b0 d1 82 d1 8c 0a 00 3f 20 20 28 |............?  (|   000000d0 31 3d d0 bc d0 b5 d0 bd d1 8c d1 88 d0 b5 2c 20 |1=............, |   000000e0 32 3d d0 b1 d0 be d0 bb d1 8c d1 88 d0 b5 2c 20 |2=............, |   000000f0 33 3d d0 bf d0 be d0 bf d0 b0 d0 bb 29 20 00 d0 |3=..........) ..|   00000100 92 d1 80 d1 91 d1 88 d1 8c 2c 20 d1 82 d0 b0 d0 |........., .....|   00000110 ba 20 d0 bd d0 b5 20 d0 b1 d1 8b d0 b2 d0 b0 d0 |. .... .........|   00000120 b5 d1 82 21 0a 00 d0 97 d0 b0 d0 b4 d1 83 d0 bc |...!............|   00000130 d0 b0 d0 b9 20 d1 87 d0 b8 d1 81 d0 bb d0 be 20 |.... .......... |   00000140 d0 be d1 82 20 00 d0 a3 d1 80 d0 b0 21 20 d0 af |.... .......! ..|   00000150 20 d0 bc d0 be d0 bb d0 be d0 b4 d0 b5 d1 86 21 | ..............!|   00000160 0a 00 d0 ad d1 82 d0 be 20 00 d0 af 20 d0 bd d0 |........ ... ...|   00000170 b8 d1 87 d0 b5 d0 b3 d0 be 20 d0 bd d0 b5 20 d0 |......... .... .|   00000180 bf d0 be d0 bd d1 8f d0 bb 21 0a 00             |.........!..|   0000018c   [tyomitch@home ~]$ **./jsk pcode**   Задумай число от 0 до 1000, а я буду угадывать   Это 500? (1=меньше, 2=больше, 3=попал) **2**   Это 750? (1=меньше, 2=больше, 3=попал) **2**   Это 875? (1=меньше, 2=больше, 3=попал) **2**   Это 938? (1=меньше, 2=больше, 3=попал) **1**   Это 906? (1=меньше, 2=больше, 3=попал) **1**   Это 890? (1=меньше, 2=больше, 3=попал) **2**   Это 898? (1=меньше, 2=больше, 3=попал) **2**   Это 902? (1=меньше, 2=больше, 3=попал) **1**   Это 900? (1=меньше, 2=больше, 3=попал) **1**   Это 899? (1=меньше, 2=больше, 3=попал) **1**   Врёшь, так не бывает!   `  
Если приглядеться к дампу, то можно заметить, что первые `0xa0` байт занимает п-код (четвёрки байтов), а остаток файла — строки в UTF-8.

### Backpatching

Сейчас в каждом узле дерева хранится список всех соответствующих ему команд, и каждая реализация `emit` включает в себя объединение команд из дочерних узлов — в том самом порядке (слева направо), в котором эти узлы создавались во время парсинга. Можно сэкономить и память на хранение команд, и код на их объединение, если все генерируемые команды сразу же сваливать в результат, а в символах хранить только «метаинформацию» типа номеров регистров.

Самая резкая разница — что теперь нам вообще не потребуется дерево: для каждого символа оказывается достаточно хранить _один скаляр_. Более того: у символов операторов теперь вовсе нет значения — весь результат их разбора немедленно сваливается в вектор готового п-кода; поэтому свёртках, где не генерируется код, даже наследовать ничего не нужно.

Небольшая проблема возникает в конструкциях типа `if` и `while`, где после проверки условия нужно вставить прыжок вперёд, если условие не выполняется; и до конца разбора конструкции неизвестно, на сколько нужно прыгать. Придётся оставить на месте прыжка команду-пустышку, и заполнять её в конце разбора. Такая система однопроходной генерации кода с пустышками, и их последующего «залатывания», называется _backpatching_. Она весьма универсальна, и не только позволяет компилировать все привычные управляющие конструкции, но и упрощает реализацию операторов типа `break`, прыгающих вперёд на неизвестное расстояние.

Чтобы вставить прыжок-пустышку после проверки условия в `if` и `while`, добавим в грамматику _маркер_ — «пустой символ»:

```
OP: 'if' '(' EXPR ')' M OP 'else' M OP ;
  | 'while' '(' EXPR ')' M OP ;
M : ;

```

Трюк в том, что свёртка `M` выполнится после свёртки `EXPR` (которая сгенерирует код проверки условия) и перед свёрткой `OP`, так что в код свёртки `M` как раз и сможем добавить генерацию пустышки. Когда будем сворачивать конструкцию целиком, заполним пустышку прыжком до следующей пустышки (после `if`) либо до конца всего сгенерированного кода (после `else` и `while`).

Расстояние для прыжка вперёд теперь знаем; а как для `while` узнать расстояние для прыжка назад в конце цикла? Ведь раз нет списков команд, значит в коде свёртки не сможем узнать, сколько команд заняла вся конструкция. Придётся завести ещё один маркер `N`, который не генерирует код, а просто запоминает адрес нужного места:

```
OP: 'while' N '(' EXPR ')' M OP ;
M : ;
N : ;

```

Дополнительное преимущество новой системы — что для каждой генерируемой команды сразу известен её адрес, так что для строк сможем хранить не временные «идентификаторы», а списки всех ссылок. Это упростит подстановку адресов строк на заключительном этапе генерации п-кода.

`%{       #include <iostream>       #include <vector>       #include <list>       #include <map>       extern int yylineno;       extern int yylex();       void yyerror(char *s) {         std::cerr << s << ", line " << yylineno << std::endl;         exit(1);       }       #include "jsk.h"       struct arg_t {           regnum dest;     // if numeric           std::string str; // if literal       };       typedef struct {           std::string str;         // tokens           regnum dest;             // expr           arg_t arg;           std::list<arg_t> args;           int addr;                // markers           char null;               // op (no data)       } YYSTYPE;       #define YYSTYPE YYSTYPE       #define TOKENPASTE(x, y) x ## y       #define TOKENPASTE2(x, y) TOKENPASTE(x, y)       #define foreach(i, list) typedef typeof(list) TOKENPASTE2(T,__LINE__); \                           for(TOKENPASTE2(T,__LINE__)::iterator i = list.begin(); i != list.end(); i++)       template<typename L>       inline void append(L& list1, L& list2) {           list1.splice(list1.end(), list2, list2.begin(), list2.end());       }`

    `std::vector`

`<command> pcode;       std::map<std::string,regnum> vars;       std::map<std::string,std::list<int> > strings;       regnum lastreg = 0;       inline regnum newreg() {           if (!++lastreg)               yyerror("Too many registers used.");           return lastreg;       }inline int emit(const command& cmd) {           pcode.push_back(cmd);           return pcode.size()-1;       }       inline int emit(command::opcodes opcode, regnum dest, regnum src1, regnum src2) {           return emit(command(opcode, dest, src1, src2));       }       inline int emit(command::opcodes opcode, regnum dest, short imm) {           return emit(command(opcode, dest, imm));       }       inline void fix(int index, command::opcodes opcode, regnum dest, short imm) {           pcode[index] = command(opcode, dest, imm);       }   %}%token IF ELSE WHILE EXIT   %token EQ LE GE NE   %token STRING NUM ID%type<str> ID NUM STRING   %type<dest> EXPR EXPR1 EXPR2 TERM VAL   %type<arg> ARG   %type<args> ARGS   %type<null> OPS OP1 OP2 OP   %type<addr> M N%%PROGRAM: OPS    { emit(command::hlt, 0,0); }   ;OPS:    OP      // no action   |       OPS OP  // no action   ;OP1:    '{' OPS '}'                     {}   |       EXPR ';'                        {}   |       IF '(' EXPR ')' M OP1 ELSE M OP1{ fix($5, command::jz, $3, $8-$5);                                             fix($8, command::jz, 0, pcode.size()-1-$8);                                           }   |       WHILE N '(' EXPR ')' M OP1      { fix($6, command::jz, $4, emit(command::jz,0,$2-pcode.size()-1) -$6); }   |       EXIT ';'                        { emit(command::hlt, 0,0); }   ;OP2:    IF '(' EXPR ')' M OP            { fix($5, command::jz, $3, pcode.size()-$5); }   |       IF '(' EXPR ')' M OP1 ELSE M OP2{ fix($5, command::jz, $3, $8-$5);                                             fix($8, command::jz, 0, pcode.size()-1-$8);                                           }   |       WHILE N '(' EXPR ')' M OP2      { fix($6, command::jz, $4, emit(command::jz,0,$2-pcode.size()-1) -$6); }   ;OP:     OP1 | OP2 ;             // no actionM:                              { $$ = emit(command::hlt, 0,0); } // dummy   ;N:                              { $$ = pcode.size(); }   ;EXPR:   EXPR1                   // inherit   |       ID '=' EXPR             { $$ = $3;                                     if(vars[$1])                                           emit(command::add, vars[$1], $3, 0);                                     else                                           vars[$1] = $3; // new var                                   }   EXPR1:  EXPR2                   // inherit   |       EXPR1 EQ EXPR2          { $$ = newreg(); emit(command::eq, $$, $1, $3); }   |       EXPR1 LE EXPR2          { $$ = newreg(); emit(command::le, $$, $1, $3); }   |       EXPR1 GE EXPR2          { $$ = newreg(); emit(command::ge, $$, $1, $3); }   |       EXPR1 NE EXPR2          { $$ = newreg(); emit(command::ne, $$, $1, $3); }   |       EXPR1 '>' EXPR2         { $$ = newreg(); emit(command::gt, $$, $1, $3); }   |       EXPR1 '<' EXPR2         { $$ = newreg(); emit(command::lt, $$, $1, $3); }   ;EXPR2:  TERM                    // inherit   |       EXPR2 '+' TERM          { $$ = newreg(); emit(command::add, $$, $1, $3); }   |       EXPR2 '-' TERM          { $$ = newreg(); emit(command::sub, $$, $1, $3); }   ;TERM:   VAL                     // inherit   |       TERM '*' VAL            { $$ = newreg(); emit(command::mul, $$, $1, $3); }   |       TERM '/' VAL            { $$ = newreg(); emit(command::div, $$, $1, $3); }   ;VAL:    NUM                     { $$ = newreg(); emit(command::mov, $$, atoi($1.c_str())); }   |       '-' VAL                 { $$ = newreg(); emit(command::sub, $$, 0, $2); }   |       '!' VAL                 { $$ = newreg(); emit(command::eq, $$, 0, $2); }   |       '(' EXPR ')'            { $$ = $2; }   |       ID                      { if(vars[$1])                                           $$ = vars[$1];                                     else                                           yyerror("Undefined variable");                                   }   |       ID '(' ARGS ')'         { if(!$1.compare("input")) {                                       if($3.size())                                           yyerror("Input: too many arguments");                                       $$ = newreg();                                       emit(command::input, $$, 0);                                     } else if (!$1.compare("echo")) {                                       if(!$3.size())                                           yyerror("Input: too many arguments");                                       $$ = 0;                                       foreach(i, $3)                                           if(!i->dest) // string                                               strings[i->str].push_back(emit(command::echo, 0, 0));                                           else                                               emit(command::echo, i->dest, 0);                                     } else                                           yyerror("Undefined function");                                   }   ;ARGS:                           { $$.clear(); }   |       ARG                     { $$.clear(); $$.push_back($1); }   |       ARGS ',' ARG            { $$ = $1; $$.push_back($3); }   ;ARG:    EXPR                    { $$.dest = $1; }   |       STRING                  { $$.str=$1; $$.dest=0; }   ;%%int main() {           yyparse();           int offset = pcode.size()*sizeof(command);           foreach(i, strings) {                   foreach(j, i->second) // all refs                           pcode[*j].imm = offset;                   offset += i->first.length();                   offset++;           }           foreach(i, pcode)   // dump code                   write(1, &*i, sizeof(*i));           foreach(i, strings) // dump strings                   write(1, i->first.c_str(), i->first.length()+1);}   `  
Код компилятора сократился почти вдвое, а компилирует он точно так же, как и прежде.  
Если нет разницы, зачем писать больше?
---
created: 2023-03-14T12:14:16 (UTC +03:00)
tags: [компиляция,генерация кода,оптимизация кода]
source: https://habr.com/ru/post/99595/
author: Artyom Skrobov
---

# Компиляция. 7: назначение регистров / Хабр

> ## Excerpt
> File names are infinite in length, where infinity is set to 255 characters. --Peter Collinson: The Unix File System Итак, у нас есть программа на п-коде, и в её...

---
Время на прочтение 18 мин

Количество просмотров 4.9K

> File names are infinite in length, where infinity is set to 255 characters.  
> _\--Peter Collinson: The Unix File System_

Итак, у нас есть программа на п-коде, и в её распоряжении неограниченное количество регистров (т.е. 255). Число регистров у реального процессора куда меньше (предположим, четыре). Что будем делать?

### Далее в посте:

1.  Разбор п-кода
2.  Время жизни
3.  Реализация
4.  Простые оптимизации
5.  Расщепление версий
6.  Работа с памятью
7.  Что получилось?

### Разбор п-кода

В прошлом посте был дамп скомпилированной программы. Её 40 команд несложно расшифровать:

```
00 mov   r01, 0
01 mov   r02, 0x3e8
02 echo  0x126
03 echo  r01
04 echo  0xa0
05 echo  r02
06 echo  0xa7
07 le    r03, r01, r02
08 jz    r03, +0x1d (=0x26)
09 add   r04, r01, r02
0a mov   r05, 2
0b div   r06, r04, r05
0c echo  0x162
0d echo  r06
0e echo  0xcc
0f input r07
10 mov   r08, 1
11 eq    r09, r07, r08
12 jz    r09, +4 (=0x17)
13 mov   r0a, 1
14 sub   r0b, r06, r0a
15 add   r02, r0b, 0
16 jz    0,   +e (=0x25)
17 mov   r0c, 2
18 eq    r0d, r07, r0c
19 jz    r0d, +4 (=0x1e)
1a mov   r0e, 1
1b add   r0f, r06, r0e
1c add   r01, r0f, 0
1d jz    0,   +7 (=0x25)
1e mov   r10, 3
1f eq    r11, r07, r10
20 jz    r11, +3 (=0x24)
21 echo  0x146
22 hlt
23 jz    0,   +1 (=0x25)
24 echo  0x16a
25 jz    0,   -0x1f (=7)
26 echo  0xff
27 hlt

```

Видно, что не все регистры используются одновременно: большинство хранят промежуточные значения, которые нужны только для следующей команды. Например, `r03` используется только в командах `07-08`, а `r0f` только в командах `1b-1c`. Значит, нет никаких препятствий задействовать для хранимых значений один и тот же физический регистр: в командах `07-08` он будет использоваться для одного значения, а в `1b-1c` — для другого. Любые два регистра, которые не используются _одновременно для разных значений_, можно объединить в один физический регистр.

Есть небольшая тонкость по поводу определения «используются одновременно для разных значений». Во-первых, нельзя считать временем жизни регистра просто промежуток от его первого упоминания до последнего: код может содержать прыжки во все стороны, например:

```
   ...
10 mov  r, 42
11 jz   0, 20
12 echo r
   ...
20 ...
   ...
30 jz   0, 12
   ...

```

Даже хотя `r` упоминается только в командах 10-12, он неявно используется и в команде 20, потому что после неё возможен прыжок обратно на 12; и значит, `r` нельзя объединять с другими регистрами, используемыми в команде 20.

Вторая тонкость:

```
   ...
10 mov  r, 42
11 echo r
   ...
20 ...
   ...
30 mov  r, 24
31 echo r
   ...

```

В команде 20 регистр `r` на самом деле не используется, хотя упоминается и перед этим (10-11), и после этого (30-31). Можем хранить в нём любые другие значения, потому что перед следующим использованием (31) значение ему будет присвоено по-новой. В принципе, мы даже можем назначить разные физические регистры для `r` в 10-11 и в 31-31, потому что значения всё равно будут храниться разные. Но для этого нужно обнаружить, что у `r` две независимые «версии», и обрабатывать их по-отдельности.

### Время жизни

Определить набор команд, в которых регистр используется, можно итеративно:

-   регистр нужен команде, которая _читает_ его значение;
-   если из команды A можно перейти на B (непосредственно или прыжком), и регистр нужен B, то он нужен и А;
-   регистр не нужен команде, которая _задаёт_ его значение.

Для каждой команды определяем набор регистров, которые нужны ей «на входе» и «на выходе», и применяем три правила до тех пор, пока эти наборы не установятся. Вот что получим для нашей программы:

```
             номер итерации: 1(вход/вых) 2(вход/выход)       3(вход/выход)       4(вход/выход)     ...    итог(вход/выход)
00 mov   r01, 0                                                                                                    /r01
01 mov   r02, 0x3e8                                                                    /r01                     r01/r01,r02
02 echo  0x126                                 /r01             r01/r01             r01/r01                 r01,r02/r01,r02
03 echo  r01                    r01/        r01/                r01/                r01/r02                 r01,r02/r01,r02
04 echo  0xa0                                  /r02             r02/r02             r02/r02                 r01,r02/r01,r02
05 echo  r02                    r02/        r02/                r02/                r02/r01,r02             r01,r02/r01,r02
06 echo  0xa7                                  /r01,r02     r01,r02/r01,r02     r01,r02/r01,r02             r01,r02/r01,r02
07 le    r03, r01, r02      r01,r02/    r01,r02/r03         r01,r02/r03         r01,r02/r01,r02,r03         r01,r02/r01,r02,r03
08 jz    r03, +0x1d (=0x26)     r03/        r03/r01,r02 r01,r02,r03/r01,r02 r01,r02,r03/r01,r02         r01,r02,r03/r01,r02
09 add   r04, r01, r02      r01,r02/    r01,r02/            r01,r02/            r01,r02/r04                 r01,r02/r01,r02,r04
0a mov   r05, 2                                /r04,r05         r04/r04,r05         r04/r04,r05         r01,r02,r04/r01,r02,r04,r05
0b div   r06, r04, r05      r04,r05/    r04,r05/            r04,r05/            r04,r05/r06         r01,r02,r04,r05/r01,r02,r06
0c echo  0x162                                 /r06             r06/r06             r06/r06             r01,r02,r06/r01,r02,r06
0d echo  r06                    r06/        r06/                r06/                r06/                r01,r02,r06/r01,r02,r06
0e echo  0xcc                                                                                           r01,r02,r06/r01,r02,r06
0f input r07                                                                           /r07             r01,r02,r06/r01,r02,r06,r07
10 mov   r08, 1                                /r07,r08         r07/r07,r08         r07/r07,r08     r01,r02,r06,r07/r01,r02,r06,r07,r08
11 eq    r09, r07, r08      r07,r08/    r07,r08/r09         r07,r08/r09         r07,r08/r09     r01,r02,r06,r07,r08/r01,r02,r06,r07,r09
12 jz    r09, +4 (=0x17)        r09/        r09/                r09/                r09/r06,r07 r01,r02,r06,r07,r09/r01,r02,r06,r07
13 mov   r0a, 1                                /r06,r0a         r06/r06,r0a         r06/r06,r0a             r01,r06/r01,r06,r0a
14 sub   r0b, r06, r0a      r06,r0a/    r06,r0a/r0b         r06,r0a/r0b         r06,r0a/r0b             r01,r06,r0a/r01,r0b
15 add   r02, r0b, 0            r0b/        r0b/                r0b/                r0b/                    r01,r0b/r01,r02
16 jz    0,   +e (=0x25)                                                                                    r01,r02/r01,r02
17 mov   r0c, 2                                /r07,r0c         r07/r07,r0c         r07/r07,r0c     r01,r02,r06,r07/r01,r02,r06,r07,r0c
18 eq    r0d, r07, r0c      r07,r0c/    r07,r0c/r0d         r07,r0c/r0d         r07,r0c/r0d     r01,r02,r06,r07,r0c/r01,r02,r06,r07,r0d
19 jz    r0d, +4 (=0x1e)        r0d/        r0d/                r0d/                r0d/r06,r07 r01,r02,r06,r07,r0d/r01,r02,r06,r07
1a mov   r0e, 1                                /r06,r0e         r06/r06,r0e         r06/r06,r0e             r02,r06/r02,r06,r0e
1b add   r0f, r06, r0e      r06,r0e/    r06,r0e/r0f         r06,r0e/r0f         r06,r0e/r0f             r02,r06,r0e/r02,r0f
1c add   r01, r0f, 0            r0f/        r0f/                r0f/                r0f/                    r02,r0f/r01,r02
1d jz    0,   +7 (=0x25)                                                               /r01,r02             r01,r02/r01,r02
1e mov   r10, 3                                /r07,r10         r07/r07,r10         r07/r07,r10         r01,r02,r07/r01,r02,r07,r10
1f eq    r11, r07, r10      r07,r10/    r07,r10/r11         r07,r10/r11         r07,r10/r11         r01,r02,r07,r10/r01,r02,r11
20 jz    r11, +3 (=0x24)        r11/        r11/                r11/                r11/                r01,r02,r11/r01,r02
21 echo  0x146
22 hlt
23 jz    0,   +1 (=0x25)                                                               /r01,r02             r01,r02/r01,r02
24 echo  0x16a                                                                         /r01,r02             r01,r02/r01,r02
25 jz    0,   -0x1f (=7)                       /r01,r02     r01,r02/r01,r02     r01,r02/r01,r02             r01,r02/r01,r02
26 echo  0xff
27 hlt

```

По поводу отдельных итераций:

1.  На входе каждой команды — используемые ей регистры; (правило №1)
2.  На выход каждой команды копируем вход достижимых из неё команд; (правило №2)
3.  На вход каждой команды копируем её выход, исключая записанный командой регистр; (правило №3)
4.  На выход каждой команды копируем вход достижимых из неё команд; (правило №2)

Далее правила №2 и №3 повторяются поочерёдно.

После нескольких итераций получаем окончательную разметку «живучести регистров» — какие регистры нужны каждой команде. Тогда можем переименовывать регистры п-кода в физические — например, «по-жадному»: берём «самый нужный» регистр (нужный наибольшему количеством команд); переименовываем в физический, который ещё не занят в соответствующих командах; повторяем.  
Оптимальный выбор, каким п-регистрам следует предоставить физические, чтобы хватило на как можно больше, — возможен только полным перебором: эта задача равносильна «раскраске графа в минимум цветов», про которую математики верят, что для неё не существует эффективного решения. Наше «жадное» приближение — не самое худшее из возможных.

Что делать, если для очередного п-регистра не окажется свободного физического? Например, в нашем коде есть команды (10-12, 17-19), использующие по 5 п-регистров: как минимум одному из них места не хватит. Понятно, что придётся хранить его в памяти.  
Но просто сказать регистру «тебе не повезло, ты будешь храниться в памяти» мало: ведь команды нашего п-кода не умеют работать со значениями из памяти, равно как и команды большинства реальных процессоров. Необходимо на время использования доставать значение из памяти в регистр. Только в какой? Ведь потому и убрали значение в память, что все регистры заняты!

На этом месте выученная мной теория заканчивается, и идут догадки и эвристики. Я решил перед командой, на которую не хватает регистров, «выливать в память» лишние регистры, а после — читать их из памяти обратно. Тем самым, во «времени жизни» вылитых регистров появится дырка на месте этой команды, и в этой дырке сможем использовать освободившиеся регистры для других целей.

Чтобы можно было «раздвигать» код и вставлять в него команды чтения/записи в память, придётся чуточку поменять промежуточный формат: теперь это будет связанный список, и цель прыжка будет храниться не как смещение, а как указатель (превращая список в орграф). Во время генерации п-кода, для [бэкпатчинга](http://habrahabr.ru/blogs/programming/99592/) нам понадобится обращаться к командам и по индексу; для этого заведём отдельный вектор смещений.  
    `typedef std::list<struct commandn>::iterator pcommandn;       struct commandn {           command cmd;           pcommandn tgt; // цель прыжка           commandn(const command& cmd) : cmd(cmd), tgt(NULL) {}       };`

    `std::list<commandn> pcode;       std::vector<pcommandn> pcodeidx;`

`inline int emit(const command& cmd) {           pcodeidx.push_back(pcode.insert(pcode.end(), commandn(cmd)));           return pcode.size()-1;       }       inline int emit(command::opcodes opcode, regnum dest, regnum src1, regnum src2) {           return emit(command(opcode, dest, src1, src2));       }       inline int emit(command::opcodes opcode, regnum dest, short imm) {           return emit(command(opcode, dest, imm));       }       inline void fix(int index, command::opcodes opcode, regnum dest, short imm) {           *pcodeidx[index] = commandn(command(opcode, dest, imm));       }   `  
Указатели на цель прыжка сложно заполнять во время генерации п-кода: в момент создания прыжков уже известен индекс цели, но ещё неизвестно, какая там будет стоять команда; ставить указатель на ещё не созданную команду проблематично. Поэтому после конца разбора и генерации п-кода обойдём сгенерированный код, и расставим указатели прыжков; потом выполним всю нужную работу с распределением регистров; и в конце, перед дампом p-кода в файл, нужно будет его «сериализовать» — определить окончательный индекс каждой команды, и заполнить смещения прыжков. Ради этого, добавим в `struct commandn` поле `int index;`

`int main() {       yyparse();       // расставить цели прыжков       for(int i=0; i<pcode.size(); i++)          if(pcodeidx[i]->cmd.opcode==command::jz)               pcodeidx[i]->tgt = pcodeidx[i+1+pcodeidx[i]->cmd.imm];// обработка / оптимизация       // ...// сериализация / расстановка смещений       int index = 0;       foreach(i, pcode) i->index = index++;       foreach(i, pcode)           if (i->cmd.opcode==command::jz)               i->cmd.imm = i->tgt->index-i->index-1;// запись п-кода в файл       // ...   }   `  
Дело за малым: реализовать «обработку / оптимизацию». Займёт она, как и можно ожидать, большую часть всего кода компилятора.

### Реализация

Для назначения регистров будем хранить для каждой команды (прямо в `struct commandn`) множества живых на входе и на выходе регистров: отдельно — регистров п-кода, для определения времени жизни; и отдельно — физических регистров, для определения сочетаемости при собственно назначении.  
    `typedef std::set<regnum> aliveset;       enum physreg { firstp = 1, lastp = 4 };       typedef std::set<physreg> alivesetp;       struct commandn {           // ...           aliveset onenter, onexit;       // liveness check           alivesetp onenterp, onexitp;    // phys reg allocation           // ...       };`  
Ещё одна полезная вещь — определение по опкоду, какие регистры используются командой:  
    `inline bool hasnext(pcommandn cmd) {           return (cmd->cmd.opcode!=command::hlt &&!                   (cmd->cmd.opcode==command::jz && !cmd->cmd.dest));       }       inline bool has2src(pcommandn cmd) {           return cmd->cmd.opcode>=command::add;       }       inline bool writesdest(pcommandn cmd) {           return cmd->cmd.opcode>=command::mov;       }       inline bool readsdest(pcommandn cmd) {           return cmd->cmd.opcode>=command::store &&                   cmd->cmd.opcode<=command::echo;       }`  
После этого, по приведённой выше схеме, рассчитываем для каждой команды множество нужных на входе и на выходе регистров; заодно считаем, сколько раз нужен каждый регистр, для жадного назначения.  
`std::vector<int> liveness() { // returns usecount       std::vector<int> usecount(lastreg+1);       bool changed = false;       // rule 1       foreach(i, pcode) {           i->onenter = i->onexit = aliveset();           if (has2src(i)) {               if (i->cmd.src1) {                   usecount[i->cmd.src1]++;                   i->onenter.insert(i->cmd.src1);               }               if (i->cmd.src2) {                   usecount[i->cmd.src2]++;                   i->onenter.insert(i->cmd.src2);               }           } else if (readsdest(i) && i->cmd.dest) {               usecount[i->cmd.dest]++;               i->onenter.insert(i->cmd.dest);           }           if (i->onenter.size())               changed = true;       }       while (changed) {           changed = false;           foreach2(i, pcode, next) {               int oldsize = i->onenter.size()+i->onexit.size();               // rule 2 (next command)               if (hasnext(i))                   i->onexit.insert(next->onenter.begin(), next->onenter.end());               // rule 2 (jmp target)               if (i->cmd.opcode==command::jz)                   i->onexit.insert(i->tgt->onenter.begin(), i->tgt->onenter.end());               // rule 3               i->onenter.insert(i->onexit.begin(), i->onexit.end());               if (writesdest(i))                   i->onenter.erase(i->cmd.dest);if (i->onenter.size()+i->onexit.size() != oldsize)                   changed = true;           }       }       return usecount;   }   `  
Использованный макрос `foreach2` позволяет в теле цикла смотреть и на текущий, и на следующий за ним элемент:  
`#define foreach2(i, list, next) typedef typeof(list) TOKENPASTE2(T,__LINE__); \           for(TOKENPASTE2(T,__LINE__)::iterator next = list.begin(), i=next++; i != list.end(); i=next, next++)   `  
В принципе, можно было сократить общее число итераций, если обходить команды не «сверху вниз», а «снизу вверх», потому что нужность «распространяется» от каждой команды к предыдущим; обход «сверху вниз» выбран ради упрощения кода. В самом худшем случае, для кода длиной _N_ команд потребуется 2_N_ итераций (на каждой итерации нужность распространяется на расстояние полкоманды). Для `test.jsk` хватило 35 итераций, потому что прыжки сокращают расстояния.

Наконец, то, зачем мы всё это делали:  
    `// обработка / оптимизация:       while(1) { // пока все регистры не уложатся в физические// предварительная обработка           // ...`

        `std::vector<`

`int> usecount = liveness();           std::vector<physreg> physmap(lastreg+1);           foreach(i, pcode)               i->onenterp = i->onexitp = alivesetp();           while(1) {               // самый нужный регистр               std::vector<int>::iterator max = std::max_element(usecount.begin(), usecount.end());               if (!*max) break; // все регистры размещены               *max = 0;               regnum r = max - usecount.begin();               // поищем физ. регистр для п-регистра №r               std::vector<int> collisions(lastp); // 0-based               for (physreg p=firstp; p<=lastp; p=(physreg)(p+1)) { // error: ISO C++ forbids incrementing an enum                   foreach(i, pcode) {                       if (contains(i->onenter, r) && contains(i->onenterp, p))                           collisions[p-1]++;                       if (contains(i->onexit, r) && contains(i->onexitp, p))                           collisions[p-1]++;                   }                   if (collisions[p-1]) continue; // попробовать другой физ. рег                   physmap[r] = p;                   // разместили п-регистр №r в физическом №p                   foreach(i, pcode) {                       if (contains(i->onenter, r))                           i->onenterp.insert(p);                       if (contains(i->onexit, r))                           i->onexitp.insert(p);                   }                   break; // успешное назначение               }               if (physmap[r]) continue; // нашлось куда разместить               // не хватило физ. регистра для п-регистра №r               // эвристика: найдём команду, в которой не хватает регистров               foreach2(i, pcode, next)                   if ((i->cmd.opcode!=command::load && i->cmd.opcode!=command::store) &&                           ((contains(i->onenter, r) && i->onenterp.size()==lastp) ||                            (contains(i->onexit, r) && i->onexitp.size()==lastp))) {                       // найдём, какой регистр можно вылить, и выльем                       // ...                       goto afterspill;                   }               // эвристика не сработала: что же делать?               yyerror("don't know how to proceed");           }           // все регистры размещены; переименовываем           foreach(i, pcode) {               i->cmd.dest = physmap[i->cmd.dest];               if (has2src(i)) {                   i->cmd.src1 = physmap[i->cmd.src1];                   i->cmd.src2 = physmap[i->cmd.src2];               }           }           break;afterspill: // пост-обработка после "выливания регистра"       }   `  
Ещё не углубляясь в то, как именно мы выливаем регистр, стоит упомянуть, что у приведённого кода масса проблем. Во-первых, эвристика работает только в самых простых случаях; чаще встречаются ситуации навроде

```
   ...
10 нужны r1,r2,r3,r4
   ...
20 нужны r1,r3,r4,r5
   ...
30 нужны r2,r3,r4,r5
   ...

```

Регистру `r5` не хватает физического, потому что все физические израсходовались на `r1,r2,r3,r4`; но нет ни одной команды, где все пять регистров нужны одновременно.

Более жёсткая проблема — что каждый вылив засоряет программу бесполезными парами `store/load`, и их нужно вычищать — иначе используемые в них регистры создают достаточно «шума», чтоб регистров не хватило больше ни на что.

Ещё одна идея: дырка во времени жизни, образовавшаяся из-за вылива, может разделить исходный п-регистр на две независимых «версии», которые можно размещать в разных физических регистрах. Ради гибкости нашей системы, стоит реализовать расщепление версий: тогда с каждой итерацией внешнего цикла времена жизни регистров будут сокращаться, и распределять им физические будет становиться всё проще и проще.

И, раз уж мы пошли удалять лишние `load` и `store`, удалим заодно и прочие лишние команды. Учитывая, что у операций нашего п-кода нет других побочных эффектов, кроме вычисления регистра с результатом, — можно удалять команды, результат которых не жив на выходе. Может быть, программист присвоил значение неиспользуемой переменной, или употребил оператор наподобие `(2+2);`  
Удаляем всё подряд — так удалим до кучи недостижимый код (например, jz после hlt), и сожмём цепочки прыжков (заменим прыжок на прыжок одним прыжком).

Для удаления команды, чтобы не искать и не исправлять все прыжки на неё, удобно заменить её на `nop`; в качестве него назначим безусловный прыжок на следующую команду (`jz r00, +0`). Выгода в том, что на следующей итерации прыжок на `nop` сожмётся по цепочке, и сам `nop` вычистится как недостижимая команда.

### Простые оптимизации

Для обнаружения недостижимых команд пользуемся обходом в глубину; чтобы следить, какие команды уже обошли, в `struct commandn` добавляем новое поле `int reachcnt;`  
Нам хватило бы и булева поля; но «степень захода» каждой команды, может статься, ещё пригодится когда-нибудь потом.  
`void markReachable(pcommandn cmd) {       while(!cmd->reachcnt++) {           if (cmd->cmd.opcode==command::jz)               markReachable(cmd->tgt);           if (hasnext(cmd))               cmd++;           else               break;       }   }void nopOut(pcommandn cmd) {       pcommandn next = cmd; next++;       cmd->cmd = command(command::jz, 0,0);       cmd->tgt = next;   }void simpleopt() {       // сжать цепочки прыжков       foreach(i, pcode)           if(i->cmd.opcode==command::jz)               while(i->tgt->cmd.opcode==command::jz && !i->tgt->cmd.dest)                   i->tgt = i->tgt->tgt;       // удалить недостижимый код       foreach(i, pcode) i->reachcnt = 0;       markReachable(pcode.begin());       foreach2(i, pcode, next)           if(!i->reachcnt)               pcode.erase(i);       // удалить все nop: уже не могут быть целью прыжка       foreach2(i, pcode, next)           if(i->cmd.opcode==command::jz &&                   !i->cmd.dest && i->tgt==next)               pcode.erase(i);   }// предварительная обработка в цикле назначения регистров:       simpleopt();       // удалить команды с неживым результатом       liveness();       bool changed = false;       foreach(i, pcode)           if(writesdest(i) && !contains(i->onexit, i->cmd.dest)) {               nopOut(i);               changed = true;           }       if (changed) continue;       // расщепление версий       // ...   `

### Расщепление версий

Если в «интервале нужности» регистра есть разрыв, т.е. значение из одного набора команд никогда не проникает в другой набор, — значит, регистр можно «расщепить» на пару регистров с более короткими временами жизни.  
Для выделения безразрывных фрагментов из времён жизни пригодится ещё один графовый алгоритм: поиск компонент связности.  
Стремимся больше к ясности кода, чем к его эффективности; поэтому у нас пвг внутри пвг, и слияние компонент выполняется обходом всего графа.

В `struct commandn` потребуется ещё одно поле, последнее на сегодня: `std::map<regnum,regnum> version;`  
В нём будем хранить для каждой команды соответствия «п-регистр -> номер версии».  
Если регистр в команде используется, а соответствия в `version` ещё нет — значит, обход до этой команды ещё не дошёл.  
Для внешнего же пвг, чтобы не заводить новое поле, пользуемся тем же `reachcnt`, что и в `markReachable()`  
`std::map<regnum,regnum> renameto;       // для слияния компонентvoid versionizeReg(pcommandn cmd, regnum r, regnum rv) { // переименовать r в rv во всей компоненте       while(!contains(cmd->version, r) &&               (contains(cmd->onenter, r) || contains(cmd->onexit, r))) {           // переименование           cmd->version[r] = renameto[rv];           if (cmd->cmd.dest==r) cmd->cmd.dest=renameto[rv];           if (has2src(cmd)) {               if (cmd->cmd.src1==r) cmd->cmd.src1=renameto[rv];               if (cmd->cmd.src2==r) cmd->cmd.src2=renameto[rv];           }           if (!contains(cmd->onexit,r)) return; // больше не живой           if (cmd->cmd.opcode==command::jz &&                   contains(cmd->tgt->onenter, r)) {               versionizeReg(cmd->tgt, r, rv);           }           if (hasnext(cmd)) {               cmd++;               if (contains(cmd->onenter, r))                   continue;           }           return; // зашли в тупик       }       // натолкнулись на другую версию?       if(contains(cmd->version, r) && cmd->version[r]!=renameto[rv]) {           // слить renameto[rv] и cmd->version[r]           regnum from = std::max(cmd->version[r], renameto[rv]),                  to = std::min(cmd->version[r], renameto[rv]);           renameto[from] = to;           foreach(i, pcode) {               if (i->cmd.dest==from) i->cmd.dest = to;               if (has2src(i)) {                   if (i->cmd.src1==from) i->cmd.src1 = to;                   if (i->cmd.src2==from) i->cmd.src2 = to;               }               if(contains(i->version, r) && i->version[r]==from)                   i->version[r] = to;           }       }   }void versionize(pcommandn cmd) {       while(!cmd->reachcnt++) {           // versionize registers that live on exit           foreach(r, cmd->onexit)               if(!contains(cmd->version, *r)) {                   regnum rv = newreg();                   renameto[rv] = rv;                   versionizeReg(cmd, *r, rv);               }           if (cmd->cmd.opcode==command::jz)               versionize(cmd->tgt);           if (hasnext(cmd))               cmd++;           else               break;       }   }// расщепление версий:       foreach(i, pcode) {           i->version.clear();           i->reachcnt = 0;       }       renameto.clear();       int lastbasereg = lastreg;       versionize(pcode.begin());       // переименовать версии, чтоб начинались с 1       foreach(i, pcode) {           if (i->cmd.dest) i->cmd.dest-=lastbasereg;           if (has2src(i)) {               if (i->cmd.src1) i->cmd.src1-=lastbasereg;               if (i->cmd.src2) i->cmd.src2-=lastbasereg;           }       }       lastreg -= lastbasereg;   `  
Осталось реализовать собственно вылив регистра. Конкретизируем эвристику: вылить можно любой регистр, который жив, но командой не используется.  
`regnum spillable(pcommandn cmd) { // найти регистр, который можно вылить       aliveset alive;       alive.insert(cmd->onenter.begin(), cmd->onenter.end());       alive.insert(cmd->onexit.begin(), cmd->onexit.end());       alive.erase(cmd->cmd.dest);       if (has2src(cmd)) {           alive.erase(cmd->cmd.src1);           alive.erase(cmd->cmd.src2);       }       if (!alive.size()) return 0;       return *alive.begin();   }   `  
В отдельном `map` будем хранить по номеру регистра «адрес» его копии в памяти, чтобы все выливы регистра попадали в одно и то же место. Адрес присваивается регистру лишь в момент первого вылива.  
`// spill slots   std::map<regnum,int> spill;   int lastspill = 0;void spillAt(pcommandn cmd, regnum victim, pcommandn next) {       // найти / выделить слот       int spslot = spill[victim];       if(!spslot) {           spslot = ++lastspill;           spill[victim] = spslot;       }       // вставить store перед и load после       pcommandn me = pcode.insert(next, *cmd);       cmd->cmd = command(command::store, victim, spslot);       commandn load(command(command::load, victim, spslot));       if(hasnext(me))           pcode.insert(next, load);       if(me->cmd.opcode==command::jz)           me->tgt = pcode.insert(me->tgt, load);   }   `  
Поскольку команда заменяется тройкой `store-cmd-load`, нужно, чтобы существующие прыжки на команду прыгали на вставленный перед ней `store`. Чтобы не искать такие прыжки по всему коду, мы вставляем _следующей_ командой копию `cmd`, а потом _оригинал_ команды заменяем на `store`.  
Аналогично, если команда — условный переход, то нужно, чтобы `load` выполнился при обоих исходах; поэтому и добавим его следующей командой, и вставим перед целью прыжка.

(Немного досадно, что из-за возможности переезда команд из одного `commandn` в другой нам придётся связывать строки для `echo` с самими командами по «идентификатору», как и в первой древесной реализации: ни индексы команд, ни указатели не остаются неизменными.)

Вторая эвристика: если не удалось найти команду, в которой заняты все физические регистры, то возьмём тот физический регистр, который «лучше всего подходит» (меньше всего коллизий с уже назначенными регистрами), и попытаемся освободить его всюду, где он нужен, но занят.  
    `// не хватило физ. регистра для п-регистра №r       regnum victim;       // эвристика 1: найдём команду, в которой не хватает регистров       foreach2(i, pcode, next)           if ((i->cmd.opcode!=command::load && i->cmd.opcode!=command::store) &&                   ((contains(i->onenter, r) && i->onenterp.size()==lastp) ||                    (contains(i->onexit, r) && i->onexitp.size()==lastp))) {               victim = spillable(i);               assert(victim);               spillAt(i, victim, next);               goto afterspill;           }       // эвристика 2: найдём "самый подходящий" регистр       physreg bestfit = (physreg)(std::max_element(collisions.begin(), collisions.end())-collisions.begin()+1);       foreach2(i, pcode, next)           if ((i->cmd.opcode!=command::load && i->cmd.opcode!=command::store) &&                   ((contains(i->onenter, r) && contains(i->onenterp, bestfit)) ||                    (contains(i->onexit, r) && contains(i->onexitp, bestfit))) &&                   (victim = spillable(i))) {               spillAt(i, victim, next);               goto afterspill;           }       yyerror("don't know how to proceed");`  
При расщеплении версий нужно не забыть скопировать номер слота (все версии одного регистра хранятся в одном слоте), а потом, при переименовании версий, — не забыть обновить `spill`.

Компилятор уже почти работает; последняя проблема — что генерируется куча бесполезных `load` и `store`, и из-за них не остаётся регистров на осмысленные команды.

### Работа с памятью

Во-первых, может оказаться, что некоторые регистры используются исключительно в командах `load/store`  
Такие команды бесполезны: регистр записывается всегда в тот же слот, из которого был прочитан.  
Вставим чистку после расщепления версий: там у нас как раз должно получиться много регистров с коротким временем жизни.  
    `// вычистить бессмысленные регистры       std::vector<bool> used(lastreg+1);       foreach(i, pcode) {           if (writesdest(i) && i->cmd.opcode!=command::load)               used[i->cmd.dest] = true;           if (readsdest(i) && i->cmd.opcode!=command::store)               used[i->cmd.dest] = true;           if (has2src(i)) {               used[i->cmd.src1] = true;               used[i->cmd.src2] = true;           }       }       foreach(i, pcode)           if ((i->cmd.opcode==command::load && !used[i->cmd.dest]) ||               (i->cmd.opcode==command::store && !used[i->cmd.dest]))                   nopOut(i);`  
Во-вторых, если у нас есть цепочки одинаковых `load`, то все, кроме последней, удалятся за то, что прочитанный регистр не жив. А вот если у нас цепочки одинаковых `store`, то для их удаления нужно придумать нечто новое. Алгоритм очень похож на итеративное определение нужности регистров, только теперь определяем «несохранённость» — чтобы вычистить все сохранения уже сохранённых регистров.

-   регистр не сохранён в команде, которая _задаёт_ его значение;
-   если из команды A можно перейти на B (непосредственно или прыжком), и регистр не сохранён в A, то он не сохранён и в B;
-   регистр сохранён в команде, которая _сохраняет_ его значение.

Видим, что от предыдущего этот алгоритм отличается только направлением распространения: нужность распространяется от каждой команды к предыдущим, а несохранённость — к последующим.  
В общем виде итеративный алгоритм вычисления множеств регистров в каждой точке программы называется _data flow analysis_, и применяется, кроме двух названных, и для многих других оптимизаций.

`void unsaved() {       bool changed = false;       // rule 1       foreach(i, pcode) {           i->onenter = i->onexit = aliveset();           if (writesdest(i)) {               i->onexit.insert(i->cmd.dest);               changed = true;           }       }       while (changed) {           changed = false;           foreach2(i, pcode, next) {               int oldsize = i->onenter.size()+i->onexit.size();               // rule 2 (next command)               if (hasnext(i))                   next->onenter.insert(i->onexit.begin(), i->onexit.end());               // rule 2 (jmp target)               if (i->cmd.opcode==command::jz)                   i->tgt->onenter.insert(i->onexit.begin(), i->onexit.end());               // rule 3               i->onexit.insert(i->onenter.begin(), i->onenter.end());               if (i->cmd.opcode==command::store)                   i->onexit.erase(i->cmd.dest);if (i->onenter.size()+i->onexit.size() != oldsize)                   changed = true;           }       }   }afterspill: // пост-обработка после "выливания регистра"           unsaved();           foreach(i, pcode)               if (i->cmd.opcode==command::store && !contains(i->onenter, i->cmd.dest))                   nopOut(i);       }   `

### Что получилось?

Весь компилятор вместе: [tyomitch.net.ru/jsk.y.regs.html](http://tyomitch.net.ru/jsk.y.regs.html)  
Из полутысячи строк, к парсингу относится лишь пятая часть. Действительно кажется, что по сравнению с трудозатратами на остальную часть компилятора, парсер — неинтересная мелочь сбоку. Но это лишь потому, что создание парсеров обсосано до косточек, и нам остаётся лишь воспользоваться готовым; тогда как при обработке кода больше места выдумке.

В итоге назначения регистров и первых оптимизаций, генерируемый код удлинился всего на пару команд:

```
00 mov   r01, 0
01 mov   r02, 0x3e8
02 echo  0x12e
03 echo  r01
04 echo  0xa8
05 echo  r02
06 echo  0xaf
07 le    r03, r01, r02
08 jz    r03, +0x1f (=0x28)
09 add   r03, r01, r02
0a mov   r04, 2
0b div   r03, r03, r04
0c echo  0x16a
0d echo  r03
0e echo  0xd4
0f input r04
10 store r01, 1
11 mov   r01, 1
12 eq    r01, r04, r01
13 jz    r01, +5 (=0x19)
14 load  r01, 1
15 mov   r02, 1
16 sub   r02, r03, r02
17 add   r02, r02, 0
18 jz    0,   -0x12 (=0x7)
19 mov   r01, 2
1a eq    r01, r04, r01
1b jz    r01, +4 (=0x20)
1c mov   r01, 1
1d add   r01, r03, r01
1e add   r01, r01, 0
1f jz    0,   -0x19 (=0x7)
20 load  r01, 1
21 mov   r03, 3
22 eq    r03, r04, r03
23 jz    r03, +2 (=0x26)
24 echo  0x14e
25 hlt
26 echo  0x172
27 jz    0,   -0x21 (=7)
28 echo  0x107
29 hlt

```

Зато, поскольку используется только четыре регистра, этот п-код возможно будет перевести в машинный код реального процессора.

Продолжим в августе: уезжаю в отпуск, и дописываю этот пост прямо из аэропорта.  
Всем приятного лета!
---
created: 2023-03-14T12:14:31 (UTC +03:00)
tags: [компиляция,оптимизация кода,data flow analysis]
source: https://habr.com/ru/post/101946/
author: Artyom Skrobov
---

# Компиляция. 8: оптимизация / Хабр

> ## Excerpt
> После приятного отдыха продолжаем писать компилятор для нашего джей-скрипа. В предыдущем посте реализовали взятую с потолка эвристику для назначения регистров, и...

---
Время на прочтение 15 мин

Количество просмотров 3K

После приятного отдыха продолжаем писать компилятор для нашего джей-скрипа.  
В предыдущем посте реализовали взятую с потолка [эвристику для назначения регистров](http://habrahabr.ru/blogs/programming/99595/), и заодно начали оптимизировать код. А ещё перед этим читатели [обнаружили баг](http://habrahabr.ru/blogs/programming/99592/#comment_3082245) в реализации присваивания.

### Далее в посте:

1.  Починка бага
2.  Чистка копирований
3.  Что получилось?
4.  Сворачивание констант
5.  Реализация

### Починка бага

Дело в том, что мы решили было схитрить, и при первом присваивании значения переменной не выполнять собственно копирование, а просто объявить регистр с промежуточным значением местом хранения переменной:  
    `ID '=' EXPR       { $$ = $3;                           if(vars[$1])                               emit(command::add, vars[$1], $3, 0);                           else                               vars[$1] = $3; // new var                         }`  
Тогда при компиляции операции типа `a=2;` получим одну команду `MOV R1, 2` (из свёртки 2) и запомним `vars["a"]=R1` (из свёртки присваивания).  
Всё верно, просто и естественно.

Проблема возникала тогда, когда в правой части присваивания использовалось не промежуточное значение, а нечто долгоживущее: например, другая переменная.

```
a = 2;
b = a;

```

Во второй свёртке присваивания не генерируется новый код — только запоминаем `vars["b"]=R1`  
Обе переменные оказались в одном регистре, и при изменении одной из них — изменится и вторая.

Решение лежит на поверхности: для каждой новой переменной заводим новый регистр.  
    `ID '=' EXPR       { $$ = $3;                           if(!vars[$1]) vars[$1] = newreg();                           emit(command::add, vars[$1], $3, 0);                         }`  
Тогда из `a=2;` получим уже пару команд

```
MOV R1, 2
ADD R2, R1, 0

```

и запоминаем `vars["a"]=R2`  
Если за ней следует `b = a;` — то к коду добавится `MOV R3, R2, 0` и `vars["b"]=R3`

Иначе говоря, теперь в генерируемом коде будет уйма лишних копирований из регистра в регистр, а назначение регистров будет работать ещё медленнее — из-за того, что число использованных регистров растёт.  
Постараемся найти те случаи, где копирование излишне (например, если переменная из правой части присваивания в дальнейшем не изменяется), и исправим команды, использующие копию, так, чтоб использовали оригинал.

### Чистка копирований

_Copy elimination_ — одна из простых оптимизаций, которую я [обещал](http://habrahabr.ru/blogs/programming/99162/) с самого первого поста серии. Как и для оптимизаций, выполняемых во время назначения регистров, для чистки удобно применить data-flow analysis. Важным отличием от двух предыдущих применений DFA (проход назад для обнаружения живых регистров, проход вперёд для обнаружения сохранённых регистров) будет являться то, что в каждой точке храним не одно множество регистров, а _разбиение_ всех регистров на множества одинаковых. Можно смотреть на это как на более общий случай DFA, чем два рассмотренных прежде. (Прежде, регистры всегда разбивались на два множества — «включённые» и «исключённые».)

Как же будем разбивать регистры?

-   команда `ADD RA, RB, 0` переносит `RA` во множество к `RB`;
-   любая другая команда, изменяющая регистр, выносит его во множество-синглетон;
-   `RA` и `RB` будут вместе в команде C, если они вместе _во всех_ командах, из которых можно перейти в C (непосредственно или прыжком).

После получения окончательного разбиения будет видно, где вместо копии можно использовать оригинал: вместо `RA` можно использовать `RB`, если они вместе _во всех_ командах, где используется `RA`.

И ещё одна тонкость: поскольку при переходах от команды к команде мы не наращиваем множества, а усекаем (пересекаем все входящие множества), то перед запуском DFA нужно инициализировать множества не в пустые, а во всеобъемлющие — и по мере работы алгоритма множества усекутся, как надо. Чтобы не тратиться и не держать взаправду в каждой команде множество всех существующих регистров, договоримся считать «отсутствующий итератор» указывающим именно на такое всеобъемлющее множество.

Для удобства, три нужных нам операции над разбиениями оформляем в класс. В разбиении храним список множеств, на которые разбиты регистры (кроме «глобального» множества, в котором регистры все вместе находятся изначально), и для каждого регистра (кроме тех, что в «глобальном» множестве) — итератор того множества, в котором он находится.

С древесным `std::set` у меня возникли непонятные проблемы, так что я написал себе контейнер `bit::set` с аналогичным интерфейсом, но с `std::bitset` внутри. Параметром шаблона он принимает максимальное значение ключа в множестве.  
Заодно в `bit::set` вынесены стандартные операции над множествами (`&=`, `|=`).

`typedef bit::set<regnum,255> regset;class regPartition {       typedef std::list<regset> regsets;       regsets sets;       std::map<regnum, regsets::iterator> byreg;   // изначально: все регистры в "глобальном" разбиенииpublic:       // возвращает: изменилось ли разбиение       bool add(regnum copy, regnum orig) {           if (byreg.count(copy)) {               if(byreg[copy]==byreg[orig]) // уже вместе                   return false;               byreg[copy]->erase(copy);               // был последним?               if(!byreg[copy]->size())                   sets.erase(byreg[copy]);           }           assert(byreg.count(orig));           byreg[copy] = byreg[orig];           byreg[copy]->insert(copy);           return true;       }void remove(regnum r) {           if (byreg.count(r)) {               if(byreg[r]->size()==1) return; // уже один               byreg[r]->erase(r);           }           byreg[r] = sets.insert(sets.end(), regset());           byreg[r]->insert(r);       }// возвращает: изменилось ли разбиение       bool isect(/*const*/regPartition& p, const command& self) {           bool changed = false;           // оставить вместе только тех, кто вместе и в p           foreach(i, byreg) {               regnum r = i->first;               // split by p.byreg[r]               regsets::iterator withR = i->second,                            withoutR = sets.insert(sets.end(), regset());               foreach2(j, (*withR), next)                   // не разделяем, если текущая команда -- mov с теми же регистрами:                   //   всё равно на следующем шагу объединятся                   if(!(self.opcode==command::add && !self.src2 &&                       ((self.src1==r && self.dest==*j)||(self.dest==r && self.src1==*j)))                   &&((!p.byreg.count(r) && p.byreg.count(*j)) ||  // R in global, J isn't                       (p.byreg.count(r) && !p.byreg[r]->count(*j)))) { // R not in global                           withR->erase(*j);                           withoutR->insert(*j);                           byreg[*j] = withoutR;                   }               if(!withoutR->size()) // ничего не отделилось                   sets.erase(withoutR);               else // разделили                   changed = true;           }           // теперь те, что в глобальном в this, но не в p           foreach(i, p.sets) {               regset inP;               foreach(j, (*i))                   if(!byreg.count(*j)) inP.insert(*j);               if(inP.size()) {                   regsets::iterator newSet = sets.insert(sets.end(), inP);                   foreach(j, inP) byreg[*j] = newSet;                   changed = true;               }           }           return changed;       }// применение разбиения: формируем для r множество возможных замен (во всём коде)       void apply(regnum r, regset& global) {           if (!r) return; // may not be replaced           assert(byreg.count(r));           if(!global.size()) // uninitialized set               global = *byreg[r];           else // initialized; intersect               global &= *byreg[r];       }   }   `  
В `struct commandn` добавляем новое поле `regPartition copies;`  
Теперь привычным образом реализуем DFA, используя уже готовые операции:  
`void copies() {           // а) вычисляем разбиения для каждой команды           bool changed = false;           foreach(i, pcode) {               i->copies = regPartition();               // rule 2               if (writesdest(i)) {                   i->copies.remove(i->cmd.dest);                   changed = true;               }           }           while (changed) {               changed = false;               foreach2(i, pcode, next) {                   // rule 1                   if (i->cmd.opcode==command::add && !i->cmd.src2)                       changed |= i->copies.add(i->cmd.dest, i->cmd.src1);                   // rule 3 (next command)                   if (hasnext(i))                       changed |= next->copies.isect(i->copies, next->cmd);                   // rule 3 (jmp target)                   if (i->cmd.opcode==command::jz)                       changed |= i->tgt->copies.isect(i->copies, i->tgt->cmd);               }           }           // б) вычисляем возможные замены во всём коде           std::vector<regset> copies(lastreg+1);           foreach(i, pcode) {               if(readsdest(i))                   i->copies.apply(i->cmd.dest, copies[i->cmd.dest]);               if(has2src(i)) {                   i->copies.apply(i->cmd.src1, copies[i->cmd.src1]);                   i->copies.apply(i->cmd.src2, copies[i->cmd.src2]);               }           }           // в) объединяем копии           for(regnum r=1; r<=lastreg; r++) {               copies[r].erase(r);               if(copies[r].size()) {  // остались возможные замены?                   regnum s = *(copies[r].begin()); // заменим r на s                   foreach(i, pcode) { // во всём коде                       if(i->cmd.dest==r)                           i->cmd.dest = s;                       if(has2src(i)) {                           if(i->cmd.src1==r) i->cmd.src1 = s;                           if(i->cmd.src2==r) i->cmd.src2 = s;                       }                       if(i->cmd.opcode==command::add && i->cmd.src1==i->cmd.dest && !i->cmd.src2) // self-mov                           nopOut(i);                   }                   foreach(c, copies)  // и в векторе замен                       if(c->count(r)) {                           c->erase(r);                           c->insert(s);                       }               }           }   }   `Вызов `copies();` вставим в самое начало цикла оптимизаций, перед проверкой живости.

### Что получилось?

По сравнению с прошлым разом, код сократился ещё на пару команд:

```
00 mov   r01, 0
01 mov   r02, 0x3e8
02 echo  0x126
03 echo  r01
04 echo  0xa0
05 echo  r02
06 echo  0xa7
07 le    r03, r01, r02
08 jz    r03, +0x1d (=0x26)
09 add   r03, r01, r02
0a mov   r04, 2
0b div   r03, r03, r04
0c echo  0x162
0d echo  r03
0e echo  0xcc
0f input r04
10 store r01, 1
11 mov   r01, 1
12 eq    r01, r04, r01
13 jz    r01, +4 (=0x18)
14 load  r01, 1
15 mov   r02, 1
16 sub   r02, r03, r02
17 jz    0,   -0x11 (=0x7)
18 mov   r01, 2
19 eq    r01, r04, r01
1a jz    r01, +3 (=0x1e)
1b mov   r01, 1
1c add   r01, r03, r01
1d jz    0,   -0x17 (=0x7)
1e load  r01, 1
1f mov   r03, 3
20 eq    r03, r04, r03
21 jz    r03, +2 (=0x24)
22 echo  0x146
23 hlt
24 echo  0x16a
25 jz    0,   -0x1f (=7)
26 echo  0xff
27 hlt

```

Может показаться, что про исчезнувшие команды (`add r01, r01, 0` и `add r02, r02, 0`) сразу было видно, что они бессмысленные. На самом деле, эти команды принимали бессмысленную форму только после назначения физических регистров, т.е. на самом последнем этапе перед выводом готового п-кода. До тех пор, номера п-регистров у операндов различались; лишь выполненный нами только что анализ позволил их объединить, и удалить ставшее бессмысленным копирование — всё это задолго до назначения физических регистров.

### Сворачивание констант

Ещё одна стандартная оптимизация, которая, как и предыдущие, реализуется при помощи DFA, — _constant folding_. Принцип донельзя прост: если известны значения операндов, то операцию можно выполнить сразу при компиляции. Например, вместо кода

```
MOV R1, 2
MOV R2, 3
ADD R3, R1, R2

```

можем сгенерировать сразу же

```
MOV R3, 5
```

Операции над константами не обязательно свидетельствуют о небрежности программиста, поленившегося вычислить заранее известный результат: например, `pixels=1024*768;` легче читать и поддерживать, чем `pixels=786432;`

В этот раз, в каждой команде храним множества регистров, для которых известны значения, — вместе со значениями: в виде `std::map<regnum,int>`  
Как обычно, формулируем три правила вычисления множеств:

-   в команде `MOV R, X` значение R известно, и это _X_;
-   в любой другой команде, задающей значение R, это значение неизвестно;
-   в команде C известно значение R, если оно известно и одинаково _во всех_ командах, из которых можно перейти в C (непосредственно или прыжком).

Вновь видим: направление прохода — вперёд (от значения регистра в предыдущей команде зависит её значение в последующей); операция в узлах — объединение неизвестных регистров.

Когда множества стабилизируются, сможем заменить каждую операцию, оба операнда которой известны, на `MOV`.

Те же самые данные позволят нам выполнить ещё одну оптимизацию — _constant propagation_ (подстановка известного значения вместо ссылки на регистр). Эта оптимизация невозможна при выбранном нами формате п-кода, потому что в нём отсутствуют операции над регистром и константой; такие операции, однако, присутствуют во многих реальных процессорах, так что выполнить полноценную «подстановку констант» можно будет при генерации выполнимого кода. Сейчас же ограничимся заменой нулевого значения на R0.

Например, конструкция типа `if (1>2) { echo("unreachable"); }`, которая компилируется в

```
MOV R1, 1
MOV R2, 2
GT R3, R1, R2
JZ R3, label
ECHO "unreachable"
label:

```

превратится на этапе сворачивания констант в

```
MOV R1, 1
MOV R2, 2
MOV R3, 0
JZ R3, label
ECHO "unreachable"
label:

```

и уже реализованная нами в прошлый раз оптимизация «уничтожение неживого кода» удалит две первых команды `MOV`.  
Если же мы заодно заменим нулевое значение на R0:

```
MOV R3, 0
JZ R0, label
ECHO "unreachable"
label:

```

то вместе с неживым кодом удалится и последний `MOV`, а «уничтожение недостижимого кода» удалит ещё и `ECHO`, превратив `JZ` в `NOP`.

Аналогично можно удалять из кода `JZ` с известным ненулевым значением. Второй реализованный «особый случай» — замена команд `ADD RX, (0), RY` на `ADD RX, RY, R0`, чтобы алгоритм чистки копирований распознал в этой команде копирование из регистра в регистр.

Ещё одна выгода от сворачивания констант — что теперь в наших командах могут использоваться отрицательные значения. Из-за того, что [в лексере](http://habrahabr.ru/blogs/programming/99397/) мы задали токен `NUM` регэкспом `[0-9]+`, строки типа "-123" интерпретировались как унарный минус и затем литерал 123; поэтому они компилировались в п-код наподобие

```
MOV R1, 123
SUB R2, R0, R1

```

Теперь же в п-коде будет честная команда `MOV R1, -123`.

### Реализация

`struct commandn` дополняется ещё парой полей:  
`std::map<regnum,int> known; regset unknown;`

Основой оптимизации, как и в предыдущих случаях, является DFA:  
`void constp() {           bool changed = false;           foreach(i, pcode) {               i->known.clear(); i->unknown.clear();               if (i->cmd.opcode==command::mov) { // rule 1                   i->known[i->cmd.dest] = i->cmd.imm;                   changed = true;               } else if(writesdest(i)) { // rule 2                   i->unknown.insert(i->cmd.dest);                   changed = true;               }           }           while(changed) {               changed = false;               foreach2(i, pcode, next) {                   // rule 3 (next command)                   if (hasnext(i))                       changed |= propagate(i, next);                   // rule 3 (jmp target)                   if (i->cmd.opcode==command::jz)                       changed |= propagate(i, i->tgt);               }           }           // заменим известные значения           foreach(i, pcode) {               i->known[0] = 0; // R0 известен всегда               if(has2src(i) && i->known.count(i->cmd.src1) && i->known.count(i->cmd.src2))                   i->cmd = command(command::mov, i->cmd.dest, ops[i->cmd.opcode](i->known[i->cmd.src1],i->known[i->cmd.src2]));               // подставляем 0               if(has2src(i)) {                   if(i->known.count(i->cmd.src1) && !i->known[i->cmd.src1])                       i->cmd.src1 = 0;                   if(i->known.count(i->cmd.src2) && !i->known[i->cmd.src2])                       i->cmd.src2 = 0;                   if(i->cmd.opcode==command::add && !i->cmd.src1) { // чтоб распознавалось как копирование                       i->cmd.src1 = i->cmd.src2;                       i->cmd.src2 = 0;                   }               }               if(readsdest(i) && i->known.count(i->cmd.dest))                   if(!i->known[i->cmd.dest])                       i->cmd.dest = 0;                   else // значение известно, но это не 0                       if(i->cmd.opcode==command::jz) nopOut(i);           }   }   `  
Процедура `propagate()` реализует объединение множеств неизвестных регистров: регистр с несколькими известными значениями объявляется неизвестным.  
`bool propagate(pcommandn from, pcommandn to) {           bool changed = false; // возвращает: изменились ли множества           // проверяем известные значения           foreach(i, from->known) {               regnum r = i->first;               if(to->known.count(r))                   if((to->known[r]!=i->second) // другое, и не заданное правилом 1                       &&!((to->cmd.opcode==command::mov) && (to->cmd.dest==r))) {                           to->known.erase(r);                           to->unknown.insert(r);                           changed = true;                   } else; // значение известное и верное               else if(!to->unknown.count(r)) { // по умолчанию, известно                   to->known[r]=i->second;                   changed = true;               }           }           // объединяем неизвестные           foreach(r, from->unknown)               if(!to->unknown.count(*r)) {                   to->unknown.insert(*r);                   to->known.erase(*r);                   changed = true;               }           return changed;   }   `  
Последнее, что осталось, — собственно вычисление значения, когда операнды известны. Так же, как в выполнятеле джей-скрипа, заводим по функции на каждый опкод:  
`int hlt(int src1, int src2) { assert(false); return 0; }   int add(int src1, int src2) { return src1+src2; }   int sub(int src1, int src2) { return src1-src2; }   ...   int lt(int src1, int src2) { return src1<src2; }   int (*ops[])(int, int) = {hlt, hlt, hlt, hlt, hlt, hlt, hlt, add, sub, mul, div, eq, ne, ge, le, gt, lt};   `  
Вставим вызов `constp();` перед `copies();` — и на этом с оптимизацией закончим.

В следующем посте — собираем из п-кода с расставленными физическими регистрами [настоящий исполнимый код](http://habrahabr.ru/blogs/programming/103402/) для x86/x64.
---
created: 2023-03-14T12:14:46 (UTC +03:00)
tags: [компиляция,генерация кода,x64,x86]
source: https://habr.com/ru/post/103402/
author: Artyom Skrobov
---

# Компиляция. 9: исполняемый код / Хабр

> ## Excerpt
> Напоминаю, что мы пишем компилятор для игрушечного языка джей-скрип. Начали с компиляции в п-код, потратили немало сил на его оптимизацию, и приготовились к закл...

---
Время на прочтение 19 мин

Количество просмотров 5.5K

Напоминаю, что мы пишем компилятор для игрушечного языка [джей-скрип.](http://habrahabr.ru/blogs/programming/99397/) Начали с компиляции [в п-код](http://habrahabr.ru/blogs/programming/99592/), потратили немало сил на его [оптимизацию](http://habrahabr.ru/blogs/programming/101946/), и приготовились к заключительному этапу компиляции — к выводу машинно-зависимого выполнимого кода.  
Никаких замысловатых алгоритмов тут уже нет: по большому счёту, только замена одной системы команд на другую.

### Далее в посте:

1.  Выбор кода
2.  Загрузчик
3.  Изменения в п-коде
4.  Генерация
5.  Что получилось?

### Выбор кода

Рискну предположить, что вы читаете этот пост на компьютере, внутри которого процессор x86 или x64. Перед пользователями мобильных устройств извиняюсь: генерировать код для модного гаджета было бы занимательно, но мне слишком сложно раздобыть такой экземплярчик для экспериментов.

Постараемся генерировать «кроссплатформенный» код, одинаково работоспособный и на x86, и на x64. Сосредоточимся именно на машинном коде, а не на внутренностях формата ELF и взаимодействии с загрузчиком; поэтому будем создавать код «сплошным куском», аналогично досовскому формату COM. Читать его с диска и запускать будет наш собственный загрузчик.

Пользоваться будем только 32-битными регистрами, так что одна и та же программа, даже если в ней при вычислениях происходят переполнения, будет давать одинаковые результаты и на x64, и на x86.

Для связи со внешним миром (команды `ECHO` и `INPUT`) сгенерированный код должен будет как-то вызывать функции операционной системы. Откуда он узнает их адреса?  
Наш загрузчик создаст для загруженной программы «область связи» — массив указателей на «стандартные функции», и передаст адрес этого массива параметром в программу. Стандартных функций у нас три: ввод числа, вывод числа, вывод строки; поэтому область связи будет состоять из трёх указателей. Для удобства адресации, сразу же на входе в программу сохраним переданный адрес в `EBP`/`RBP`.

Другой интересный момент — доступ к памяти (к вылитым переменным). Вместо типичной для x86 абсолютной адресации в x64 ввели «перемещаемую абсолютную», относительно `RIP`. Чтобы код действительно получился кроссплатформенным, надо пользоваться явной относительной адресацией.  
Не мудрствуя лукаво, будем адресовать ячейки вылитых переменных относительно того же `EBP`/`RBP` — т.е. сразу за областью связи, по смещению `0x18`, начнётся область переменных.

Сгенерированный п-код использует четыре «абстрактных физических регистра» `R01..R04`, которым естественно сопоставить настоящие регистры `EAX,ECX,EDX,EBX`: т.е. номер настоящего регистра получается из номера «абстрактного» вычитанием единицы. Если бы мы захотели задействовать остальные регистры процессора, соответствие между номерами было бы более сложным.

Способ передачи параметров в функцию на x86 и на x64 сильно отличается. На x86 параметры по умолчанию передаются через стек (_cdecl_), но можно попросить `gcc` передавать до трёх параметров в регистрах `ECX,EDX,EAX` (_fastcall_). На x64 шесть параметров передаются в регистрах `RDI,RSI,RDX,RCX,R8,R9`, и `gcc` не позволяет менять способ вызова. Из-за этой несовместимости придётся реализовать в генераторе кода оба механизма передачи, и выбирать нужный. К счастью, передача параметров будет в нашем коде единственным платформо-зависимым местом.  
На обоих процессорах вызываемая функция вправе портить содержимое `EAX,ECX,EDX`, так что их понадобится сохранять перед вызовом (если они живы), и восстанавливать после. Таким образом, информация о живости физических регистров, которой мы пользовались в ходе их назначения, — оказывается нужна и при генерации кода.

Какой код будем генерировать, разобрались; дело за малым — реализовать задуманное.

### Загрузчик

Берём за основу давнишний интерпретатор п-кода, оставляем всю шелуху (проверка ввода, отображение файла в память), а нутро (цикл выполнения и реализации команд) заменяем вызовом прочитанного кода, как будто бы это обычная сишная функция.  
`#include <fcntl.h>   #include <stdio.h>   #include <stdlib.h>   #include <sys/mman.h>   #include <sys/stat.h>const char* fdata = NULL; // весь прочитанный кодint input() { int d; scanf(" %d", &d); return d; }   void echoi(int i) { printf("%d", i); }   void echos(int offset) { printf("%s", fdata+offset); }void* linkarea[1000] = {(void*)input, (void*)echoi, (void*) echos};int main(int argc, char** argv) {if(argc!=2) {           printf("Missing code file name.\n");           exit(1);       }int fd = open(argv[1], O_RDONLY);       if (fd<0) {           printf("Cannot open code file.\n");           exit(1);       }       struct stat finfo;       fstat(fd, &finfo);       fdata = (const char*)mmap(0, finfo.st_size, PROT_READ|PROT_EXEC, MAP_PRIVATE, fd, 0);       if (!fdata) {           printf("Cannot read code file.\n");           exit(1);       }`

    `((`

`void (*)(void**)) fdata)(linkarea); // запуск      munmap((  void*)fdata, finfo.st_size);       close(fd);       return 0;   }   `  
Заметьте, что исчез `#include "jsk.h"`, задававший определения команд: новый загрузчик ничего не знает ни про джей-скрип, ни про наш п-код.

### Изменения в п-коде

Сейчас, когда п-код стал внутренним представлением, невидимым снаружи компилятора, — уже нет смысла сжимать каждую команду в 4 байта; значит, не нужны ни хитрые `union`, ни ограничения размера поля. Заменяем `jsk.h` на объявление обычной структуры с полями `int`:  
`struct command {       enum opcodes {           hlt, store, jz, echo, mov, load, input, add, sub, mul, div,           eq, ne, ge, le, gt, lt       };       opcodes opcode;       regnum dest, src1, src2;       int imm;       command(opcodes opcode, regnum dest, regnum src1, regnum src2) :               opcode(opcode), dest(dest), src1(src1), src2(src2) {}       command(opcodes opcode, regnum dest, int imm) :               opcode(opcode), dest(dest), imm(imm) {}   };   `

Особенность набора инструкций x86/x64 — его разнообразие и неортогональность. Едва ли не любую операцию можно закодировать тремя-четырьмя разными способами. Постараемся для каждой п-команды выбирать самую компактную из возможных реализаций. (Это предельный случай «оптимизации сквозь глазок» — _peephole optimization_, занимающейся не программой в целом, а короткими блоками смежных команд. У нас вообще каждая команда обрабатывается независимо от окружающих.)

Например, п-команда `add` у нас может скомпилироваться в `MOV`, в `INC`, в `DEC`, в одну из трёх форм `ADD` или в одну из трёх форм `LEA` — в зависимости от сочетания аргументов.

Некоторые локальные оптимизации, вроде замены `mul r, r, 2` на `add r, r, r`, удобно выполнить ещё на уровне п-кода, до трансляции в выполнимый код. На этом же этапе — после выбора физических регистров, но до окончательной трансляции — избавимся от регистров, значение которых известно во всех местах, где они используются: при трансляции будем пользоваться известным значением.  
`// в подстановке констант:   //      ...           if(i->cmd.opcode==command::mul) { // несколько замен               if(i->known.count(i->cmd.src1)) std::swap(i->cmd.src1, i->cmd.src2);               if(i->known.count(i->cmd.src2)) switch(i->known[i->cmd.src2]) {                   case -1: i->cmd = command(command::sub, i->cmd.dest, 0, i->cmd.src1); break;                   case 0:  i->cmd = command(command::mov, i->cmd.dest, 0); break;                   case 1:  nopOut(i); break;                   case 2:  i->cmd = command(command::add, i->cmd.dest, i->cmd.src1, i->cmd.src1); break;               }           }// удалить регистры, значение которых известно всюду, где используется   void postalloc() {           std::vector<bool> needed(lastreg+1);           foreach(i, pcode) {               if(i->has2src()) {                   if(!i->known.count(i->cmd.src1)) needed[i->cmd.src1]=true;                   if(!i->known.count(i->cmd.src2)) needed[i->cmd.src2]=true;                   else // src2 известен: есть один особый случай                       if(i->cmd.opcode==command::div && i->known[i->cmd.src2]!=2)                           needed[i->cmd.src2]=true; // под делитель нужен регистр               }               if(i->readsdest() && !i->known.count(i->cmd.dest))                   needed[i->cmd.dest]=true;           }           foreach(i, pcode)               if(i->writesdest() && !needed[i->cmd.dest])                   nopOut(i);   }// после успешного выбора всех физических регистров:               // ...               postalloc();               // вычистить NOP-ы               simpleopt();               // подставляем физические регистры: и в командах, и в known               foreach(i, pcode) {                   std::map<regnum,int> known;                   if(i->known.count(i->cmd.dest))                       known[physmap[i->cmd.dest]] = i->known[i->cmd.dest];                   i->cmd.dest = physmap[i->cmd.dest];                   if (i->has2src()) {                       if(i->known.count(i->cmd.src1))                           known[physmap[i->cmd.src1]] = i->known[i->cmd.src1];                       if(i->known.count(i->cmd.src2))                           known[physmap[i->cmd.src2]] = i->known[i->cmd.src2];                       i->cmd.src1 = physmap[i->cmd.src1];                       i->cmd.src2 = physmap[i->cmd.src2];                   }                   i->known = known;               }               break;   `

### Генерация

Весь генерируемый код будем хранить в одном большом векторе `std::vector<char> code;`  
В `struct commandn` нам понадобится несколько новых полей. `int offset, length;` будут определять позицию команды в векторе `code`. Кроме того, для команд `JZ` и `ECHO`, значение смещения в которых неизвестно до конца генерации кода, в поле `int needfixat;` будем хранить индекс незаполненного смещения.

Итак, на первом проходе по п-коду генерируем весь исполнимый код в векторе `code`; затем пройдём по коду второй раз, и заполним недостающие смещения. После этого выводим в результат весь код и все строки.

Я постарался убрать из листинга самые неинтересные куски, чтоб хоть немного его сократить. Полный код компилятора выложен на [tyomitch.net.ru/jsk.y.natv.html](http://tyomitch.net.ru/jsk.y.natv.html)

`// последний этап: генерация кода для x86/x64   const char regsize = sizeof(void*); // 4 либо 8   // пролог   if(regsize==4) { // PUSH EBP / MOV EBP, [ESP+8] / PUSH EDI / PUSH ESI / PUSH EBX       code.push_back(0x55); code.push_back(0x8b); code.push_back(0x6c); code.push_back(0x24);       code.push_back(0x08); code.push_back(0x57); code.push_back(0x56); code.push_back(0x53);   } else {         // PUSH EBP / MOV RBP, RDI / PUSH EBX       code.push_back(0x55); code.push_back(0x48); code.push_back(0x8b); code.push_back(0xef);       code.push_back(0x53);   }   foreach(i, pcode) {       int imm, doffset, joffset;       bool jshort, saveAX, saveDX;       i->offset = code.size();       switch(i->cmd.opcode) {       case command::hlt:           if(regsize==4) {               i->emit(0x5b, 0x5e, 0x5f, 0x5d); // POP EBX / POP ESI / POP EDI / POP EBP               i->emit(0xc2, 2, 0);             // RET 2           } else               i->emit(0x5b, 0x5d, 0xc3);       // POP EBX / POP EBP / RET           break;       case command::store: // MOV [EBP+18+(imm-1)*4], dst           doffset = 0x18+(i->cmd.imm-1)*4;           if(i->known.count(i->cmd.dest)) {               i->emit(0xc7);               if(doffset<128)                   i->emit(0x45, (char)doffset);               else {                   i->emit14(0x85, doffset);               }               i->emit4(i->known[i->cmd.dest]);           } else {               i->emit(0x89);               if(doffset<128)                   i->emit(0x45|(i->cmd.dest-1)<<3, (char)doffset);               else                   i->emit14(0x85|(i->cmd.dest-1)<<3, doffset);           }           break;       case command::jz:           joffset = i->tgt->offset - (i->offset+2); // предполагаем JMP SHORT           jshort = i->tgt->offset && (joffset>=-128); // прыжок назад и близко           if(!i->cmd.dest) { // JMP off               if(jshort)                   i->emit(0xeb, (char)joffset);               else {                   i->emit(0xe9);                   if(i->tgt->offset) // прыжок назад                       i->emit4(joffset-3);                   else {                       i->needfixat = code.size();                       i->emit4(0);                   }               }               break;           }           if(jshort && (i->cmd.dest==2)) { // JECXZ               i->emit(0xe3, (char)joffset);               break;           }           // OR dst, dst / JZ off           i->emit(0x0b, 0xc0|(i->cmd.dest-1)<<3|(i->cmd.dest-1));           if(jshort && (joffset>=-126))               i->emit(0x74, (char)(joffset-2));           else {               i->emit(0x0f, 0x84);               if(i->tgt->offset) // прыжок назад                   i->emit4(joffset-6);               else {                   i->needfixat = code.size();                   i->emit4(0);               }           }           break;       case command::echo:  // PUSH live / PUSH dst / CALL [EBP+?] / ADD ESP, 4 / POP live           foreach(rp, i->onexitp) if(*rp!=4) i->emit(0x50|(*rp-1));           if(!i->cmd.dest) { // imm, [EBP+8]               if(regsize==4) i->emit(0x68); else i->emit(0xbf);               i->needfixat = code.size();               i->emit4(0);               i->emit(0xff, 0x55, 2*regsize);           } else {               if(i->known.count(i->cmd.dest)) { // imm, [EBP+4]                   imm = i->known[i->cmd.dest];                   if(regsize==8)                       i->emit14(0xbf, imm);                   else if((imm>=-128)&&(imm<128))                       i->emit(0x6a, (char)imm);                   else                       i->emit14(0x68, imm);               } else if(regsize==4) // dst, [EBP+4]                   i->emit(0x50|(i->cmd.dest-1));               else                   i->emit(0x8b, 0xf8|(i->cmd.dest-1));               i->emit(0xff, 0x55, regsize);           }           if(regsize==4) i->emit(0x83, 0xc4, 4);           foreachr(rp, i->onexitp) if(*rp!=4) i->emit(0x58|(*rp-1));           break;       case command::mov:   // MOV dst, imm           if(i->cmd.imm)               i->emit14(0xb8|(i->cmd.dest-1), i->cmd.imm);           else             // XOR dst, dst               i->emit(0x33, 0xc0|(i->cmd.dest-1)<<3|(i->cmd.dest-1));           break;       case command::load:  // MOV dst, [EBP+(3+i)*4]           doffset = 0x18+(i->cmd.imm-1)*4;           i->emit(0x8b);           if(doffset<128)               i->emit(0x45|(i->cmd.dest-1)<<3, (char)doffset);           else               i->emit14(0x85|(i->cmd.dest-1)<<3, doffset);           break;       case command::input: // PUSH live / CALL [EBP+0] / XCHG EAX, dst / POP live           foreach(rp, i->onenterp) if(*rp!=4) i->emit(0x50|(*rp-1));           i->emit(0xff, 0x55, 0);           if(i->cmd.dest!=1) i->emit(0x90|(i->cmd.dest-1));           foreachr(rp, i->onenterp) if(*rp!=4) i->emit(0x58|(*rp-1));           break;       case command::add:           // максимум 1 операнд известен; поставим его в src2           if(i->known.count(i->cmd.src1) || (i->cmd.src2==i->cmd.dest))               std::swap(i->cmd.src1, i->cmd.src2);           if(!i->cmd.src2) // MOV dst, src1               i->emit(0x8b, 0xc0|(i->cmd.dest-1)<<3|(i->cmd.src1-1));           else if(i->known.count(i->cmd.src2)) {               imm = i->known[i->cmd.src2];       addimm:               if(i->cmd.dest==i->cmd.src1) // ADD dst, imm                   if(imm==1) // INC dst                       i->emit(0xff, 0xc0|(i->cmd.dest-1));                   else if(imm==-1) // DEC dst                       i->emit(0xff, 0xc8|(i->cmd.dest-1));                   else if((imm>=-128)&&(imm<128))                       i->emit(0x83, 0xc0|(i->cmd.dest-1), (char)imm);                   else // for imm=128 we might use SUB Edst, -128                       i->emit114(0x81, 0xc0|(i->cmd.dest-1), imm);               else // LEA dst, [src1+imm]                   if((imm>=-128)&&(imm<128))                       i->emit(0x8d, 0x40|(i->cmd.dest-1)<<3|(i->cmd.src1-1), (char)imm);                   else                       i->emit114(0x8d, 0x80|(i->cmd.dest-1)<<3|(i->cmd.src1-1), imm);           } else if(i->cmd.dest==i->cmd.src1) // ADD dst, src2               i->emit(0x03, 0xc0|(i->cmd.dest-1)<<3|(i->cmd.src2-1));           else // LEA dst, [src1+src2]               i->emit(0x8d, (i->cmd.dest-1)<<3|4, (i->cmd.src1-1)<<3|(i->cmd.src2-1));           break;       case command::sub: // ...       case command::mul: // ...       case command::div:           if(i->known.count(i->cmd.src2) && i->known[i->cmd.src2]==2) {               if(i->cmd.dest!=i->cmd.src1) // MOV dst, src1 / SAR dst, 1                   i->emit(0x8b, 0xc0|(i->cmd.dest-1)<<3|(i->cmd.src1-1));               i->emit(0xd1, 0xf8|(i->cmd.dest-1));               break;           }           // для деления нужны именно EAX,EDX;           // сохраним их текущее содержимое в EDI,ESI, а после деления восстановим           // MOV EDI, EAX / MOV EAX, src1 / MOV ESI, EDX / XOR EDX, EDX           // IDIV src2 / XCHG dst, EAX / MOV EDX, ESI / MOV EAX, EDI           saveAX = i->onexitp.count((physreg)1) && (i->cmd.dest!=1);           saveDX = i->onexitp.count((physreg)3) && (i->cmd.dest!=3);           if(saveAX || (i->cmd.src2==1)) i->emit(0x8b, 0xf8);           if(i->cmd.src1!=1)               if(i->known.count(i->cmd.src1))                   i->emit14(0xb8, i->known[i->cmd.src1]);               else                   i->emit(0x8b, 0xc0|(i->cmd.src1-1));           if(saveDX || (i->cmd.src2==3)) i->emit(0x8b, 0xf2);           i->emit(0x33, 0xd2);           if(i->cmd.src2==1) // переехал в EDI               i->emit(0xf7, 0xff);           else if(i->cmd.src2==3) // переехал ESI               i->emit(0xf7, 0xfe);           else               i->emit(0xf7, 0xf8|(i->cmd.src2-1));           if(i->cmd.dest!=1)               i->emit(0x90|(i->cmd.dest-1));           if(saveDX) i->emit(0x8b, 0xd6);           if(saveAX) i->emit(0x8b, 0xc7);           break;       case command::eq: case command::ne: case command::ge:       case command::le: case command::gt: case command::lt:           // максимум 1 операнд известен; поставим его в src2           if(i->known.count(i->cmd.src1)) {               std::swap(i->cmd.src1, i->cmd.src2);               switch(i->cmd.opcode) {               case command::ge: i->cmd.opcode = command::le; break;               case command::le: i->cmd.opcode = command::ge; break;               case command::gt: i->cmd.opcode = command::lt; break;               case command::lt: i->cmd.opcode = command::gt; break;               }           }           // CMP src1, src2 / SETcc dstL / MOVZX dst, dstL           if(i->known.count(i->cmd.src2)) {               imm = i->known[i->cmd.src2];               if((imm>=-128)&&(imm<128))                   i->emit(0x83, 0xf8|(i->cmd.src1-1), (char)imm);               else if(i->cmd.src1==1)                   i->emit14(0x3d, imm);               else                   i->emit114(0x81, 0xf8|(i->cmd.src1-1), imm);           } else               i->emit(0x3b, 0xc0|(i->cmd.src1-1)<<3|(i->cmd.src2-1));           i->emit(0x0f);           switch(i->cmd.opcode) {           case command::eq: i->emit(0x94); break;           case command::ne: i->emit(0x95); break;           // ...           }           i->emit(0xc0|(i->cmd.dest-1));           i->emit(0x0f, 0xb6, 0xc0|(i->cmd.dest-1)<<3|(i->cmd.dest-1));           break;       default:           yyerror("unknown opcode");       }   }   // после всего кода -- строки   int offset = code.size();   std::vector<int> offsets(strings.size()+1);   foreach(i, strings) {       offsets[i->second] = offset;       offset += i->first.length();       offset++;   }   // второй проход: подставляем смещения   foreach(i, pcode) if(i->needfixat)       if(i->cmd.opcode==command::jz)           i->fix4(i->tgt->offset-(i->offset+i->length));       else if (i->cmd.opcode==command::echo)           i->fix4(offsets[i->cmd.imm]);`

`write(`

`1, &*code.begin(), code.size()); // вывод кода   foreach(i, strings)                     // вывод строк       write(1, i->first.c_str(), i->first.length()+1);   `

### Что получилось?

Компилируем компилятор, компилируем им тестовую программу, компилируем загрузчик, и запускаем:

`[tyomitch@home ~]$ **bison jsk.y**   [tyomitch@home ~]$ **c++ jsk.tab.c lex.yy.c -o jskc**   [tyomitch@home ~]$ **./jskc < test.jsk > code**   [tyomitch@home ~]$ **cc jskld.c -o jskld**   [tyomitch@home ~]$ **./jskld code**   Задумай число от 0 до 1000, а я буду угадывать   Это 500? (1=меньше, 2=больше, 3=попал) **1**   Это 249? (1=меньше, 2=больше, 3=попал) **3**   Ура! Я молодец!   `  
Интересно, во что наша программа скомпилировалась?

```
00: 55                 push rbp
01: 48 8b ef           mov rbp,rdi
04: 53                 push rbx
05: 33 c0              xor eax,eax
07: b9 e8 03 00 00     mov ecx,0x3e8
0c: 50                 push rax
0d: 51                 push rcx
0e: bf 80 01 00 00     mov edi,0x180
13: ff 55 10           call qword ptr [rbp+0x10]
16: 59                 pop rcx
17: 58                 pop rax
18: 50                 push rax
19: 51                 push rcx
1a: bf 00 00 00 00     mov edi,0x0
1f: ff 55 08           call qword ptr [rbp+0x8]
22: 59                 pop rcx
23: 58                 pop rax
24: 50                 push rax
25: 51                 push rcx
26: bf fa 00 00 00     mov edi,0xfa
2b: ff 55 10           call qword ptr [rbp+0x10]
2e: 59                 pop rcx
2f: 58                 pop rax
30: 50                 push rax
31: 51                 push rcx
32: bf e8 03 00 00     mov edi,0x3e8
37: ff 55 08           call qword ptr [rbp+0x8]
3a: 59                 pop rcx
3b: 58                 pop rax
3c: 50                 push rax
3d: 51                 push rcx
3e: bf 01 01 00 00     mov edi,0x101
43: ff 55 10           call qword ptr [rbp+0x10]
46: 59                 pop rcx
47: 58                 pop rax
48: 3b c1              cmp eax,ecx
4a: 0f 9e c2           setle dl
4d: 0f b6 d2           movzx edx,dl
50: 0b d2              or edx,edx
52: 0f 84 97 00 00 00  je 0xef
58: 8d 14 01           lea edx,[rcx+rax*1]
5b: d1 fa              sar edx,1
5d: 50                 push rax
5e: 51                 push rcx
5f: 52                 push rdx
60: bf bc 01 00 00     mov edi,0x1bc
65: ff 55 10           call qword ptr [rbp+0x10]
68: 5a                 pop rdx
69: 59                 pop rcx
6a: 58                 pop rax
6b: 50                 push rax
6c: 51                 push rcx
6d: 52                 push rdx
6e: 8b fa              mov edi,edx
70: ff 55 08           call qword ptr [rbp+0x8]
73: 5a                 pop rdx
74: 59                 pop rcx
75: 58                 pop rax
76: 50                 push rax
77: 51                 push rcx
78: 52                 push rdx
79: bf 26 01 00 00     mov edi,0x126
7e: ff 55 10           call qword ptr [rbp+0x10]
81: 5a                 pop rdx
82: 59                 pop rcx
83: 58                 pop rax
84: 50                 push rax
85: 51                 push rcx
86: 52                 push rdx
87: ff 55 00           call qword ptr [rbp+0x0]
8a: 93                 xchg ebx,eax
8b: 5a                 pop rdx
8c: 59                 pop rcx
8d: 58                 pop rax
8e: 89 45 18           mov dword ptr [rbp+0x18],eax
91: 83 fb 01           cmp ebx,0x1
94: 0f 94 c0           sete al
97: 0f b6 c0           movzx eax,al
9a: 0b c0              or eax,eax
9c: 0f 84 08 00 00 00  je 0xaa
a2: 8b 45 18           mov eax,dword ptr [rbp+0x18]
a5: 8d 4a ff           lea ecx,[rdx-0x1]
a8: eb 9e              jmp 0x48
aa: 83 fb 02           cmp ebx,0x2
ad: 0f 94 c0           sete al
b0: 0f b6 c0           movzx eax,al
b3: 0b c0              or eax,eax
b5: 0f 84 04 00 00 00  je 0xbf
bb: 03 c2              add eax,edx
bd: eb 89              jmp 0x48
bf: 8b 45 18           mov eax,dword ptr [rbp+0x18]
c2: 83 fb 03           cmp ebx,0x3
c5: 0f 94 c2           sete dl
c8: 0f b6 d2           movzx edx,dl
cb: 0b d2              or edx,edx
cd: 0f 84 0b 00 00 00  je 0xde
d3: bf a0 01 00 00     mov edi,0x1a0
d8: ff 55 10           call qword ptr [rbp+0x10]
db: 5b                 pop rbx
dc: 5d                 pop rbp
dd: c3                 ret
de: 50                 push rax
df: 51                 push rcx
e0: bf c4 01 00 00     mov edi,0x1c4
e5: ff 55 10           call qword ptr [rbp+0x10]
e8: 59                 pop rcx
e9: 58                 pop rax
ea: e9 59 ff ff ff     jmp 0x48
ef: bf 59 01 00 00     mov edi,0x159
f4: ff 55 10           call qword ptr [rbp+0x10]
f7: 5b                 pop rbx
f8: 5d                 pop rbp
f9: c3                 ret

```

Невооружённым глазом видно, как минимум, две актуальные оптимизации, которым нужен «глазок» больше одной команды:

-   когда команда заканчивается на `POP reg`, а следующая начинается на `PUSH reg`, обе эти инструкции можно удалить;
-   комбинацию `SETcc regl / MOVZX reg, regl / OR reg, reg / JZ offset` можно заменить на одну инструкцию `JNcc offset`, если `reg` не жив на выходе `JZ`.

Этой «оптимизацией в большой глазок» и займёмся в следующий раз. Более важная оставшаяся задача — [генерировать настоящий ELF](http://habrahabr.ru/blogs/programming/104104/), чтоб не нужен был самодельный загрузчик.
---
created: 2023-03-14T12:15:00 (UTC +03:00)
tags: [компиляция,генерация кода,elf,relocations]
source: https://habr.com/ru/post/104104/
author: Artyom Skrobov
---

# Компиляция. 10: компиляция в ELF / Хабр

> ## Excerpt
> В прошлый раз мы ограничились компиляцией джей-скрипа в файл в нашем собственном формате, которому требовался специальный загрузчик. Кроме того, мы задумали было...

---
Время на прочтение 13 мин

Количество просмотров 6.4K

В [прошлый раз](http://habrahabr.ru/blogs/programming/103402/) мы ограничились компиляцией джей-скрипа в файл в нашем собственном формате, которому требовался специальный загрузчик. Кроме того, мы задумали было пару оптимизаций исполнимого кода, требующих анализа соседних команд.

### Далее в посте:

1.  Оптимизация «в глазок»
2.  Стандартные функции
3.  Вывод в ELF
4.  Как это работает?
5.  Что получилось?

### Оптимизация «в глазок»

Чтобы реализовать задуманные оптимизации, во-первых, разделим общий вектор `code` на маленькие вектора сгенерированного машинного кода для каждой команды, и в конце будем склеивать их вместе.

Во-вторых, двух проходов нам уже не хватит: на первом проходе генерируем для каждой команды машинный код, на втором — выполняем оптимизации, на третьем — «заполировываем», заполняя смещения прыжков и строк. Одновременно с расчётом смещений прыжков будем по возможности заменять близкие (_near_) прыжки на короткие (_short_), так что на третьем проходе код дополнительно сократится, и потребуется ещё один проход — четвёртый; на нём вновь будем исправлять смещения прыжков, изменившиеся из-за сокращения кода.

В каждой команде придётся хранить количество сгенерированных `POP`, потому что по одному лишь машинному коду тяжело понять, является ли последний байт инструкцией `POP`, или просто совпал по значению. Количество сгенерированных `PUSH` нет надобности хранить: первый байт машинного кода расшифровывается однозначно.

```
    struct commandn {
// ...
        int offset;                     // от начала кода
        int needfixat;                  // для JZ, ECHO
        int popcnt;                     // INPUT, ECHO
        std::vector<unsigned char> code;// окончательный выполнимый
// ...
        void pop_back(int c = 1) {
            code.resize(code.size()-c);
        }
        void pop_front(int c = 1) {
            code.erase(code.begin(), code.begin()+c);
        }
    };

        // ...
        // "предварительная" генерация кода для JZ:
// предполагаем, что прыжок будет близкий
        case command::jz:
            if(!i->cmd.dest) // JMP off
                i->emit(0xe9);
            else {           // OR dst, dst / JZ off
                i->emit(0x0b, 0xc0|(i->cmd.dest-1)<<3|(i->cmd.dest-1));
                i->emit(0x0f, 0x84);
            }
            i->needfixat = i->code.size();
            i->emit4(0);
            break;
// ...
// в ECHO и INPUT добавляем счётчик popcnt;
// остальная генерация -- без изменений
        case command::input:
            foreach(rp, i->onenterp) if(*rp!=4) i->emit(0x50|(*rp-1));
            i->emit(0xff, 0x55, 0);
            if(i->cmd.dest!=1) i->emit(0x90|(i->cmd.dest-1));
            foreachr(rp, i->onenterp) if(*rp!=4) {
                i->emit(0x58|(*rp-1));
                i->popcnt++;
            }
            break;

    // ...
    // второй проход: оптимизация в глазок, расчёт смещений команд
    int offset = 0;
    foreach2(i,pcode,next) {
        i->offset = offset;
        // пары "POP-PUSH"
        while(i->popcnt && ((next->code[0]&0xfc) == 0x50) &&
            ((i->code.back()&3) == (next->code[0]&3)) &&
            // особый случай: нужно загрузить и пересохранить
            !((next->cmd.opcode==command::echo) && (next->cmd.dest==(next->code[0]&3)+1))) {
                i->pop_back();
                next->pop_front();
                i->popcnt--;
                if(next->needfixat) next->needfixat--;
        }
        // пары "сравнение-JZ"
        if((i->cmd.opcode>=command::eq) && (next->cmd.opcode==command::jz) &&
            (i->cmd.dest==next->cmd.dest) && !next->onexitp.count((physreg)next->cmd.dest)) {
                char cc = i->code[i->code.size()-5]; // cond code
                i->pop_back(6);     // SETcc / MOVZX
                next->code.clear(); // заменяем всю команду
                next->emit(0x0f, cc^0x11);
                next->needfixat = next->code.size();
                next->emit4(0);
        }
        offset += i->code.size();
    }
    // третий проход: окончательная генерация прыжков
    offset = 0;
    foreach(i, pcode) {
        i->offset = offset;
        if(i->cmd.opcode==command::jz) {
            int joffset = i->tgt->offset-(i->offset+i->code.size());
            if((joffset>=-128) && (joffset<128)) {  // заменяем команду
                if(!i->cmd.dest) {                  // JMP SHORT
                    i->code.clear();
                    i->emit(0xeb, (char)joffset);
                } else if(i->code[0]==0x0b && i->code[1]==0xc9) { // OR ECX, ECX
                    i->code.clear();
                    i->emit(0xe3, (char)joffset);   // JECXZ
                } else {
                    char cc = i->code[i->code.size()-5]; // cond code
                    i->pop_back(6);
                    i->emit(cc^0xf0, (char)joffset);// Jcc SHORT
                }
                i->needfixat = i->code.size()-1;    // в последнем байте смещение
            }
        }
        offset += i->code.size();
    }
    // четвёртый проход: подставляем смещения в прыжках
    foreach(i, pcode) if(i->needfixat)
        if(i->cmd.opcode==command::jz) {
            int joffset = i->tgt->offset-(i->offset+i->code.size());
            switch(i->code[i->needfixat]-1) {
            case 0xeb: case 0xe3: case 0x74: case 0x75: case 0x7c: case 0x7d: case 0x7e: case 0x7f:
                i->code[i->needfixat] = (char)joffset; break; // short
            default:
                i->fix4(joffset);
            }
        }
        else if (i->cmd.opcode==command::echo)
            i->fix4(offsets[i->cmd.imm]);
```

### Стандартные функции

В прошлый раз реализация стандартных функций `input,echoi,echos` была в нашем загрузчике. В этот раз загрузчика не будет; где же будут функции?

Мы можем, в принципе, вставлять их код в каждый генерируемый бинарник; но это некрасиво. Вместо этого скомпилируем их в отдельный файл `.o`, который будет потом линковаться с нашим файлом. Преимущество этого подхода — в изоляции платформо-зависимости: все различия между x86 и x64, которые, с точки зрения нашего компилятора, заключаются в способе вызова сишных функций, — спрячем в платформо-зависимую библиотечку, а сами будем генерировать платформо-независимый код.

Нам удобно, чтобы наши стандартные функции принимали параметр в `ESI`, а результат возвращали в `EAX`. Так и сделаем. Вот реализация для x64:

```
.global input,echoi,echos
.text
fd:     .asciz "%d"
fs:     .asciz "%s"
input:  push %rax
        lea  fd,   %edi
        xor  %eax, %eax
        mov  %rsp, %rsi
        call scanf
        pop  %rax
        ret
echoi:  lea  fd,   %edi
echo:   xor  %eax, %eax
        jmp  printf
echos:  movslq %esi, %rsi
        add  %rbp, %rsi
        lea  fs,   %edi
        jmp  echo
```

А вот — для x86:

```
.global input,echoi,echos
.text
fd:     .asciz "%d"
fs:     .asciz "%s"
input:  push %eax
        push %esp
        push $fd
        call scanf
        pop  %eax
pop2:   pop  %eax
        pop  %eax
        ret
echoi:  push %esi
        push $fd
echo:   call printf
        jmp  pop2
echos:  add  %ebp, %esi
        push %esi
        push $fs
        jmp  echo
```

### Вывод в ELF

Исполняемый код у нас практически готов; осталось лишь «упаковать» его так, чтобы ОС смогла его слинковать и запустить.

В памяти код будет состоять из тех же частей, что и прежде: код, данные, область связи для вызова стандартных функций. Отличие формата файлов `.o` от непосредственно исполнимых файлов — что в `.o` неизвестно сорасположение частей программы (_секций_) в памяти; поэтому компилятор не может сгенерировать ссылку из одной секции на адрес в другой. Вместо этого компилятор генерирует указание линкеру — _релокацию_, указывающую, какой адрес нужно вычислить при линковке, и как его нужно вычислять. Поэтому файлы `.o` в [спецификации формата ELF](http://www.skyfree.org/linux/references/ELF_Format.pdf) называются _релоцируемыми_.

Можно было бы разделить данные на две секции: отдельно инициализированные и неизменяемые (область связи и строки), отдельно неинициализированные и изменяемые (ячейки для вылитых регистров); но тогда на x86 нам не хватило бы регистров постоянно хранить базовые адреса обеих секций данных, — значит, пришлось бы генерировать по релокации на каждое обращение. Упростим себе жизнь, и обойдёмся одной секцией данных.  
По той же самой причине для вызова стандартных функций мы пользуемся областью связи: для вызова напрямую потребовалось бы создавать по релокации на каждый вызов. Сделаем область связи 24-байтной и на x86, и на x64 — опять же, для простоты и кроссплатформенности. На x64 это будет просто массив из трёх указателей (на `input,echoi,echos`); на x86 за каждым указателем будет следовать 4-байтная «заглушка».

Получается, что релокаций у нас будет всегда четыре: три адреса стандартных функций в области связи, и загрузка базового адреса данных в `RBP/EBP` первой командой программы. В итоге, генерация «релоцируемого» кода почти не будет отличаться от генерации «сплошного куска» в прошлый раз. В некоторых отношениях она даже упростится: поскольку сейчас строки будут храниться отдельно от кода, мы можем запоминать их смещения прямо на этапе синтаксического разбора; так мы полностью избавимся от «временных идентификаторов строк» и от этапа их привязки перед выводом скомпилированного кода. Кроме того, способ вызова стандартных функций теперь не будет зависеть от платформы.

```
    typedef std::map<std::string,int> stringmap;
    stringmap strings;
    int laststr = 24; // строки идут сразу за областью связи
    std::vector<stringmap::iterator> strdata; // порядок важен

    // ...
    // в коде свёртки VAL: ID '(' ARGS ')'
    if (!$1.compare("echo")) {
        if(!$3.size())
            yyerror("Input: too many arguments");
        $$ = 0;
        foreach(i, $3)
            if(!i->dest) // string
                if(strings.count(i->str))
                    emit(command::echo, 0, strings[i->str]);
                else {
                    strdata.push_back(strings.insert(stringmap::value_type(i->str,laststr)).first);
                    emit(command::echo, 0, laststr);
                    laststr += i->str.length()+1;
                }
            else
                emit(command::echo, i->dest, 0);
    }

    // ...
    // (на первом проходе по п-коду)
        case command::hlt:
            i->emit(0x5b, 0x5e, 0x5f, 0x5d); // POP EBX / POP ESI / POP EDI / POP EBP
            i->emit(0xc3);                   // RET
            break;
        case command::echo:    // PUSH live / MOV EDI, dst / CALL [EBP+?] / POP live
            foreach(rp, i->onexitp) if(*rp!=4) i->emit(0x50|(*rp-1));
            if(!i->cmd.dest) { // imm / [EBP+16]
                i->emit14(0xbe, i->cmd.imm);
                i->emit(0xff, 0x55, 16);
            } else {
                if(i->known.count(i->cmd.dest)) // imm / [EBP+4]
                    i->emit14(0xbe, i->known[i->cmd.dest]);
                else           // dst / [EBP+8]
                    i->emit(0x8b, 0xf0|(i->cmd.dest-1));
                i->emit(0xff, 0x55, 8);
            }
            foreachr(rp, i->onexitp) if(*rp!=4) {
                i->emit(0x58|(*rp-1));
                i->popcnt++;
            }
            break;
```

Релокации в ELF бывают в двух форматах: `rel` или `rela`. Формат `rel` компактнее, но линкеру проще работать с `rela`; поэтому при переходе на платформу x64 релокации типа `rel` объявили «осуждаемыми» (_deprecated_). Тем не менее, моя версия `ld` поддерживает `rel` в 64-битном коде, поэтому генерировать будем именно `rel`.

Сгенерируем восемь стандартных секций: пустую, `.shstrtab, .strtab, .symtab, .rel.text, .rel.data, .text, .data`. Заголовок ELF и первые шесть секций имеют предопределённое содержимое; только `.text` и `.data` наполняются в зависимости от сгенерированного кода.

```
// объявления ELF
#include <linux/elf.h>
#if ELF_CLASS == ELFCLASS32
#define Elf_Shdr Elf32_Shdr
#define Elf_Sym Elf32_Sym
#define Elf_Rel Elf32_Rel
#define ELF_R_INFO(s,t) (((s)<<8)+(unsigned char)(t))
#define R_32 R_386_32
#else
#define Elf_Shdr Elf64_Shdr
#define Elf_Sym Elf64_Sym
#define Elf_Rel Elf64_Rel
#define ELF_R_INFO(s,t) (((unsigned long)(s)<<32)+(t))
#define R_32 R_X86_64_32
#endif
#define ST_GLOBAL_NOTYPE STB_GLOBAL<<4

// ...
// после четырёх проходов генерации:
// привязка смещений строк больше не нужна
// осталось только вывести код
// пролог: PUSH EBP / PUSH EDI / PUSH ESI / PUSH EBX / MOV RBP, ...
const char prolog[] = {0x55,0x57,0x56,0x53,0x48,0xc7,0xc5,0,0,0,0};
offset += sizeof(prolog);
int alignment = ((offset+3)&~3) - offset; // выравнивание на dword
offset += alignment;
const struct {
    elfhdr hdr;
    Elf_Shdr Shdr[8];
    char shstrtab[64];
    char strtab[24];
    Elf_Sym symtab[6];
    Elf_Rel reltext[1];
    Elf_Rel reldata[3];
} elf =
    {{{ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3, ELF_CLASS, ELF_DATA, EV_CURRENT},        // identification
      ET_REL, ELF_ARCH, EV_CURRENT, 0, 0, sizeof(elfhdr), 0, sizeof(elfhdr), 0, 0, sizeof(Elf_Shdr),8, 1},
     {{0, SHT_NULL},
      {1, SHT_STRTAB, 0, 0, (char*)&elf.shstrtab-(char*)&elf, sizeof(elf.shstrtab), 0, 0, 1, 0},
      {11, SHT_STRTAB, 0, 0, (char*)&elf.strtab-(char*)&elf, sizeof(elf.strtab), 0, 0, 1, 0},
      {19, SHT_SYMTAB, 0, 0, (char*)&elf.symtab-(char*)&elf, sizeof(elf.symtab), 2, 2, 8,sizeof(Elf_Sym)},
      {27, SHT_REL, 0, 0, (char*)&elf.reltext-(char*)&elf, sizeof(elf.reltext), 3, 6, 8, sizeof(Elf_Rel)},
      {37, SHT_REL, 0, 0, (char*)&elf.reldata-(char*)&elf, sizeof(elf.reldata), 3, 7, 8, sizeof(Elf_Rel)},
      {47, SHT_PROGBITS, SHF_ALLOC|SHF_EXECINSTR, 0, sizeof(elf), offset, 0, 0, 4, 0},
      {53, SHT_PROGBITS, SHF_ALLOC|SHF_WRITE, 0, sizeof(elf)+offset, laststr+lastspill*4, 0, 0, 4, 0}},
     "\0.shstrtab\0.strtab\0.symtab\0.rel.text\0.rel.data\0.text\0.data",   // shstrtab
     "\0main\0input\0echoi\0echos",                                         // strtab
     {{},
      #if ELF_CLASS == ELFCLASS32
      {0, 0, 0, STT_SECTION, 0, 7},
      {1, 0, 0, ST_GLOBAL_NOTYPE, 0, 6},    // main
      {6, 0, 0, ST_GLOBAL_NOTYPE, 0, 0},    // input
      {12, 0, 0, ST_GLOBAL_NOTYPE, 0, 0},   // echoi
      {18, 0, 0, ST_GLOBAL_NOTYPE, 0, 0}},  // echos
      #else
      {0, STT_SECTION, 0, 7, 0, 0},
      {1, ST_GLOBAL_NOTYPE, 0, 6, 0, 0},    // main
      {6, ST_GLOBAL_NOTYPE, 0, 0, 0, 0},    // input
      {12, ST_GLOBAL_NOTYPE, 0, 0, 0, 0},   // echoi
      {18, ST_GLOBAL_NOTYPE, 0, 0, 0, 0}},  // echos
      #endif
     {{7, ELF_R_INFO(1,R_32)}},     // reltext
     {{0, ELF_R_INFO(3,1)},         // input
      {8, ELF_R_INFO(4,1)},         // echoi
      {16, ELF_R_INFO(5,1)}}        // echos
    };
write(1, &elf, sizeof(elf));
// вывод кода
write(1, prolog, sizeof(prolog));
foreach(i, pcode)
    write(1, &*i->code.begin(), i->code.size());
// дополнение до dword
const char zero[24] = {};
write(1, zero, alignment);
// область связи
write(1, zero, 24);
// вывод строк
foreach(i, strdata)
    write(1, (*i)->first.c_str(), (*i)->first.length()+1);
// резервируем место для выливания
ftruncate(1, sizeof(elf)+offset+laststr+lastspill*4);
```

### Как это работает?

В неизменном заголовке, который мы дописываем к сгенерированному коду, куча непонятных циферок. Что все они значат?  
Пройдёмся по порядку.

-   `ELFMAG0,ELFMAG1,ELFMAG2,ELFMAG3`: четыре «волшебных байта», с которых должен начинаться ELF-файл;
-   `ELF_CLASS,ELF_DATA,EV_CURRENT`: идентификаторы «битности» (ширины слова), порядка байтов в слове, и версии формата ELF. В зависимости от этих идентификаторов расшифровывается весь остальной заголовок (в его 32- и 64-битной версиях разный размер полей);
-   `ET_REL`: тип ELF-файла («релоцируемый», «исполняемый», «динамическая библиотека»);
-   `ELF_ARCH,EV_CURRENT`: идентификатор процессора и ещё раз версия формата;
-   `0,0`: адрес точки входа и смещение таблицы сегментов. В релоцируемых файлах нет ни того, ни другого;
-   `sizeof(elfhdr)`: смещение таблицы секций. У нас она пойдёт сразу же за заголовком;
-   `0`: флаги, на x86/x64 не определены;
-   `sizeof(elfhdr)`: размер заголовка;
-   `0,0`: размер и количество записей в таблице сегментов. У нас этой таблицы как не было, так и нет;
-   `sizeof(Elf_Shdr),8`: размер и количество записей в таблице секций;
-   `1`: номер секции, содержащей названия всех секций;
-   `"\0.shstrtab\0.strtab\0.symtab\0.rel.text\0.rel.data\0.text\0.data"`: названия всех секций, одно за другим. Первым символом строки должен быть `\0`, чтобы нулевое смещение указывало на пустое название;
-   `{0, SHT_NULL}`: секция №0 по стандарту должна быть пустой;
-   `1`: название секции (смещение внутри `shstrtab`);
-   `SHT_STRTAB`: тип секции (в данном случае, «таблица строк»);
-   `0`: флаги (чтение, запись, выполнение), задающие для секции защиту памяти. Для служебных секций, таких как таблицы имён, не нужно ничего из этого;
-   `0`: адрес секции в памяти. В релоцируемых файлах не определён;
-   `(char*)&elf.shstrtab-(char*)&elf,sizeof(elf.shstrtab)`: смещение секции в файле, и её размер;
-   `0,0`: два дополнительных поля, трактовка которых зависит от типа секции. Для таблицы строк не определены;
-   `1`: размер блока выравнивания; для строк — 1 байт, т.е. без выравнивания;
-   `0`: размер записи внутри секции. В таблице строк записи неопределённой длины;
-   `{11,SHT_STRTAB,0,0,(char*)&elf.strtab-(char*)&elf,sizeof(elf.strtab),0,0,1,0}`: ещё одна таблица строк. Отличается только именем (11—`.strtab`);
-   `{19,SHT_SYMTAB,0,0,(char*)&elf.symtab-(char*)&elf,sizeof(elf.symtab),2,2,8,sizeof(Elf_Sym)}`: секция типа «таблица символов». Содержимое дополнительных полей: первая двойка — номер секции с именами символов (предыдущая, т.е. `.strtab`), вторая двойка — номер первого глобального символа;
-   `{27,SHT_REL,0,0,(char*)&elf.reltext-(char*)&elf,sizeof(elf.reltext),3,6,8,sizeof(Elf_Rel)}`: секция типа «таблица релокаций». Содержимое дополнительных полей: ссылка на таблицу символов (предыдущая секция, она же №3) и на релоцируемую секцию (`.text`, она же №6);
-   `{37,SHT_REL,0,0,(char*)&elf.reldata-(char*)&elf,sizeof(elf.reldata),3,7,8,sizeof(Elf_Rel)}`: ещё одна таблица релокаций. Ссылается на ту же самую таблицу символов (№3) и на секцию `.data` (№7);
-   `{47,SHT_PROGBITS,SHF_ALLOC|SHF_EXECINSTR,0,sizeof(elf),offset,0,0,4,0}`: секция данных (`SHT_PROGBITS`) с возможностью выполнения (`SHF_EXECINSTR`) размером `offset`;
-   `{53,SHT_PROGBITS,SHF_ALLOC|SHF_WRITE,0,sizeof(elf)+offset,laststr+lastspill*4,0,0,4,0}`: секция данных с возможностью изменения (`SHF_WRITE`), в которой будут строки и 4-байтные ячейки для выливания;
-   `"\0main\0input\0echoi\0echos"`: имена символов (импортируемых и экспортируемых), в таком же формате, как имена секций;
-   `{}`: символ №0 должен остаться пустым;
-   `{0, 0, 0, STT_SECTION, 0, 7}`: безымянный (0) локальный символ, указывающий на секцию (`STT_SECTION`) №7, т.е. `.data`;
-   `{1, 0, 0, ST_GLOBAL_NOTYPE, 0, 6}`: глобальный (ST\_GLOBAL\_NOTYPE) символ по имени `main` (смещение имени 1), указывает на смещение 0 в секции №6, т.е. `.text`;
-   `{6, ST_GLOBAL_NOTYPE, 0, 0, 0, 0}`: глобальный символ по имени `input` (смещение имени 6), не относящийся ни к одной секции, т.е. импортируемый;
-   два других импортируемых символа, `echoi` и `echos`, определены аналогично.

Чтобы запутать программистов, структуры `Elf32_Sym` и `Elf64_Sym` определены с одинаковыми полями, но в разном порядке. У нас не остаётся выхода, кроме как написать два варианта кода, и при помощи `#ifdef` выбирать один из них.

Релокации типа `rel` состоят из троек «смещение релоцируемого поля, номер символа, код типа привязки». Первая релокация (`{7, ELF_R_INFO(1,R_32)}`) — в прологе, по смещению 7 от начала кода; она задаёт базовый адрес данных, загружаемый в `EBP/RBP`. Эта релокация ссылается на символ №1, т.е. на секцию `.data`. На любой архитектуре она имеет размер 32 бита. Код типа привязки при этом отличается: `R_386_32=1` на x86, и `R_X86_64_32=10` на x64.  
Три других релокации — в данных, получение адресов трёх импортируемых функций по смещениям 0,8,16. Эти три релокации ссылаются на импортируемые символы (№№3,4,5), и используют код привязки 1, всегда равный машинному слову (`R_386_32,R_X86_64_64`).

Полный код компилятора: [tyomitch.net.ru/jsk.y.elf.html](http://tyomitch.net.ru/jsk.y.elf.html)

Если вас заинтересовал сбор бинарников вручную, советую глянуть [способы уменьшения размеров ELF-файлов](http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html), от практически полезных трюков до чокнутых хаков; и заодно [примеры донельзя ужатых программ](http://www.muppetlabs.com/~breadbox/software/tiny/).

> Получился файл размером 45 байт: в пять раз меньше, чем на ассемблере, и в пятьдесят раз меньше, чем на Си. Мы выкинули из файла всё, что смогли; а то, что не смогли выкинуть, используем одновременно в двух-трёх целях.
> 
> Примерно половина значений в этом файле так или иначе нарушают стандарт ELF; нормальный программист постеснялся бы признаться, что такая программа — плод его рук. Поразительно, что Linux соглашается присвоить PID этому кошмару.
> 
> С другой стороны, про каждый байт в этом файле я могу объяснить, зачем он нужен. Часто вы можете сказать то же самое про скомпилированные вами файлы?

  

### Что получилось?

Теперь окончательный бинарник получается из двух независимых компонент, которые можем скомпилировать по отдельности.  

```
[tyomitch@home ~]$ as jskstd.s -o jskstd.o
[tyomitch@home ~]$ 
[tyomitch@home ~]$ bison jsk.y
[tyomitch@home ~]$ c++ jsk.tab.c lex.yy.c -o jskc
[tyomitch@home ~]$ 
[tyomitch@home ~]$ ./jskc < test.jsk > code.o
[tyomitch@home ~]$ cc jskstd.o code.o
[tyomitch@home ~]$ ./a.out
Задумай число от 0 до 1000, а я буду угадывать
Это 500? (1=меньше, 2=больше, 3=попал) 1
Это 249? (1=меньше, 2=больше, 3=попал) 3
Ура! Я молодец!
[tyomitch@home ~]$ objdump -d code.o

code.o:     file format elf64-x86-64

Disassembly of section .text:

0000000000000000 <main>:
   0:   55                      push   %rbp
   1:   57                      push   %rdi
   2:   56                      push   %rsi
   3:   53                      push   %rbx
   4:   48 c7 c5 00 00 00 00    mov    $0x0,%rbp
   b:   33 c0                   xor    %eax,%eax
   d:   b9 e8 03 00 00          mov    $0x3e8,%ecx
  12:   50                      push   %rax
  13:   51                      push   %rcx
  14:   be 18 00 00 00          mov    $0x18,%esi
  19:   ff 55 10                callq  *0x10(%rbp)
  1c:   59                      pop    %rcx
  1d:   58                      pop    %rax
  1e:   50                      push   %rax
  1f:   51                      push   %rcx
  20:   be 00 00 00 00          mov    $0x0,%esi
  25:   ff 55 08                callq  *0x8(%rbp)
  28:   be 38 00 00 00          mov    $0x38,%esi
  2d:   ff 55 10                callq  *0x10(%rbp)
  30:   59                      pop    %rcx
  31:   51                      push   %rcx
  32:   be e8 03 00 00          mov    $0x3e8,%esi
  37:   ff 55 08                callq  *0x8(%rbp)
  3a:   be 3f 00 00 00          mov    $0x3f,%esi
  3f:   ff 55 10                callq  *0x10(%rbp)
  42:   59                      pop    %rcx
  43:   58                      pop    %rax
  44:   3b c1                   cmp    %ecx,%eax
  46:   0f 8f 6c 00 00 00       jg     b8 <main+0xb8>
  4c:   8d 14 01                lea    (%rcx,%rax,1),%edx
  4f:   d1 fa                   sar    %edx
  51:   50                      push   %rax
  52:   51                      push   %rcx
  53:   52                      push   %rdx
  54:   be 64 00 00 00          mov    $0x64,%esi
  59:   ff 55 10                callq  *0x10(%rbp)
  5c:   5a                      pop    %rdx
  5d:   52                      push   %rdx
  5e:   8b f2                   mov    %edx,%esi
  60:   ff 55 08                callq  *0x8(%rbp)
  63:   be 6c 00 00 00          mov    $0x6c,%esi
  68:   ff 55 10                callq  *0x10(%rbp)
  6b:   ff 55 00                callq  *0x0(%rbp)
  6e:   93                      xchg   %eax,%ebx
  6f:   5a                      pop    %rdx
  70:   59                      pop    %rcx
  71:   58                      pop    %rax
  72:   89 85 04 01 00 00       mov    %eax,0x104(%rbp)
  78:   83 fb 01                cmp    $0x1,%ebx
  7b:   75 0b                   jne    88 <main+0x88>
  7d:   8b 85 04 01 00 00       mov    0x104(%rbp),%eax
  83:   8d 4a ff                lea    0xffffffffffffffff(%rdx),%ecx
  86:   eb bc                   jmp    44 <main+0x44>
  88:   83 fb 02                cmp    $0x2,%ebx
  8b:   75 05                   jne    92 <main+0x92>
  8d:   8d 42 01                lea    0x1(%rdx),%eax
  90:   eb b2                   jmp    44 <main+0x44>
  92:   8b 85 04 01 00 00       mov    0x104(%rbp),%eax
  98:   83 fb 03                cmp    $0x3,%ebx
  9b:   75 0d                   jne    aa <main+0xaa>
  9d:   be 9f 00 00 00          mov    $0x9f,%esi
  a2:   ff 55 10                callq  *0x10(%rbp)
  a5:   5b                      pop    %rbx
  a6:   5e                      pop    %rsi
  a7:   5f                      pop    %rdi
  a8:   5d                      pop    %rbp
  a9:   c3                      retq
  aa:   50                      push   %rax
  ab:   51                      push   %rcx
  ac:   be bb 00 00 00          mov    $0xbb,%esi
  b1:   ff 55 10                callq  *0x10(%rbp)
  b4:   59                      pop    %rcx
  b5:   58                      pop    %rax
  b6:   eb 8c                   jmp    44 <main+0x44>
  b8:   be dd 00 00 00          mov    $0xdd,%esi
  bd:   ff 55 10                callq  *0x10(%rbp)
  c0:   5b                      pop    %rbx
  c1:   5e                      pop    %rsi
  c2:   5f                      pop    %rdi
  c3:   5d                      pop    %rbp
  c4:   c3                      retq
```

`` `   Код выглядит сносно, хотя, наверное, и не дотягивает по качеству до сгенерированного llvm. Зато здесь каждый байт — собственными руками.` ``
